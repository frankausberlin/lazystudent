"""This class **scans** a **folder** and its **subfolders** for special **YAML**'s named by **ID** and provides an **organization** and **serialization** mechanism for the files."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_Yamler.ipynb.

# %% auto 0
__all__ = ['Yamler']

# %% ../nbs/00_Yamler.ipynb 4
class Yamler:
  def __init__(self, root='yamler', id_len=11, onInit={'config':False, 'files':False, 'data':False}, mediator=None):
    """ set workingfolder, scan for yamls, load main yamls and build data object
    """
    # init attributes
    self.tags, self.id_len, self.topics, self.original, self.onInit, self.mediator = [],  id_len, {}, {}, onInit, mediator
    # init current working topic - can be root ('_') or an other topic from self.topics
    self.data, self.folder, self.files, self.topic, self.config = None, None, None, '_', None

    # replace ~, create root folder if not exists
    folder = os.path.expanduser(root)
    if not os.path.exists (folder): os.makedirs (root)

    # create Yamler root dict with empty file list, folder and empty data / config objects
    self.topics['_'] = {'files':[], 'folder':root, 'data': {}, 'config': {}}
    #self.root ={'files':[], 'folder':folder, 'data': {}, 'config': {}}

    # set root to working folder
    self.switch()

    # load yamls like in onInit
    self.initialize ()

    # use the subfolders as topics
    for item in os.listdir(f"{self.folder}/"):
      if os.path.isdir(os.path.join(f"{self.topics['_']['folder']}/", item)):

        # create topic without file list
        self.topics[item] = {'files':[], 'data': {}, 'config': {}, 'folder': f"{self.topics['_']['folder']}/{item}"}

        # load yamls like in onInit
        self.initialize (topic=item)

    # set root to working folder back - it changed by initializing topics
    self.switch()

    # say ready
    if self.mediator: self.mediator.notify ("onYamlerReady", list(self.topics.keys()))

  def activate (self, topic=None):
    self.switch (topic)
    self.scan ()
    if self.mediator: self.mediator.notify ("onYamlerActivate", self.topic)

  def initialize (self, topic=None):
    if topic: self.switch (topic)

    # build file list
    if self.onInit['files']: self.scan ('files')

    # config data ('__')
    if self.onInit['config']: self.scan ('config')

    # load all yamls for id
    if self.onInit['data']: self.scan ('data')

  def switch (self, topic=None):
    if not topic: topic = '_'
    # set topic to current
    self.topic, self.data,                  self.config,                  self.folder,                  self.files =\
    topic,      self.topics[topic]['data'], self.topics[topic]['config'], self.topics[topic]['folder'], self.topics[topic]['files']


  def scan (self, part='all'):
    if (part == 'files' or part == 'all') and not self.files:
      self.files = [f for f in os.listdir(f"{self.folder}") if f.split('.')[-1] == 'yml']

    if (part == 'config' or part == 'all') and not self.config:
      files = self.files if self.files else [f for f in os.listdir(f"{self.folder}") if f.split('.')[-1] == 'yml']
      for f in files:
        if f[:2] == '__' and not f[2:-4] in self.config:
          with open (f"{self.folder}/{f}", 'r') as stream:
            self.config[f[2:-4]] = yaml.safe_load(stream)
          self.original[f"{self.folder}/{f}"] = Yamler.dictcopy (self.config[f[2:-4]])

    if (part == 'data' or part == 'all') and not self.data:
      self.data = {}
      for id in self.ids():
        # only if not done before
        if id in self.data: continue # already loaded

        # main-yaml
        self.data[id] = {'_':{}} # empty data obj for id
        with open (f"{self.folder}/{id}.yml", 'r') as stream:
          self.data[id]['_'] = yaml.safe_load(stream)
        self.original[f"{self.folder}/{id}.yml"] = Yamler.dictcopy (self.data[id]['_'])

        # tag-yamls
        taglist = [f[self.id_len+1:-4] for f in self.files if len(f) > self.id_len+5 and f[self.id_len] == '_']
        for tag in taglist:
          # remember found tags
          if tag not in self.tags: self.tags.append(tag)
          try: # load if exists
            with open (f"{self.folder}/{id}_{tag}.yml", 'r') as stream: self.data[id][tag] = yaml.safe_load(stream)
            self.original[f"{self.folder}/{id}_{tag}.yml"] = Yamler.dictcopy (self.data[id][tag])
          except: pass

  def dumpChanged (self,fname,obj):
    count = 0
    # only if new or changed
    if not fname in self.original or self.original[fname] != obj:
      # write it
      with open(fname, 'w') as file: yaml.dump(obj, file)
      count += 1
      # delete old original
      if fname in self.original: del self.original[fname]
      # make a copy to compare if changed by next dump
      self.original[fname] = Yamler.dictcopy (obj)
    return count

  def dump (self):
    count = 0
    # write __<config>.yml's
    for config_yml in self.config:
      fname, obj = f"{self.folder}/__{config_yml}.yml", self.config[config_yml]
      count += self.dumpChanged (fname, obj)

    # write <id>.yml's
    for id in self.data:

      # main-yaml
      if not '_' in self.data[id]: continue
      fname, obj = f"{self.folder}/{id}.yml", self.data[id]['_']
      count += self.dumpChanged (fname, obj)

      # tag-yamls
      for tag in self.tags:
        if not tag in self.data[id]: continue
        fname, obj = f"{self.folder}/{id}_{tag}.yml", self.data[id][tag]
        count += self.dumpChanged (fname, obj)
    return count

  def ids(self):
    # get files
    files = self.files if self.files else [f for f in os.listdir(f"{self.folder}") if f.split('.')[-1] == 'yml']
    # parse ids - criterias: fname don't start with '__', correkt len and its a .yml-file
    return list(set([f[:-4] for f in files if f[:2] != '__' and len (f) == (self.id_len+4) and f[-4:] == '.yml']))

  def dictcopy (d):
    ret = {}
    if type(d) == dict: # data is dict
      ret = {}
      for k in d: # keys
        if type(d[k]) == dict: ret[k] = Yamler.dictcopy(d[k])
        if type(d[k]) == list: ret[k] = Yamler.dictcopy(d[k])
        else:                  ret[k] = d[k]
    elif type(d) == list: # data is list
      ret = []
      for i in d: # items
        if type(i) == dict: ret.append (Yamler.dictcopy(i))
        if type(i) == list: ret.append (Yamler.dictcopy(i))
        else:               ret.append (i)
    return ret

  def remove (self, id, deleteFiles=True):
    if deleteFiles:     os.system (f'rm {self.folder}/{id}*.yml')
    if id in self.data: del self.data[id]

  def store(self, id, data=None):
    pass





