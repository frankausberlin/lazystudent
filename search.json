[
  {
    "objectID": "lazystudentnotebook.html#what-kind-of-notebook-is-this",
    "href": "lazystudentnotebook.html#what-kind-of-notebook-is-this",
    "title": "The lazy student notebook",
    "section": "What kind of notebook is this",
    "text": "What kind of notebook is this\n\nIt contains an application called ‚ÄúLazy Student‚Äù which allows you to use transcripts of (lecture) videos as input for AI prompts.\nYou can use it to make chapters and summaries or just talk with an AI about the video.\nIf you just want to use the software go to the last cell and run it.\n\nBut if you want a quick peek down the rabbit hole of modern software development, go cell by cell.\nWelcome to the notebook - it takes your laziness to a new level\nüòâNo, of course not, I‚Äôm just kidding.\nThe inspiration came when I came across prompt engineering. I thought, a prompt like ‚ÄúCreate a summary‚Äù needs input, why not the transcription of the lecture video I‚Äôm watching, and hey presto: the idea for ‚ÄúLazy Student‚Äù was born.\nSo I started programming - and I programmed and programmed, and more and more ideas came to me.\nMaybe you remember being in a situation where you had to work hard to get your code error-free and a voice inside you said: ‚ÄúThis isn‚Äôt good. This code that can best be described as obese and it could be done better. If I only had the time to do a careful refactoring.‚Äù\nWell, I‚Äôm a guy who had this time.\nAnd so, this is not just a tool to generate chapters, descriptions and summaries from video transcriptions, it is much more about the following key points:\nRefactoring * The first faulty version of Lazy Student can be found right at the beginning * Using OO techniques (inheritance, classes, design patterns) in new version. * Using a Component oriented software design. * ‚ÄòBig boys‚Äô development process - github, nbdev, pypi, conda\nPython specials * Working with ipywidgets, JavaScript integration and the YouTube-API * Using GDrive with Rclone to provide a YAML-based persistence mechanism * Using the components as code snippets collection for Google Colab. * Using nbdev to provide the components in a library, hosting on pypi and conda.\nAI topics * It has a little editor for prompt engineering. * A loop function allows using transcription fragments in prompt. * Using openai api and its chat completition mechanism. * A chat client for openai, gpt4all and compatible models\nPS: The flow of the refactoring process is reflected in the order of the components.",
    "crumbs": [
      "<font size='0' color='#ffffff'>The lazy student notebook</font>"
    ]
  },
  {
    "objectID": "lazystudentnotebook.html#view-of-the-legacy",
    "href": "lazystudentnotebook.html#view-of-the-legacy",
    "title": "The lazy student notebook",
    "section": "View of the legacy",
    "text": "View of the legacy\nFirst we look at the code of the old version and try to find an answer to the mother of all refactoring questions: ‚Äòwhy my code is smelling so bad?‚Äô. Well, some points immediately catch the eye.\n\nTo much code for one cell.\nNo object oriented sofware design - just globals and functions.\nNo clear structuring into tasks or units.\nand so much more - look in the code\n\nA word of explanation is needed here. LazyStudent is part of a notebook called snippetpearls. This is a small collection of code snippets for the Google Colab environment. Therefore, the code should be completely in one cell. But as the functionality grew, I also moved away from the basic idea of ‚Äã‚Äãthe ‚Äòcode snippet‚Äô.\nI used the code snippet several times. Sometimes I needed these flex wrap layout buttons, other times the YAML mechanism. Ultimately, all these considerations led me to the decision to do a refactoring. And to the decision to do this with a complete redesign of the software architecture using a component-oriented approach. This means that I divide the overall functionality into smaller, stable and self-contained units, called components.\n\n\n\nü•≥fun fact\n\n\nDid you know that you can consider Colab notebooks as a component ware and code snippets as components?A component ware mainly has the following features: * Components can run independently, usually with an exemplary default behavior or value. * Possibility of using the component at code level, e.g.¬†through inheritance. * Provision of a runtime environment in the form of a framework or middleware. * A development environment that enables the use of the component.\nIn this thought experiment, the code snippets are the components, Google Forms ensure a graphical representationand parameterization, the runtime environment would then be the Jupyter runtime and the development environmentwould be the jupyter server. (I like to cite Borland Delphi (RIP) as a classic example for component ware.)\n\n\n\nOk, here comes the legacy‚Ä¶\nüòâ The author assumes no liability for psychological damage caused by viewing the old code.\n\ndeactivate = True   #@param {type:\"boolean\"}\n#@markdown [&lt;font size='+2' color='#005F6A'&gt;**lazy student**&lt;/font&gt;](https://github.com/frankausberlin/lazy-student)&lt;br&gt;\n#@markdown This is for the work-optimized student - openai's [prompt engineering](https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/) (**GPT**) with access to (collections of) video transicriptions, focused on bilingualism and yaml persistence.\n#@markdown * Choose your language and (your collection - select a course and) a video - build your chapters - clean it, prompt it, loop it - be creative...\n#@markdown * The prompt functions needs an **[openai](https://platform.openai.com/account/usage)** account for send your gpt request direct out of the widget.\n#@markdown * It manages collections on your **session**, **gdrive** (~ 100 MB) or **local runtime** - there are some examples (new ones can easily be added):\n#@markdown &gt; * ['Practical Deeplearning for Coders'](https://course.fast.ai/) by Jeremy Howard (**folder dlfc**)\n#@markdown &gt; * ['MIT Introduction to Deep Learning'](http://introtodeeplearning.com/) by MIT (**folder mit**)\n#@markdown &gt; * [A collection by Stanford](https://www.youtube.com/@stanfordonline/playlists?view=50&sort=dd&shelf_id=4): CS221, CS224, CS229, CS330 (**folder stanford**).\n#@markdown &gt; * [StatQuest](https://statquest.org/) Collections by the singing guy [Josh Starmer](https://www.youtube.com/@statquest) (**folder statquest**).\n#@markdown &gt; * [Calculus](https://www.wikiwand.com/en/articles/Calculus) & Co - a math playlist collection from different sources (**folder mathpl**).\n#@markdown * A **collection** is a list of several youtube **playlists** (playlists.yml) with its own **folder** for the **created yml** files.\n#@markdown * As alternative to the collections there is a **single video** selection mode.\n#@markdown * More questions? **Look in the help tab or code** - there are more detailed descriptions.\n#@markdown ---\n\nif not deactivate:\n  helptext=\"\"\"Basic concepts:\n  * Bilangualism\n    - The playlists.yml holds the description and the videos id of every playlist.\n    - You have language specific (&lt;cc&gt;) yamls:\n      - &lt;vid&gt;_&lt;cc&gt;.yml       - the transcription for a video\n      - &lt;vid&gt;_loops_&lt;cc&gt;.yml - the loops for a video\n    - Inside the Yamls 'prompts' and '&lt;vid&gt;_info.yml' you have have multi\n      languages for every prompt / aichapters.\n  * The yamls created\n    - playlists.yml           : Infos and videos list for every playlist\n    - prompts.yml             : The prompts - for all languages\n    - &lt;vid&gt;_en.yml            : The english transcription\n    - &lt;vid&gt;_&lt;cc&gt;.yml          : The &lt;cc&gt; transcription (see country codes below)\n    - &lt;vid&gt;_info.yml          : Description, chapters and aichapters for video\n    - &lt;vid&gt;_loops_&lt;en|cc&gt;.yml : Prompt loops history for video for a language\n  * There is a persistence mechanic:\n    - Select the correct working folder first:\n      - if you use local runtime the working folder is located in your home folder\n                        '~/&lt;main_folder&gt;'\n      - if you are hosted and you checked 'use_gdrive...' your working folder is\n                        '/gdrive/MyDrive/&lt;main_folder&gt;'\n      - if you are hosted and you unchecked 'use_gdrive...' your working folder is\n                        '/content/&lt;main_folder&gt;'\n    - It only creates folders (main folder, collection folders) if not exists.\n    - Yamls are only generated when they are needed:\n      - playlists.yaml               by first run\n      - *_en, *_&lt;cc&gt;, *_info files   by selection of a video\n      - prompts.yml                  by save\n      - *_loops_&lt;cc&gt;.yml             after doing loop.\n    - Simple prompts are not stored.\n  * Without api-key for openai the features using the api are disabled\n    ('send', 'loop', 'build' and 'translate') but the prompt editor works.\n  * The 'aichapters' prompt is a system prompt and can not be deleted but modified\n    with a 70 char limit used for response.\n  * The textareas does show the token count (the cyan text), the token factor\n    ('*'-textfield, editable), the request temperatur ('¬∞'-textfield, editable).\n  * Select a prompt (green button) and a chapter -&gt; click show-button to create\n    the prompt in the textarea and click send to send the textarea (!) as request\n    and wait for response.\n  * Between show and send you have the possibility to edit the prompt.\n  * The loop mechanic takes the transcript from every chapter as input for the\n    selected prompt and show the response in the textarea - be carefull it cannot\n    be interupted (check token count in chapters - 16000 token max).\n  * The api is not very stable - sometimes it hangs (about 1-3 minutes)\n  * There are 3 attempts for all requests - so mostly the result is given.\n\n  Notes UI:\n  * When you run the cell it builds the widgets for the selected collection / mode.\n  * You have a accordion tabed gridbox for every plalist and the prompt editor.\n  * On start it takes first video of first playlist and try to create the chapters\n    out of the description.\n  * It creates the video radio buttons and the buttons to work with video:\n      'all &gt;&gt;&gt;&gt;', 'clean', 'from description', 'auto', 'aichaps', 'build'\n    and the prompt-buttons\n  * If no chapters in description you can use the auto button. It takes the number\n    (value left) as count for tokens in a chapter and generate a corresponding\n    timestamp list for use for chapter buttons.\n  * There are important infos in tooltips:\n    - 'all &gt;&gt;&gt;&gt;'-button: the original description of the video.\n    - prompt-buttons: the prompt textes\n    - all other buttons: the description what they do.\n  * There are are log message line below the accordion tab - shows current events.\n  * With a small **editor** you have the possibility to have a little prompt\n    engineering **fun** (note the 4000 token limit).\n  * When you add a new prompt in the editor it will be shown as green prompt\n    button for using with videos.\n\n  Notes miscellaneous:\n  * The current select video / playlist is set in globals: function globalize().\n  * The request uses the textare text - you can reduce token len when you use\n    the clean-button before send.\n  * The libs pytube, youtubesearchpython, youtube_transcript_api and openai\n    (if selected) will be installed.\n\n  Widgets structure:\n\n  mainAccordion\n    |\n    + [gb_maingb] - gridbox for every playlist -&gt; set in globalize() to current selection\n    |    + vb_vidsel - area left with video selection and buttons\n    |    |    + wi_firstw - HTML youtube link / HBox[tx_singvid, bu_singvid]\n    |    |    + rb_vidsel - the rbs for video selection\n    |    |    + bu_allchp - the 'all &gt;&gt;&gt;&gt;' button\n    |    |    + hb_cleanb\n    |    |    |    + children0 txt for parameter - no global\n    |    |    |    + bu_cleanb - clean button\n    |    |    + bu_frodes - from description button\n    |    |    + hb_autchp\n    |    |    |    + children0 txt for parameter - no global\n    |    |    |    + bu_autchp - auto button\n    |    |    + hb_aichbu\n    |    |    |    + bu_fromai, bu_aichap - buttons 'from ai' and 'aichaps'\n    |    |    + [prompt_buttons] - button for every prompt\n    |    + vb_chpare - big area with chapter selector and transcriptions\n    |         + bx_chpsel - box for chapter selection\n    |         |    + childrenN - button for every chapter\n    |         + hb_contrl - control areas for en / xx\n    |         |    + vb_enCtrl\n    |         |    |    + hb_enCtrl\n    |         |    |    |    + children0 (HTML) - token count - no global\n    |         |    |    |    + children1 (Label) - prompt name - no global\n    |         |    |    |    + children2 (Text) - input tf for temperatur - no global\n    |         |    |    |    + bu_enShow, bu_enSend, bu_enLoop - buttons\n    |         |    |    + hb_enSele\n    |         |    |         + children0(Box)\n    |         |    |              + bu_enView, bu_enResu - the green and red buttons\n    |         |                   + [children2-n] - blue button for every loop\n    |         |    |         + children1(Box)\n    |         |    |              + bu_enLdel - the loop del button\n    |         |    + vb_xxCtrl\n    |         |         + hb_xxCtrl\n    |         |         |    + children0 (HTML) - token count - no global\n    |         |         |    + children1 (Label) - prompt name - no global\n    |         |         |    + children2 (Text) - input tf for temperatur - no global\n    |         |         |    + bu_xxShow, bu_xxSend, bu_xxLoop - buttons\n    |         |         + hb_xxSele\n    |         |              + children0(Box)\n    |         |                   + bu_xxView, bu_xxResu - the green and red buttons\n    |         |                   + [children2-n] - button for every loop\n    |         |              + children1(Box)\n    |         |                   + bu_xxLdel - the loop del button\n    |         + hb_transc - area with transcriptions\n    |              + ta_enTran - english transcription\n    |              + ta_xxTran - xx transcription\n    + gb_proedi - prompt editor tab\n    |    + rb_prompt - the prompt radio-buttons\n    |    + vb_proedi - parent for the prompt widgets\n    |         + hb_probut - the buttons line\n    |              + bu_addprmt, bu_delprmt, bu_savprmt, bu_transla\n    |         + tx_protit - prompt title\n    |         + hb_prompt - prompt text\n    + ta_helper - help tab\n  \"\"\"\n  import os, yaml, getpass, time\n  try:\n    from pytube                   import  Playlist\n    from youtubesearchpython      import  Video\n    from youtube_transcript_api   import  YouTubeTranscriptApi\n  except:\n    print ('stay tuned - installing stuff')\n    os.system ('pip install pytube youtube-search-python youtube-transcript-api')\n  from   ipywidgets               import  Accordion, VBox, HBox, Box, GridBox, HTML, Tab\n  from   ipywidgets               import  Textarea, Text, RadioButtons, Button, Layout, Label\n  from   datetime                 import  datetime\n  from   pytube                   import  Playlist\n  from   youtubesearchpython      import  Video\n  from   youtube_transcript_api   import  YouTubeTranscriptApi\n\n  # colab forms\n  use_gdrive_for_persistence                = True   #@param {type:\"boolean\"}\n  country_code_for_the_translation_language = 'de'   #@param {type:\"string\"}\n  yes_i_have_this_chatgpt_openai_account    = False   #@param {type:\"boolean\"}\n  use_english_for_ai_auto_chapters          = True  #@param {type:\"boolean\"}\n  used_model                                = 'gpt-4-turbo' #@param ['gpt-3.5-turbo', 'gpt-3.5-instruct', 'gpt-4', 'gpt-4-turbo', 'gpt-4o']\n\n\n  ####################################################################################################################################\n  ################################################## defaults / customization ########################################################\n  ####################################################################################################################################\n  playlist_prefix       = 'https://www.youtube.com/playlist?list='\n  video_prefix          = 'https://www.youtube.com/watch?v='\n  main_folder           = 'lazy_collections'\n  selected_collection   = 'Practical Deep Learning for Coders / fast.ai live coding & tutorials' #@param ['Calculus & Co - a math playlist collection', 'Single video selection','StatQuest!!!-Collections by the singing guy Josh Starmer','MIT courses around deep learning','Practical Deep Learning for Coders / fast.ai live coding & tutorials', \"A collection of free Stanford courses: CS221, CS224, CS229, CS330\"]\n\n  #\n  #         ||      your                                   /\\\n  #      \\ \\||/ /   collection                            /||\\\n  #       \\ \\/ /    here                                   ||\n  #        \\  /                              (don't forget: add to param list)\n  #         \\/\n  #\n  # if 'some unique' in selected_collection:\n  #   courses = { 'Course 1'  : 'PL******',\n  #               'Course 2'  : 'PL******',\n  #               'Course 3'  : 'PL******'}\n  #   folder_for_playlist_collection = 'yourfolder'\n\n  # The collections\n  if 'StatQuest' in selected_collection:\n    courses = { 'Histograms Clearly Explained - #66DaysOfData'                                                : 'PLblh5JKOoLUJUNlfvCNhJMNjNNpt5ljcR',\n                'Histograms Clearly Explained - Statistics Fundamentals'                                      : 'PLblh5JKOoLUK0FLuzwntyYI10UQFUhsY9',\n                'A Gentle Introduction to Machine Learning'                                                   : 'PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI',\n                'Neural Networks / Deep Learning'                                                             : 'PLblh5JKOoLUIxGDQs4LFFD--41Vzf-ME1' }\n    folder_for_playlist_collection = 'statquest'\n\n  if 'MIT courses' in selected_collection:\n    courses = { '6.0001 Introduction to Computer Science and Programming in Python'                           : 'PLUl4u3cNGP63WbdFxL8giv4yhgdMGaZNA',\n                'MIT 18.S096 Matrix Calculus For Machine Learning And Beyond'                                 : 'PLUl4u3cNGP62EaLLH92E_VCN4izBKK6OE',\n                'MIT 6.S191: Introduction to Deep Learning'                                                   : 'PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI',\n                'EfficientML.ai Lecture, Fall 2023, MIT 6.5940'                                               : 'PL80kAHvQbh-pT4lCkDT53zT8DKmhE0idB' }\n    folder_for_playlist_collection = 'mit'\n\n  if 'Stanford' in selected_collection:\n    courses = { 'CS221:  2021 - Artificial Intelligence: Principles and Techniques (Percy Liang)'             : 'PLoROMvodv4rOca_Ovz1DvdtWuz8BfSWL2',\n                'CS221:  2019 - Artificial Intelligence: Principles and Techniques (Percy Liang)'             : 'PLoROMvodv4rO1NB9TD4iUZ3qghGEGtqNX',\n                'CS224N: 2021 - NLP with Deep Learning (Christopher Manning)'                                 : 'PLoROMvodv4rOSH4v6133s9LFPRHjEmbmJ',\n                'CS224W: 2021 - Machine Learning with Graphs (Jure Leskovec)'                                 : 'PLoROMvodv4rPLKxIpqhjhPgdQy7imNkDn',\n                'CS224U: 2021 - Natural Language Understanding (Christopher Potts)'                           : 'PLoROMvodv4rPt5D0zs3YhbWSZA8Q_DyiJ',\n                'CS229:  2018 - Machine Learning Full Course (Andrew Ng)'                                     : 'PLoROMvodv4rMiGQp3WXShtMGgzqpfVfbU',\n                'CS229:  2019 - Machine Learning Course (Anand Avati)'                                        : 'PLoROMvodv4rNH7qL6-efu_q2_bPuy0adh',\n                'CS330:  2022 - Deep Multi-Task & Meta Learning - What is multi-task learning? (Chelsea Finn)': 'PLoROMvodv4rNjRoawgt72BBNwL2V7doGI' }\n    folder_for_playlist_collection = 'stanford'\n\n  if 'Deep Learning for Coders' in selected_collection:\n    courses = { 'Practical Deep Learning for Coders 2022'                                                     : 'PLfYUBJiXbdtSvpQjSnJJ_PmDQB_VyT5iU',\n                'Practical Deep Learning 2022 Part 2'                                                         : 'PLfYUBJiXbdtRUvTUYpLdfHHp9a58nWVXP',\n                'fast.ai live coding & tutorials'                                                             : 'PLfYUBJiXbdtSLBPJ1GMx-sQWf6iNhb8mM',\n                'APL & array programming'                                                                     : 'PLfYUBJiXbdtSgU6S_3l6pX-4hQYKNJZFU',\n                'Practical Deep Learning for Coders (2020)'                                                   : 'PLfYUBJiXbdtRL3FMB3GoWHRI8ieU6FhfM',\n                'Practical Deep Learning for Coders 2019'                                                     : 'PLfYUBJiXbdtSIJb-Qd3pw0cqCbkGeS0xn' }\n    folder_for_playlist_collection = 'dlfc'\n\n  if 'Calculus & Co' in selected_collection:\n    courses = { 'Essence of calculus, by Grant Sanderson (3Blue1Brown)'                                       : 'PLZHQObOWTQDMsr9K-rj53DwVRMYO3t5Yr',\n                'Computational Linear Algebra, by Rachel Thomas (fastai)'                                     : 'PLtmWHNX-gukIc92m1K0P6bIOnZb-mg0hY',}\n    folder_for_playlist_collection = 'mathpl'\n\n\n  ####################################################################################################################################\n  ########################################## single video / folders / globals / playlists.yaml #######################################\n  ####################################################################################################################################\n  # Single video\n  if 'Single video selection' in selected_collection:\n    courses = {'Single video selection':'no playlist'}\n    folder_for_playlist_collection = 'singles'\n\n  # gdrive only for hosted runtime\n  if use_gdrive_for_persistence and os.path.expanduser('~') == '/root':\n    from google.colab import drive\n    if not 'gdrive'  in os.listdir('/'): drive.mount('/gdrive')\n    # working folder gdrive\n    if not 'MyDrive' in os.getcwd(): os.chdir ('/gdrive/MyDrive')\n  else:\n    # working folder hosted / local\n    if os.path.expanduser('~') == '/root':  os.chdir ('/content')\n    else:                                   os.chdir (os.path.expanduser('~'))\n\n  # create / change to main folder\n  if main_folder in os.listdir():  os.chdir (main_folder)\n  else:\n    # check if parent main folder\n    if main_folder in os.getcwd(): os.chdir('..')\n    else:\n      os.mkdir (main_folder)\n      os.chdir(main_folder)\n\n  # create / change to collection folder\n  if folder_for_playlist_collection in os.listdir(): os.chdir (folder_for_playlist_collection)\n  else:\n    os.mkdir (folder_for_playlist_collection)\n    os.chdir(folder_for_playlist_collection)\n\n  # load\n  if os.path.exists('playlists.yml'):\n    playlists_yaml = yaml.load(open('playlists.yml', 'r'), Loader=yaml.FullLoader)\n  # or new (language)\n  try:    playlists_yaml['language'] = country_code_for_the_translation_language.split(' ')[0]\n  except: playlists_yaml             = {'language':country_code_for_the_translation_language.split(' ')[0]}\n  cc                                 = playlists_yaml['language']\n\n  # playlist loop\n  for i,title in enumerate(courses):\n    # single video\n    if courses[title] == 'no playlist':\n      try:    vl = playlists_yaml['no playlist']['videos']\n      except: vl = []\n      playlists_yaml['no playlist'] = {'title':'single videos', 'description':'hand added videos', 'videos':vl}\n      break\n\n    # check if infos exists\n    if not courses[title] in playlists_yaml:\n      # lazy using pytube\n      from pytube import Playlist\n      try:      pl     = Playlist(f'{playlist_prefix}{courses[title]}')\n      except:   raise    Exception ('BIG_OOPS')\n      try:      descr  = pl.description\n      except:   descr  = 'no description in pytube'\n      try:      links  = [link for link in pl]\n      except:   links  = []\n      videos           = [f\"{link.split('?v=')[-1]} Video {vnr+1}\" for vnr, link in enumerate(links)]\n      playlists_yaml[courses[title]] = {'title':title, 'description':descr, 'videos':videos}\n  # write playlists.yml\n  yaml.dump (playlists_yaml, open('playlists.yml', 'w'))\n\n\n  ####################################################################################################################################\n  ########################################################## helper ##################################################################\n  ####################################################################################################################################\n  def globalize ():\n    \"\"\" set globals (widgets and relevant infos) to the current accordion tab / selected video\n        see widgets structure in help text\n    \"\"\"\n    # relevant infos\n    global vPositions, videoInfos, enTrans, xxTrans, courses, playlists_yaml, cc, acIndex, plid, rbIndex, vid, countryCodes\n    global store_en, store_xx\n    # widgets\n    global mainAccordion,        gb_maingb, vb_vidsel, vb_chpare, wi_firstw, rb_vidsel, bu_allchp, hb_cleanb, bu_frodes\n    global hb_autchp, hb_aichbu, bu_cleanb, bu_autchp, bu_fromai, bu_aichap, bx_chpsel, hb_contrl, hb_transc, vb_enCtrl\n    global vb_xxCtrl, hb_enCtrl, hb_xxCtrl, bu_enShow, bu_enSend, bu_enLoop, bu_xxShow, bu_xxSend, bu_xxLoop, hb_enSele\n    global hb_xxSele, bu_enView, bu_enResu, bu_enLsel, bu_xxView, bu_xxResu, bu_xxLsel, ta_enTran, ta_xxTran\n\n    # set globals to current displayed playlist\n    gb_maingb                       = mainAccordion.children[mainAccordion.selected_index]\n    vb_vidsel, vb_chpare            = gb_maingb.children[0], gb_maingb.children[1]\n\n    # vb_vidsel - area left with video selection and buttons\n    wi_firstw, rb_vidsel, bu_allchp = vb_vidsel.children[0], vb_vidsel.children[1], vb_vidsel.children[2]\n    hb_cleanb, bu_frodes, hb_autchp = vb_vidsel.children[3], vb_vidsel.children[4], vb_vidsel.children[5]\n    hb_aichbu                       = vb_vidsel.children[6]\n    bu_cleanb, bu_autchp            = hb_cleanb.children[1], hb_autchp.children[1]\n    bu_fromai, bu_aichap            = hb_aichbu.children[0], hb_aichbu.children[1]\n\n    # vb_chpare - big area with chapter selector and transcriptions\n    bx_chpsel, hb_contrl, hb_transc = vb_chpare.children[0], vb_chpare.children[1], vb_chpare.children[2]\n    vb_enCtrl, vb_xxCtrl            = hb_contrl.children[0], hb_contrl.children[1]\n    hb_enCtrl, hb_xxCtrl            = vb_enCtrl.children[0], vb_xxCtrl.children[0]\n    bu_enShow, bu_enSend, bu_enLoop = hb_enCtrl.children[3],hb_enCtrl.children[4],hb_enCtrl.children[5]\n    bu_xxShow, bu_xxSend, bu_xxLoop = hb_xxCtrl.children[3],hb_xxCtrl.children[4],hb_xxCtrl.children[5]\n    hb_enSele, hb_xxSele            = vb_enCtrl.children[1], vb_xxCtrl.children[1]\n    bu_enView, bu_enResu, bu_enLsel = hb_enSele.children[0].children[0],hb_enSele.children[0].children[1], hb_enSele.children[1].children[0]\n    bu_xxView, bu_xxResu, bu_xxLsel = hb_xxSele.children[0].children[0],hb_xxSele.children[0].children[1], hb_xxSele.children[1].children[0]\n    ta_enTran, ta_xxTran            = hb_transc.children[0], hb_transc.children[1]\n\n    # current selection\n    acIndex = mainAccordion.selected_index\n    plid    = [courses[all] for all in courses][acIndex]\n    rbIndex = rb_vidsel.options.index(rb_vidsel.value) if rb_vidsel.value else -1\n    vid     = playlists_yaml[plid]['videos'][rbIndex][:11] if rbIndex &gt; -1 else ''\n\n  def parseChaptersFromDescription (description):\n    lines = description.split('\\n')\n    chaps = []\n    for l in lines:\n      if ':' in l:\n        for i,c in enumerate(l):\n          if c == ':':\n            if i &gt; 0 and l[i-1].isdigit() and i &lt; len(l)-1 and l[i+1].isdigit():\n              start = i - (2 if i &gt; 1 and l[i-2].isdigit() else 1)\n              for end,c in enumerate (l[i+1:]):\n                if not c.isdigit() and c != ':': break\n              chaps.append(l[start:end+i+1]+' '+l[end+i+2:])\n              break\n    return chaps\n\n  def timestampTabView (trans):\n    \"\"\" make the transcription text format for the textareas \"\"\"\n    txt, max_block_line_len = '', 60\n    for all in trans:\n      tmp, block, sec = all['text'].replace('\\xa0','').replace('\\n',''), [], int(all['start'])\n      h, i = sec//3600, len (tmp)\n      m    = (sec - (h*3600)) // 60\n      s    = sec - h*3600 - m*60\n      # make a text block\n      while len (tmp) &gt; max_block_line_len:\n        for i in reversed(range(max_block_line_len)):\n          if tmp[i] == ' ': break\n        block.append(tmp[:i])\n        tmp = tmp[i+1:]\n      block.append(tmp[:i])\n      # and show it with tabs\n      for i,l in enumerate (block):\n        if i == 0: txt += f\"{h}:{m:02d}:{s:02d}\\t{l}\\n\"\n        else:      txt += f\"\\t{l}\\n\"\n    return txt\n\n  def getStartEndFromChapterButton (b):\n    gb_maingb                       = mainAccordion.children[mainAccordion.selected_index]\n    vb_vidsel, vb_chpare            = gb_maingb.children[0], gb_maingb.children[1]\n    bx_chpsel, hb_contrl, hb_transc = vb_chpare.children[0], vb_chpare.children[1], vb_chpare.children[2]\n\n    # start ts from button\n    ts = b.description.split(' ')[0]\n    if len(ts.split(':')) == 2: start = int(ts.split(':')[0])*60+int(ts.split(':')[1])\n    else: start = int(ts.split(':')[0])*3600+int(ts.split(':')[1])*60+int(ts.split(':')[2])\n\n    # search next button\n    nb = None\n    for i,sb in enumerate(bx_chpsel.children):\n      if b.description == sb.description: break\n\n    # end ts from search\n    if i &gt;= len(bx_chpsel.children)-1: ts = '99:00:00'\n    else: ts = bx_chpsel.children[i+1].description.split(' ')[0]\n    if len(ts.split(':')) == 2: end = int(ts.split(':')[0])*60+int(ts.split(':')[1])\n    else: end = int(ts.split(':')[0])*3600+int(ts.split(':')[1])*60+int(ts.split(':')[2])\n    return start, end\n\n  def makeAutoChapters (max,lines,tfac):\n    # generate chapters (timestamp list)\n    chapters = []\n    while(True):\n      # first in lines is new timestamp\n      if lines[0].split('\\t')[0] != '': chapters.append(lines[0].split('\\t')[0])\n\n      # search for the next timestamp so that the distance between the two timestamps (growRange)\n      # is bigger than max tokens and rest is big enough for own chapter (1/5 max).\n      for nextTS,l in enumerate (lines):\n        growRange = len('\\n'.join(lines[:nextTS]))//tfac\n        restRange = len('\\n'.join(lines[nextTS:]))//tfac\n        if len(lines[nextTS]) and growRange &gt; max and lines[nextTS][1]==':' and lines[nextTS][4]==':' and restRange &gt; max/5: break\n\n      # shrink lines or terminate\n      if len(lines[:nextTS]) &gt; 0:  lines = lines[nextTS:]\n      else:                        break\n    return chapters\n\n  def taCleaner (lines,tsCount,bs=None):\n    if tsCount &gt; len (lines): tsCount = 1\n\n    org, tmp, trigger = tsCount, '', False\n    for i,l in enumerate(lines): # all lines\n      if tsCount and not i%(len(lines)//org): # trigger if ts should create\n        tsCount -= 1\n        trigger = True\n      if trigger and l != '' and l[1] == ':': # create ts\n        if i &gt; 0: tmp += '\\n'\n        tmp += l.split('\\t')[0]+'\\n'          # create blockline\n        trigger = False\n      if '\\t' in l:\n        tmp += l.split('\\t')[1]+'\\n'\n    # return tmp - if no block wanted\n    if bs == None: bs = 60\n    lines, tmp2, nl = tmp.split('\\n'), '', ''\n    for i,l in enumerate(lines): # build block\n      if len (l) &gt; 1 and l[1] != ':':\n        words = l.split(' ')\n        for w in words:\n          if len (nl+' '+w) &lt; bs:\n            nl += ' '+w\n          else:\n            tmp2 += nl + '\\n'\n            nl = w\n      else:\n        tmp2 += l+'\\n'\n    return tmp2.replace('\\n ','\\n')\n\n  def storeLoop (vid, txt, ccode):\n    lid = ''\n    if txt[:13] == '... do prompt':\n      # yaml\n      if not os.path.exists(f'{vid}_loops_{ccode}.yml'): loops_yaml = {}\n      else: loops_yaml = yaml.load (open(f'{vid}_loops_{ccode}.yml', 'r'), Loader=yaml.FullLoader)\n      lid = datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n      loops_yaml[lid] = txt\n      yaml.dump (loops_yaml, open(f'{vid}_loops_{ccode}.yml', 'w'))\n    return lid\n\n  def resetTransArea ():\n    globalize()\n\n    # unselect prompt / clear textareas / message / lastState\n    hb_enCtrl.children[1].value = hb_xxCtrl.children[1].value = '&lt;&lt;&lt;select prompt&gt;&gt;&gt;'\n    ta_enTran.value, ta_xxTran.value = \"... select chapter or click 'all &gt;&gt;&gt;&gt;'\", '...'\n\n    # buttonstyles\n    for but in bx_chpsel.children: but.button_style   = ''\n    bu_allchp.button_style                            = ''\n\n\n\n\n  ####################################################################################################################################\n  ################################################## openai-stuff: prompts ###########################################################\n  ####################################################################################################################################\n  # defaults\n  summary_50_en = \"\"\"Below is an excerpt from a transcription of a video that starts after this string '##x##'.\n  The video is a course about Deep Learning.\n  Create a summary of the content of the excerpt in 50 words or less.\n  To do this, first clean up the raw text by removing the time stamps, merging the text, and ridding it of errors or clutter.\n  ##x##\n  \"\"\"\n  summary_50_de = \"\"\"Im Folgenden findest du einen Auszug aus der Transkription eines Videos, das nach dieser Zeichenfolge '##x##' beginnt.\n  Das Video ist ein Kurs √ºber Deep Learning.\n  Erstelle eine Zusammenfassung des Inhalts des Auszugs in 50 W√∂rtern oder weniger.\n  Bereinige dazu zun√§chst den Rohtext, indem du die Zeitstempel entfernst, den Text zusammenf√ºhrst und ihn von Fehlern oder Unordnung befreien.\n  ##x##\n  \"\"\"\n  keywords_en = \"\"\"The text is an excerpt from the transcription of a video and it starts after this character sequence: '##x##'. Create a keyword list in the following structure:\n\n  - Keyword 1\n  - ...\n  - Keyword n\n\n  ##x##\n  \"\"\"\n  keywords_de = \"\"\"Bei dem Text handelt es sich um einen Auszug aus der Transkription eines Videos und er beginnt nach dieser Zeichenfolge: '##x##'. Erstelle eine Schlagwortliste in folgender Struktur:\n\n  - Schlagwort 1\n  - ...\n  - Schlagwort n\n\n  ##x##\n  \"\"\"\n  hints_en = \"\"\"The text is an excerpt from the transcription of a video and it starts after this character sequence: '##x##'. Create a hint list in the following structure:\n\n  - Hint 1\n  - ...\n  - Hint n\n\n  ##x##\n  \"\"\"\n  hints_de = \"\"\"Bei dem Text handelt es sich um einen Auszug aus der Transkription eines Videos und er beginnt nach dieser Zeichenfolge: '##x##'. Erstelle eine Liste von Hinweisen in folgender Struktur:\n\n  - Hinweis 1\n  - ...\n  - Hinweis n\n\n  ##x##\n  \"\"\"\n  aichapters_de = \"\"\"Bei dem Text handelt es sich um einen Auszug aus der Transkription eines Videos und er beginnt nach dieser Zeichenfolge: '##x##'.\n  Das Video ist eines von vielen aus einer Tutorial Reihe zum Thema Deep Learning f√ºr Programmierer.\n  Finde einen Titel f√ºr diese Sektions des Videos, der zusammenfassende Schlagw√∂rter beinhaltet und nicht mehr als 10 W√∂rter sein soll.\n  Gib den nur Titel als ergebnis zur√ºck in deutscher Sprache.\n  ##x##\n  \"\"\"\n  aichapters_en = \"\"\"The text is an excerpt from the transcription of a video and it starts after this string: '##x##'.\n  The video is one of many in a tutorial series on Deep Learning for programmers.\n  Find a title for this section of the video that includes summary keywords and should be no more than 10 words.\n  Return only the title as the result.\n  ##x##\n  \"\"\"\n  profile_de = \"\"\"Bei dem Text handelt es sich um einen Auszug aus der Transkription eines Videos und er beginnt nach dieser Zeichenfolge: ##x##. Erstelle eine Kapitelbeschreibung f√ºr den Text in folgender Struktur:\n\n  Schlagw√∂rter:\n  - Schlagwort 1\n  - ...\n  - Schlagwort n\n\n  Hinweise:\n  - Hinweis 1\n  - ...\n  - Hinweis n\n\n  Zusammenfassung:\n  &lt;ein zusammenfassender Text mit nicht mehr als 100 W√∂rtern&gt;\n\n  ##x##\n  \"\"\"\n  profile_en = \"\"\"The text is an excerpt from the transcription of a video and starts after this character string: ##x##. Create a chapter description for the text in the following structure:\n\n  Keywords:\n  - Keyword 1\n  - ...\n  - Keyword n\n\n  Notes:\n  - Note 1\n  - ...\n  - Note n\n\n  Summary:\n  &lt;a summary text with no more than 100 words&gt;\n\n  ##x##\n  \"\"\"\n  # prompts_yaml\n  if not os.path.exists('prompts.yml'):\n    prompts_yaml = {'summary 50':   {'en':summary_50_en , 'de':summary_50_de},\n                    'keywords':     {'en':keywords_en   , 'de':keywords_de},\n                    'hints':        {'en':hints_en      , 'de':hints_de},\n                    'profile':      {'en':profile_en    , 'de':profile_de},\n                    '_aichapters_': {'en':aichapters_en , 'de':aichapters_de}}\n    yaml.dump (prompts_yaml, open('prompts.yml', 'w'))\n  else:\n    prompts_yaml = yaml.load(open('prompts.yml', 'r'), Loader=yaml.FullLoader)\n\n\n  ####################################################################################################################################\n  ############################################ openai-stuff: libs / account / helper #################################################\n  ####################################################################################################################################\n  if yes_i_have_this_chatgpt_openai_account:\n    default_temperature = 0.2\n    default_chartokfac  = 3.1\n    tmphm =  HTML(\"\"\"Get &lt;a href='https://platform.openai.com/account/api-keys' target='_blank'&gt;here&lt;/a&gt; your API-Key.\"\"\")\n    display  (tmphm)\n    try:     import openai\n    except:  os.system ('pip install openai'); import openai\n    try:     openai.api_key = os.environ[\"OPENAI_API_KEY\"]\n    except:  openai.api_key = getpass.getpass (prompt='Your API key: ')\n    os.environ[\"OPENAI_API_KEY\"] = openai.api_key\n    tmphm.value = \"\"\"&lt;font color='green'&gt;Set API-key done!&lt;/font&gt;\"\"\"\n    from openai import OpenAI\n    chatclient = OpenAI()\n\n  def get_completion(prompt, model=None,temperature=None):\n    if not yes_i_have_this_chatgpt_openai_account: return 'no account'\n    # do an openai api call\n    if not model:         model         = used_model\n    if not temperature:   temperature   = default_temperature\n    messages, maxTry                    = [{\"role\": \"user\", \"content\": prompt}], 3\n    for t in range (maxTry):\n      try: # try maxTry times\n        time.sleep (t+1)\n        chatclient.chat.completions\n        return chatclient.chat.completions.create(model=model, messages=messages, temperature=temperature).choices[0].message.content\n        #return 'under construction'\n      except Exception as e:\n        print (f\"\\r\\x1b[91mApi-Error: {e}\",end=' ')\n    return 'oops - something goes wrong...'\n\n  def text_change(_):\n    global textChangeFromYaml\n    if textChangeFromYaml: return\n\n    cyanbox = lambda s: \"&lt;table width='50'&gt;&lt;tr&gt;&lt;td align='center'&gt;&lt;p style='background-color:#B0E0E6'&gt;\"+s+\"&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;\"\n    # compute tokens\n    hb_enCtrl.children[0].value = cyanbox(str(int(len(ta_enTran.value) // default_chartokfac+1)))\n    hb_xxCtrl.children[0].value = cyanbox(str(int(len(ta_xxTran.value) // default_chartokfac+1)))\n\n    # store text\n    for i,b in enumerate (hb_enSele.children[0].children):\n      if b.layout.border != None: break\n    if i &gt;= 0 and i &lt; 2: store_en[i] = ta_enTran.value\n\n    for i,b in enumerate (hb_xxSele.children[0].children):\n      if b.layout.border != None: break\n    if i &gt;= 0 and i &lt; 2: store_xx[i] = ta_xxTran.value\n\n\n  def refreshPrompts():\n    # tab loop\n    for gb_maingb in mainAccordion.children[:-2]:\n      vb_vidsel      = gb_maingb.children[0]\n      prompt_buttons = [Button (description=p,\n                                tooltip=str(prompts_yaml[p]['en']) if 'en' in prompts_yaml[p] else '' + '\\n' +\n                                        str(prompts_yaml[p][cc])  if cc in prompts_yaml[p] else '',\n                                style={'button_color':'lightgreen'}) for p in prompts_yaml if p[0] != '_']\n      for b in prompt_buttons: b.on_click (promptButtonClick)\n      firstPromptButtonPos = 3 # for safety\n      for i,but in enumerate (vb_vidsel.children):\n        try: # somtimes python is ... - hm ... - special\n          if but.style.button_color == 'lightgreen':\n            firstPromptButtonPos = i\n            break\n        except: pass\n      for oldbut in vb_vidsel.children[firstPromptButtonPos:]:  del oldbut\n      vb_vidsel.children = [*vb_vidsel.children[:firstPromptButtonPos],*prompt_buttons]\n\n\n  ####################################################################################################################################\n  ################################################ openai-stuff: buttons bi-transcription area #######################################\n  ####################################################################################################################################\n  def ccShowButtonClick (b,ccode):\n    if ccode == 'en': hb_ccCtrl, bu_ccView, ta_ccTran = hb_enCtrl, bu_enView, ta_enTran\n    else:             hb_ccCtrl, bu_ccView, ta_ccTran = hb_xxCtrl, bu_xxView, ta_xxTran\n    # check prompt selected\n    if hb_ccCtrl.children[1].value == '&lt;&lt;&lt;select prompt&gt;&gt;&gt;': return\n    # select view areas\n    if ccode == 'en':  areaSelect_en (bu_ccView)\n    else: areaSelect_xx (bu_ccView)\n    # generate prompts and show\n    if len (prompts_yaml[hb_ccCtrl.children[1].value][ccode]) &gt; 50:\n      ta_ccTran.value = f\"{prompts_yaml[hb_ccCtrl.children[1].value][ccode]}\\n{ta_ccTran.value}\"\n  def enShowButtonClick (b): ccShowButtonClick (b,'en')\n  def xxShowButtonClick (b): ccShowButtonClick (b,country_code_for_the_translation_language.split(' ')[0])\n\n  def ccSendButtonClick (b, ccode):\n    # set language and select result area\n    if ccode == 'en':\n      hb_ccCtrl, store_cc, ta_ccTran = hb_enCtrl, store_en, ta_enTran\n      areaSelect_en(bu_enResu)\n    else:\n      hb_ccCtrl, store_cc, ta_ccTran = hb_xxCtrl, store_xx, ta_xxTran\n      areaSelect_xx(bu_xxResu)\n\n    # show wait message / response\n    prompt = hb_ccCtrl.children[1].value\n    hb_ccCtrl.children[1].value = '&lt;&lt;&lt;select prompt&gt;&gt;&gt;'\n    if yes_i_have_this_chatgpt_openai_account:\n      ta_ccTran.value = '... waiting for response'\n      ta_ccTran.value = f'&gt;&gt;&gt;&gt;&gt; response for prompt {prompt} &gt;&gt;&gt;&gt;&gt;\\n'+get_completion (store_cc[0],temperature=float(hb_ccCtrl.children[2].value))\n    else:\n      ta_ccTran.value = 'sorry - no account'\n\n  def enSendButtonClick (b): ccSendButtonClick (b,'en')\n  def xxSendButtonClick (b): ccSendButtonClick (b,country_code_for_the_translation_language.split(' ')[0])\n\n  def ccLoopButtonClick (b,ccode):\n    globalize ()\n    if ccode == 'en': hb_ccCtrl, hb_ccSele, areaSelect_cc, store_cc, ta_ccTran, ccTrans = hb_enCtrl, hb_enSele, areaSelect_en, store_en, ta_enTran, enTrans\n    else:             hb_ccCtrl, hb_ccSele, areaSelect_cc, store_cc, ta_ccTran, ccTrans = hb_xxCtrl, hb_xxSele, areaSelect_xx, store_xx, ta_xxTran, xxTrans\n\n    # check prompt selected\n    if hb_ccCtrl.children[1].value == '&lt;&lt;&lt;select prompt&gt;&gt;&gt;': return\n\n    # create and select new loop button\n    for bu in hb_ccSele.children[0].children: bu.layout = Layout (width='auto', height='15px')\n    newbut = Button (layout=Layout(width='auto', height='15px', border='2px solid'), style={'button_color':'hotpink'},\n                    tooltip='')\n    newbut.on_click (areaSelect_cc)\n    store_cc.append('')\n    hb_ccSele.children[0].children = [*hb_ccSele.children[0].children, newbut]\n\n    # show wait message / response\n    prompt = hb_ccCtrl.children[1].value\n    ta_ccTran.value = f'... do prompt &lt;\"'+prompt+'\"&gt; for ...\\n'\n    for b in bx_chpsel.children:\n      ta_ccTran.value += '\\n&gt;&gt;&gt;&gt;&gt;&gt;'+b.description + '&gt;&gt;&gt;&gt;&gt;&gt;\\n'\n      start, end       = getStartEndFromChapterButton (b)\n      tmp              = taCleaner (timestampTabView ([t for t in ccTrans[vid] if t['start'] &gt;= start and t['start'] &lt; end]).split('\\n'),0)\n      response         = get_completion ( f\"{prompts_yaml[prompt][ccode]}\\n{tmp}\", temperature=float(hb_ccCtrl.children[2].value) )\n      ta_ccTran.value += f\"{response}\\n\" if response[-1] != '\\n' else f\"{response}\"\n\n    # yaml it\n    lid = storeLoop (vid, ta_ccTran.value, ccode)\n    newbut.tooltip = f'{lid} - prompt: {prompt}'\n    ta_ccTran.value += f\"\\n\\n&gt;&gt;&gt;&gt;&gt;&gt; write to {f'{vid}_loops_{ccode}.yml &gt;&gt;&gt;&gt;&gt;&gt;'}\"\n  def enLoopButtonClick (b): ccLoopButtonClick (b,'en')\n  def xxLoopButtonClick (b): ccLoopButtonClick (b,country_code_for_the_translation_language.split(' ')[0])\n\n  textChangeFromYaml = False\n  def areaSelect_cc (b, ccode):\n    global textChangeFromYaml\n    textChangeFromYaml = True\n\n    if ccode == 'en': hb_ccSele, store_cc, ta_ccTran = hb_enSele, store_en, ta_enTran\n    else:             hb_ccSele, store_cc, ta_ccTran = hb_xxSele, store_xx, ta_xxTran\n\n    # save current textarea\n    for i,bu in enumerate (hb_ccSele.children[0].children):\n      if bu.layout.border: break\n    if i &gt;= 0 and i &lt; 2: store_cc[i] = ta_ccTran.value\n\n    # draw / undraw selection border\n    for bu in hb_ccSele.children[0].children: bu.layout = Layout (width='auto', height='15px')\n    b.layout = Layout (width='auto', height='15px', border='2px solid')\n\n    # restore textarea\n    for i,bu in enumerate (hb_ccSele.children[0].children):\n      if bu == b: break\n    if i &gt;= 0 and i &lt; len(store_cc): ta_ccTran.value = store_cc[i]\n    textChangeFromYaml = False\n\n  def areaSelect_en (b): areaSelect_cc (b,'en')\n  def areaSelect_xx (b): areaSelect_cc (b,country_code_for_the_translation_language.split(' ')[0])\n\n  def loopDelete_cc (ccode):\n    if ccode == 'en': hb_ccSele, store_cc, areaSelect_cc, bu_ccView = hb_enSele, store_en, areaSelect_en, bu_enView\n    else:             hb_ccSele, store_cc, areaSelect_cc, bu_ccView = hb_xxSele, store_xx, areaSelect_xx, bu_xxView\n    # find selected loop area\n    for i,b in enumerate (hb_ccSele.children[0].children):\n      if b.layout.border != None: break\n    if i &gt;= 2 and i &lt; len (hb_ccSele.children[0].children):\n      # delete from txt store, button list and yaml file / select view area\n      hb_ccSele.children[0].children = [*hb_ccSele.children[0].children[:i],*hb_ccSele.children[0].children[i+1:]]\n      store_cc = [store_cc[:i],store_cc[i+1:]]\n      areaSelect_cc (bu_ccView);\n      try:\n        loops_yaml = yaml.load(open(f'{vid}_loops_{ccode}.yml', 'r'), Loader=yaml.FullLoader)\n        del loops_yaml[b.tooltip.split(' - ')[0]]\n        yaml.dump (loops_yaml, open(f'{vid}_loops_{ccode}.yml', 'w'))\n      except: pass\n  def loopDelete_en (b): loopDelete_cc ('en')\n  def loopDelete_xx (b): loopDelete_cc (country_code_for_the_translation_language.split(' ')[0])\n\n\n  ####################################################################################################################################\n  ####################################################### buttons left area ##########################################################\n  ####################################################################################################################################\n  def promptButtonClick (b):\n    # set prompt actve -&gt; show-button\n    hb_enCtrl.children[1].value, hb_xxCtrl.children[1].value = b.description, b.description\n    if 'info' in [b.button_style for b in [bu_allchp,*bx_chpsel.children]]: bu_enShow.disabled = bu_xxShow.disabled = False\n    bu_enLoop.disabled = bu_xxLoop.disabled = False\n\n  def chapbutClick (b):\n    globalize ()\n\n    # select view areas\n    areaSelect_en (bu_enView); areaSelect_xx (bu_xxView)\n\n    # buttonstyles\n    for but in bx_chpsel.children: but.button_style   = ''\n    bu_allchp.button_style, b.button_style            = '', 'info'\n\n    # show complete text\n    if b.description == 'all &gt;&gt;&gt;&gt;':\n      ta_enTran.value = timestampTabView (enTrans[vid])\n      ta_xxTran.value = timestampTabView (xxTrans[vid])\n    # or chapter filtered\n    else:\n      start, end    = getStartEndFromChapterButton (b)\n      ta_enTran.value = timestampTabView ([t for t in enTrans[vid] if t['start'] &gt;= start and t['start'] &lt; end])\n      ta_xxTran.value = timestampTabView ([t for t in xxTrans[vid] if t['start'] &gt;= start and t['start'] &lt; end])\n\n  def fromDescriptionButtonClick (_):\n    globalize ()\n    tmp = timestampTabView(enTrans[vid]).split('\\n')\n\n    # del old chapter buttons\n    for oldbut in bx_chpsel.children: del oldbut\n\n    # build buttons\n    chapters = videoInfos[vid]['chapters']\n    bu_allchp.tooltip = '&gt;&gt;&gt;&gt;Description from YouTube&gt;&gt;&gt;\\n'+str(videoInfos[vid]['description'])\n    bu_allchp.button_style = ''\n    bx_chpsel.children = [Button (description  = f'{c:.67}...' if len (c) &gt; 70 else c,\n                                tooltip      = c,\n                                layout       = Layout(width='auto', height='21px'))\n                        for i,c in enumerate (chapters)]\n    for button in bx_chpsel.children: button.on_click(chapbutClick)\n\n    # reset\n    resetTransArea ()\n\n  def autoButtonClick (_):\n    globalize ()\n    # select green\n    areaSelect_en (bu_enView); areaSelect_xx (bu_xxView)\n\n    tmp = timestampTabView(enTrans[vid]).split('\\n')\n\n    # makeAutoChapters\n    chapters = makeAutoChapters (int(hb_autchp.children[0].value),tmp,default_chartokfac)\n\n    bu_allchp.tooltip = str(videoInfos[vid]['description'])\n    # del old chapter buttons\n    for oldbut in bx_chpsel.children: del oldbut\n    # and make new\n    bx_chpsel.children = [Button (description  = f'{c:.67}...' if len (c) &gt; 70 else c,\n                                  tooltip      = c,\n                                  layout       = Layout(width='auto', height='21px'))\n                          for i,c in enumerate (chapters)]\n    for button in bx_chpsel.children: button.on_click(chapbutClick)\n\n    # reset\n    resetTransArea ()\n\n  def cleanButtonClick (_):\n    # parse blocksize - check &gt; 40 and &lt; 200\n    val = hb_cleanb.children[0].value\n    if not ',' in val:  bs = None\n    else:               bs = int(val.split(',')[1]) if int(val.split(',')[1]) &lt; 200 and int(val.split(',')[1]) &gt; 40 else None\n    if \"select chapter or click 'all &gt;&gt;&gt;&gt;'\" in ta_enTran.value: return\n\n    # rebuild ts view (if button clicked twice or mor)\n    if not '\\t' in ta_enTran.value:\n      if bu_allchp.button_style == 'info': chapbutClick (bu_allchp)\n      else: chapbutClick ([b for b in bx_chpsel.children if b.button_style=='info'][0])\n\n    # use taCleaner (&lt;linelist&gt;,&lt;count timestamps&gt;,&lt;blocksize&gt;)\n    ta_enTran.value = taCleaner ([l for l in ta_enTran.value.split('\\n') if l != ''], int(val.split(',')[0]), bs)\n    ta_xxTran.value = taCleaner ([l for l in ta_xxTran.value.split('\\n') if l != ''], int(val.split(',')[0]), bs)\n\n  def aiShowButtonClick (_):\n    globalize ()\n\n    # select green\n    areaSelect_en (bu_enView); areaSelect_xx (bu_xxView)\n\n    if use_english_for_ai_auto_chapters: ccode = 'en'\n    else: ccode = cc\n    tmp = timestampTabView(enTrans[vid]).split('\\n')\n\n    # del old chapter buttons\n    for oldbut in bx_chpsel.children: del oldbut\n\n    # build ai chapter buttons\n    chapters, lastTS = videoInfos[vid]['aichapters'][ccode] if ccode in videoInfos[vid]['aichapters'] else [], 0\n    for child in bx_chpsel.children: del child\n    bx_chpsel.children = [Button (description  = f'{c:.67}...' if len (c) &gt; 70 else c,\n                                  tooltip      = c,\n                                  layout       = Layout(width='auto', height='21px'))\n                        for i,c in enumerate (chapters)]\n    for button in bx_chpsel.children: button.on_click(chapbutClick)\n\n    # reset\n    resetTransArea ()\n\n  def aiBuildButtonClick (_):\n    globalize ()\n\n    # select green\n    areaSelect_en (bu_enView); areaSelect_xx (bu_xxView)\n\n    # use existing chapters from buttons or do makeAutoChapters first\n    if len(bx_chpsel.children) &gt; 0:  chapters = [b.description.split(' ')[0] for b in bx_chpsel.children]\n    else:                            chapters = makeAutoChapters (int(hb_autchp.children[0].value),tmp,tfac)\n\n    # use existing chapters from buttons or do makeAutoChapters first\n    if len(bx_chpsel.children) &gt; 0:  chapters = [b.description.split(' ')[0] for b in bx_chpsel.children]\n    else:                            chapters = makeAutoChapters (int(hb_autchp.children[0].value),timestampTabView(enTrans[vid]).split('\\n'),default_chartokfac)\n\n    # del old buttons\n    for oldbut in bx_chpsel.children: del oldbut\n    # and make new\n    bx_chpsel.children = [Button (description  = f'{c:.67}...' if len (c) &gt; 70 else c,\n                                  tooltip      = c,\n                                  layout       = Layout(width='auto', height='21px'))\n                        for i,c in enumerate (chapters)]\n\n    # wait message and start loop over chapters\n    ta_enTran.value, ta_xxTran.value = \"... please wait - chapter building in progress &gt;&gt;&gt;&gt;'\", '...'\n    for b in bx_chpsel.children:\n      start, end = getStartEndFromChapterButton (b)\n      # get ai chapter title\n      tmp = []\n      if use_english_for_ai_auto_chapters:\n        ccode = 'en'\n        tmp   = taCleaner (timestampTabView ([t for t in enTrans[vid] if t['start'] &gt;= start and t['start'] &lt; end]).split('\\n'),0)\n        title = get_completion ( f\"{prompts_yaml['_aichapters_']['en']}\\n{tmp}\", temperature=float(hb_enCtrl.children[2].value) )\n      else:\n        ccode = cc\n        tmp   = taCleaner (timestampTabView ([t for t in xxTrans[vid] if t['start'] &gt;= start and t['start'] &lt; end]).split('\\n'),0)\n        title = get_completion (f\"{prompts_yaml['_aichapters_'][cc]}\\n{tmp}\", temperature=float(hb_xxCtrl.children[2].value))\n\n      # set new title as button description\n      if len (title) &gt; 0:\n        if title[0] == '\"' or title[0] == \"'\":   title = title[1:]\n        if title[-1] == '\"' or title[-1] == \"'\": title = title[:-1]\n      b.description = b.description.split(' ')[0]+' '+title\n    for button in bx_chpsel.children: button.on_click(chapbutClick)\n\n    # reset\n    resetTransArea ()\n\n    # store in yaml\n    videoInfos[vid]['aichapters'][ccode] = [button.description for button in bx_chpsel.children]\n    yaml.dump (videoInfos[vid], open(f'{vid}_info.yml', 'w'))\n\n\n  ####################################################################################################################################\n  #################################### openai-stuff: buttons prompt editor ###########################################################\n  ####################################################################################################################################\n  def prompt_add (_):\n    # make new empty prompt\n    tx_protit.value, tx_protit.disabled = '', False\n    bu_addprmt.disabled, hb_protxt.children[0].value, hb_protxt.children[1].value = True, '', ''\n\n  def prompt_save (_):\n    # save yaml / refresh widgets\n    prompts_yaml[tx_protit.value] = { 'en':hb_protxt.children[0].value, cc: hb_protxt.children[1].value}\n    rb_prompts.options  = tuple ([tx_protit.value,*rb_prompts.options]) if not tx_protit.value in rb_prompts.options else rb_prompts.options\n    rb_prompts.disabled = bu_addprmt.disabled = False\n    yaml.dump (prompts_yaml, open('prompts.yml', 'w'))\n    refreshPrompts()\n\n  def prompt_translate (_):\n    # prompt text from textarea - using german as prompt text of cause the language names\n    # delivered by the api are in german - idontknow if it works with google accounts in other languages.\n    en_ta, xx_ta     = hb_protxt.children[0], hb_protxt.children[1]\n    prompt_ex        = f'√úbersetze die Arbeitsanweisung nach dem Doppelpunkt von Englisch nach {countryCodes[cc]} und beachte die Arbeitsanweisung nicht auszuf√ºhren sonder nur zu √ºbersetzen und zwar exakt und wort f√ºr wort: '\n    prompt_xe        = f'√úbersetze die Arbeitsanweisung nach dem Doppelpunkt von {countryCodes[cc]} nach Englisch und beachte die Arbeitsanweisung nicht auszuf√ºhren sonder nur zu √ºbersetzen und zwar exakt und wort f√ºr wort: '\n    org_xx, org_en   = xx_ta.value, en_ta.value\n\n    # translate\n    if len (org_en) &gt; 10: xx_ta.value  += f'\\n&gt;&gt;&gt;&gt;&gt; translate from en to {cc} &gt;&gt;&gt;&gt;&gt;&gt;\\n'\n    if len (org_xx) &gt; 10: en_ta.value  += f'\\n&gt;&gt;&gt;&gt;&gt; translate from {cc} to en &gt;&gt;&gt;&gt;&gt;&gt;\\n'\n    if len (org_en) &gt; 10: xx_ta.value  += get_completion (prompt_ex + org_en)\n    if len (org_xx) &gt; 10: en_ta.value  += get_completion (prompt_xe + org_xx)\n\n  def prompt_del (_):\n    if tx_protit.value[0] == '_' : return\n    # remove prompt from rb-list / save yaml / trigger refresh prompt buttons\n    if tx_protit.value in rb_prompts.options:\n      if tx_protit.value in prompts_yaml:\n        del prompts_yaml[tx_protit.value]\n        yaml.dump (prompts_yaml, open('prompts.yml', 'w'))\n      rb_prompts.options = tuple ([o for o in rb_prompts.options if o != tx_protit.value])\n    else: promptSelect(None)\n    rb_prompts.disabled = bu_addprmt.disabled = False\n    refreshPrompts()\n\n  def promptSelect (_):\n    global cc\n    # set prompt title in en/xx areas\n    hb_protxt.children[0].value = prompts_yaml[rb_prompts.value]['en'] if 'en' in prompts_yaml[rb_prompts.value] else ''\n    hb_protxt.children[1].value = prompts_yaml[rb_prompts.value][cc]   if cc   in prompts_yaml[rb_prompts.value] else ''\n    tx_protit.value, tx_protit.disabled = rb_prompts.value, True\n\n\n  ####################################################################################################################################\n  ########################################## select video -&gt; build yamls / build widgets #############################################\n  ####################################################################################################################################\n  videoInfos, enTrans, xxTrans, store_en, store_xx = {}, {}, {}, ['',''], ['','']\n  def getTraTra (vid, cc):\n    try:\n      ret = YouTubeTranscriptApi.list_transcripts (vid).find_generated_transcript([cc, 'en']).translate(cc).fetch()\n    except:\n      ret = [{}]\n      for transcript in YouTubeTranscriptApi.list_transcripts (vid):\n        if transcript.is_translatable:\n          ret = transcript.translate(cc).fetch()\n    return ret\n  def buildYamls (vid):\n    if vid == '': return\n    global store_en, store_xx\n    # create info yaml if not exists\n    if not os.path.exists (f'{vid}_info.yml'):\n      if not vid in videoInfos:\n        videoInfo = Video.getInfo(video_prefix+vid)\n        description = videoInfo['description']\n\n        # parse chapter list / infoYml\n        chapters        = parseChaptersFromDescription (description)\n        videoInfos[vid] = {'description':description, 'chapters':chapters, 'aichapters': {}}\n\n      # write infoYml\n      yaml.dump (videoInfos[vid], open(f'{vid}_info.yml', 'w'))\n      print (f\"\\r\\x1b[34mwrite {vid}_info.yml\",end=' | ')\n\n    # load infoYml\n    else:\n      if not vid in videoInfos:\n        videoInfos[vid] = yaml.load(open(f\"{vid}_info.yml\", 'r'), Loader=yaml.FullLoader)\n        print (f\"\\r\\x1b[34mload {vid}_info.yml\",end=' | ')\n      else: print (f\"\\r\\x1b[34mmemory {vid}_info.yml\",end=' | ')\n\n    # create en transcription if not exists\n    if not os.path.exists (f\"{vid}_en.yml\"):\n      # get transcriptions from youtube / write to yaml\n      enTrans[vid] = YouTubeTranscriptApi.get_transcript (vid)\n      yaml.dump (enTrans[vid], open(f'{vid}_en.yml', 'w'))\n    # load en transcription\n    else:\n      if not vid in enTrans:\n        enTrans[vid] = enYml = yaml.load(open(f\"{vid}_en.yml\", 'r'), Loader=yaml.FullLoader)\n        print (f\"\\x1b[34mload {vid}_en\",end=' | ')\n      else: print (f\"\\x1b[34mmemory {vid}_en\",end=' | ')\n\n    # create xx transcription if not exists\n    if not os.path.exists (f\"{vid}_{cc}.yml\"):\n      # get transcriptions from youtube / transcriptions-dict / write to yaml\n      xxTrans[vid] = getTraTra (vid,cc)\n      yaml.dump (xxTrans[vid], open(f'{vid}_{cc}.yml', 'w'))\n    # load xx transcription\n    else:\n      if not vid in xxTrans:\n        xxTrans[vid] = xxYml = yaml.load(open(f\"{vid}_{cc}.yml\", 'r'), Loader=yaml.FullLoader)\n        print (f\"\\x1b[34mload {vid}_{cc}.yml\",end='')\n      else: print (f\"\\x1b[34mmemory {vid}_{cc}.yml\",end='')\n\n    # loops\n    try:\n      loops_yaml, store_en  = yaml.load(open(f'{vid}_loops_en.yml', 'r'), Loader=yaml.FullLoader), store_en[:2]\n      for ts in loops_yaml: store_en.append (loops_yaml[ts])\n    except: pass\n    try:\n      loops_yaml, store_xx  = yaml.load(open(f'{vid}_loops_{cc}.yml', 'r'), Loader=yaml.FullLoader), store_xx[:2]\n      for ts in loops_yaml: store_xx.append (loops_yaml[ts])\n    except: pass\n\n\n  def selectVideo (_):\n    # if help or prompt editor do nothing\n    if mainAccordion.selected_index == None or mainAccordion.selected_index &gt;= len(mainAccordion.children) - 2: return\n\n    # set widgets and actual infos\n    globalize()\n    if vid == '': return\n\n    # log line / disable rb-selection during work\n    print ('\\r\\x1b[35mplease wait a moment ...',end='')\n    rb_vidsel.disabled = True\n\n    # check if single v mode\n    if 'no playlist' == plid: tx_singvid.value = vid\n\n    # create or load yamls\n    buildYamls (vid)\n\n    # chapters / tooltip\n    chapters = videoInfos[vid]['chapters']\n    bu_allchp.tooltip = '&gt;&gt;&gt;&gt;Description from YouTube&gt;&gt;&gt;\\n'+str(videoInfos[vid]['description'])\n\n    # only if the video changed inside a playlist box\n    if vPositions[acIndex] != rbIndex:\n\n      # reset\n      resetTransArea ()\n\n      # new chapter buttons\n      for child in bx_chpsel.children: del child\n      bx_chpsel.children = [Button (description  = f'{c:.67}...' if len (c) &gt; 70 else c,\n                                    tooltip      = c,\n                                    layout       = Layout(width='auto', height='21px'))\n                            for i,c in enumerate (chapters)]\n      for button in bx_chpsel.children: button.on_click(chapbutClick)\n      vPositions[acIndex] = rbIndex\n\n      # build area buttons en / xx\n      hb_enSele.children[0].children = [bu_enView, bu_enResu,*xareaSelectors('en')]\n      hb_xxSele.children[0].children = [bu_xxView, bu_xxResu,*xareaSelectors(cc)]\n\n      # draw / undraw selection border\n      for bu in hb_enSele.children[0].children: bu.layout = Layout (width='auto', height='15px')\n      hb_enSele.children[0].children[0].layout = Layout (width='auto', height='15px', border='2px solid')\n      for bu in hb_xxSele.children[0].children: bu.layout = Layout (width='auto', height='15px')\n      hb_xxSele.children[0].children[0].layout = Layout (width='auto', height='15px', border='2px solid')\n\n\n    # one time geting country codes - note: the language names are in the language of your google account.\n    if not '\\nAvailable country codes:\\n' in ta_helper.value:\n      countryCodes = {}\n      for transcript in YouTubeTranscriptApi.list_transcripts(vid):\n        for l in transcript.translation_languages: countryCodes[l['language_code']] = l['language']\n      ta_helper.value += \"\\nAvailable country codes:\\n\\n\"+'\\n'.join([', '.join([c for c in countryCodes][i:i+20]) for i in range (0,len([c for c in countryCodes]),20)])\n\n    # re-enable rb's\n    rb_vidsel.disabled = False\n\n\n  def xareaSelectors (ccode):\n    if ccode == 'en': areaSelect_cc = areaSelect_en\n    else:             areaSelect_cc = areaSelect_xx\n    # build area buttons en / xx\n    buttons = []\n    try:\n      loops_yaml = yaml.load(open(f'{vid}_loops_{ccode}.yml', 'r'), Loader=yaml.FullLoader)\n      buttons    = [Button (layout=Layout(width='auto', height='15px'),\n                            style={'button_color':'hotpink'},\n                            tooltip=f\"{id} - {loops_yaml[id].split('prompt &lt;')[1].split('&gt; for ...')[0]}\" )\n                for id in loops_yaml]\n      for b in buttons: b.on_click (areaSelect_cc)\n    except: pass\n    return buttons\n\n\n  ####################################################################################################################################\n  ############################################################ main ##################################################################\n  ####################################################################################################################################\n  # prompt editor widgets\n  prompt_buttons            = [Button (description  = p,\n                                      tooltip      = str(prompts_yaml[p]['en']) if 'en' in prompts_yaml[p] else '' + '\\n' +\n                                                      str(prompts_yaml[p][cc])   if cc   in prompts_yaml[p] else '',\n                                      style        = {'button_color':'lightgreen'}) for p in prompts_yaml if p[0] != '_']\n  rb_prompts, bu_addprmt    = RadioButtons(options=[p for p in prompts_yaml]), Button (description='add prompt',tooltip='add empty prompt')\n  bu_delprmt, bu_savprmt    = Button (description='del prompt',tooltip='delete prompt'), Button (description='save',tooltip='save prompt')\n  bu_transla                = Button (description='translate',tooltip='translate prompt if not empty')\n  hb_probut, tx_protit      = HBox (children=[bu_addprmt,bu_delprmt,bu_savprmt,bu_transla]), Text (layout=Layout(width='auto'))\n  hb_protxt                 = HBox (children=[Textarea(layout=Layout(width='50%',height='400px')),\n                                              Textarea(layout=Layout(width='50%',height='400px'))])\n  vb_proedi                 = VBox (children=[hb_probut,tx_protit,hb_protxt])\n  gb_proedi                 = GridBox (children=[rb_prompts,vb_proedi],\n                                      layout=Layout (grid_template_rows='auto',\n                                                      grid_template_columns='150px auto',\n                                                      grid_template_areas='\"sidebar main\"'))\n  # events\n  for b in prompt_buttons: b.on_click (promptButtonClick)\n  bu_addprmt                .on_click (prompt_add)\n  bu_savprmt                .on_click (prompt_save)\n  bu_transla                .on_click (prompt_translate)\n  bu_delprmt                .on_click (prompt_del)\n  rb_prompts                .observe  (promptSelect,names=['value'])\n  # show first\n  promptSelect(None)\n\n  # help tab\n  ta_helper = Textarea(value=helptext.replace('\\n*','\\n\\n*'),layout=Layout(width='auto',height='600px'))\n\n  # build and config widgets\n  mainLayout    = Layout    (grid_template_rows='auto', grid_template_columns='150px auto', grid_template_areas='\"sidebar main\"')\n  mainAccordion = Accordion (children = [GridBox(layout=mainLayout) for all in courses] if len (courses) else [GridBox(layout=mainLayout)])\n  mainAccordion.children = tuple([*mainAccordion.children,gb_proedi,ta_helper])\n  mainAccordion.set_title(len(mainAccordion.children)-2,'prompt editor')\n  mainAccordion.set_title(len(mainAccordion.children)-1,'help')\n\n  # the pos of selected video inside a playlist box\n  vPositions = len(courses)*[-1]\n\n  # loop to build playlist related widgets structure - the object-names are used consistently\n  # and will be set in globalize() to the current displayed widgets: accordion tab / selected video\n  for i,title in enumerate(courses):\n\n    # the widgets for a playlist\n    mainAccordion.set_title(i,f'Playlist: {title}')\n    pl        = playlists_yaml[courses[title]]\n    gb_maingb = mainAccordion.children[i]\n    wi_firstw = HTML          (f'&lt;a href=\"{playlist_prefix}{courses[title]}\" title=\"{playlist_prefix}{courses[title]}\" target=\"_blank\"&gt;youtube&lt;/a&gt;')\n    rb_vidsel = RadioButtons  (options=[v[12:] if len (v) &gt; 12 else v for v in pl['videos']],layout=Layout(height='300px',overflow='scroll'))\n    bu_allchp = Button        (description='all &gt;&gt;&gt;&gt;',tooltip='',layout=Layout(width='auto'))\n    bu_frodes = Button        (description='from description',tooltip='Try parsing chapters out of video description.',\n                              layout=Layout(width='auto'),style={'button_color':'powderblue'})\n    bu_autchp = Button        (description='auto',tooltip='Division of the video into sections with max. tokens.',\n                              layout=Layout(width='60%'),style={'button_color':'powderblue'})\n    hb_autchp = HBox          (children=[Text (value='500',layout=Layout(width='40%')),bu_autchp])\n    bu_fromai = Button        (description='from ai',tooltip='Show the ai generated chapters',\n                              layout=Layout(width='50%'),style={'button_color':'powderblue'})\n    bu_aichap = Button        (description='aichaps',tooltip='(Re)build the ai chapters - uses the token len from auto as chapter size.',\n                              layout=Layout(width='50%'),style={'button_color':'hotpink'},disabled=not yes_i_have_this_chatgpt_openai_account)\n    hb_aichbu = HBox          (children=[bu_fromai,bu_aichap])\n    bu_cleanb = Button        (description='clean',tooltip='Comma seperated the number of generated timestamps and the max line lenght.',\n                              layout=Layout(width='60%'))\n    hb_cleanb = HBox          (children=[Text (value='3, 70',layout=Layout(width='40%')),bu_cleanb])\n    #                                        0        1         2          3         4        5         6\n    vb_vidsel = VBox          (children=[wi_firstw,rb_vidsel,bu_allchp,hb_cleanb,bu_frodes,hb_autchp,hb_aichbu,*prompt_buttons],layout=Layout(overflow=\"hidden\"))\n    bx_chpsel = Box           (layout=Layout(display='flex', flex_flow='wrap'))\n    ta_enTran = Textarea      (layout=Layout(width='50%',height='400px'))\n    ta_xxTran = Textarea      (layout=Layout(width='50%',height='400px'))\n    hb_transc = HBox          (children=[ta_enTran,ta_xxTran])\n    bu_enShow = Button        (description='show', style={'button_color':'lightgreen'}, layout=Layout(width='10%'),\n                              tooltip='paste the prompt at the top of the textarea - do this before send')\n    bu_enSend = Button        (description='send', style={'button_color':'orange'}, layout=Layout(width='10%'),\n                              tooltip='send the hole textarea content to gpt and shows response - be careful it sends everything that stands there')\n    bu_enLoop = Button        (description='loop', style={'button_color':'hotpink'}, layout=Layout(width='10%'),\n                              tooltip='make auto chapters and loop over all to: clean it (0,60), send with selected prompt to gpt and show response in new loop area')\n    bu_xxShow = Button        (description='show', style={'button_color':'lightgreen'}, layout=Layout(width='10%'),\n                              tooltip=bu_enShow.tooltip)\n    bu_xxSend = Button        (description='send', style={'button_color':'orange'}, layout=Layout(width='10%'),disabled=not yes_i_have_this_chatgpt_openai_account,\n                              tooltip=bu_enSend.tooltip)\n    bu_xxLoop = Button        (description='lopp', style={'button_color':'hotpink'}, layout=Layout(width='10%'),disabled=not yes_i_have_this_chatgpt_openai_account,\n                              tooltip=bu_enLoop.tooltip)\n    bu_enView = Button        (layout=Layout(width='auto', height='15px', border='2px solid'), style={'button_color':'lightgreen'},\n                              tooltip='Area for the prompt: first select text than select prompt and show.')\n    bu_enResu = Button        (layout=Layout(width='auto', height='15px'), style={'button_color':'orange'},\n                              tooltip='Area with the result from gpt for the sended prompt.')\n    bu_enLdel = Button        (layout=Layout(width='auto', height='15px'), style={'button_color':'Crimson'},\n                              tooltip='delete selected loop out off the yaml')\n    bu_xxView = Button        (layout=Layout(width='auto', height='15px', border='2px solid'), style={'button_color':'lightgreen'}, tooltip=bu_enView.tooltip)\n    bu_xxResu = Button        (layout=Layout(width='auto', height='15px'), style={'button_color':'orange'},tooltip=bu_enResu.tooltip)\n    bu_xxLdel = Button        (layout=Layout(width='auto', height='15px'), style={'button_color':'Crimson'},tooltip=bu_enLdel.tooltip)\n    hb_enSele = HBox          (children=[Box(children=[bu_enView, bu_enResu],\n                                            layout=Layout(display='flex', flex_flow='row', border='1px solid', width='95%')),\n                                        Box(children=[bu_enLdel],\n                                            layout=Layout(display='flex', flex_flow='row', border='1px solid', width='5%')) ])\n    hb_xxSele = HBox          (children=[Box(children=[bu_xxView, bu_xxResu],\n                                            layout=Layout(display='flex', flex_flow='row', border='1px solid', width='95%')),\n                                        Box(children=[bu_xxLdel],\n                                            layout=Layout(display='flex', flex_flow='row', border='1px solid', width='5%')) ])\n    hb_enCtrl = HBox          (children=[HTML(value='',layout=Layout(width='10%')),\n                                        Label(value='&lt;&lt;&lt;select prompt&gt;&gt;&gt;',layout=Layout(width='40%')),\n                                        Text(description='¬∞',value='0.1',layout=Layout(width='20%'),tooltip='temperature for api call'),\n                                        bu_enShow, bu_enSend, bu_enLoop], layout=Layout(border='1px solid black',width='auto'))\n    hb_xxCtrl = HBox          (children=[HTML(value='',layout=Layout(width='10%')),\n                                        Label(value='&lt;&lt;&lt;select prompt&gt;&gt;&gt;',layout=Layout(width='40%')),\n                                        Text(description='¬∞',value='0.1',layout=Layout(width='20%')),\n                                        bu_xxShow, bu_xxSend, bu_xxLoop], layout=Layout(border='1px solid black',width='auto'))\n    vb_enCtrl = VBox          (children=[hb_enCtrl,hb_enSele],layout=Layout(width='50%'))\n    vb_xxCtrl = VBox          (children=[hb_xxCtrl,hb_xxSele],layout=Layout(width='50%'))\n    hb_contrl = HBox          (children=[vb_enCtrl,vb_xxCtrl])\n    vb_chpare = VBox          (children=[bx_chpsel,hb_contrl,hb_transc])\n    gb_maingb                 .children = [vb_vidsel,vb_chpare]\n\n    # events\n    rb_vidsel                 .observe  (selectVideo, names=['value'])\n    mainAccordion             .observe  (selectVideo, names=['selected_index'])\n    bu_allchp                 .on_click (chapbutClick)\n    bu_enShow                 .on_click (enShowButtonClick)\n    bu_xxShow                 .on_click (xxShowButtonClick)\n    bu_enSend                 .on_click (enSendButtonClick)\n    bu_xxSend                 .on_click (xxSendButtonClick)\n    bu_enLoop                 .on_click (enLoopButtonClick)\n    bu_xxLoop                 .on_click (xxLoopButtonClick)\n    bu_autchp                 .on_click (autoButtonClick)\n    bu_frodes                 .on_click (fromDescriptionButtonClick)\n    bu_cleanb                 .on_click (cleanButtonClick)\n    bu_fromai                 .on_click (aiShowButtonClick)\n    bu_aichap                 .on_click (aiBuildButtonClick)\n    ta_enTran                 .observe  (text_change, names=['value'])\n    ta_xxTran                 .observe  (text_change, names=['value'])\n    bu_enView                 .on_click (areaSelect_en)\n    bu_enResu                 .on_click (areaSelect_en)\n    bu_xxView                 .on_click (areaSelect_xx)\n    bu_xxResu                 .on_click (areaSelect_xx)\n    bu_enLdel                 .on_click (loopDelete_en)\n    bu_xxLdel                 .on_click (loopDelete_xx)\n\n  # add / del / id input for single videos - no need for globalize\n  if 'no playlist' in playlists_yaml:\n    tx_singvid, bu_singvid = Text (layout=Layout(width='100px')), Button (description='+',tooltip='delete known, add unknown')\n\n    # kick wi_firstw HTML - replace with HBox\n    vb_vidsel.children = [HBox (children=[tx_singvid, bu_singvid],layout=Layout(width='auto')), *vb_vidsel.children[1:]]\n\n    # events\n    def tx_singvid_change (_):\n      bu_singvid.disabled    = len (tx_singvid.value) != 11\n      bu_singvid.description = '-' if tx_singvid.value+' ' in playlists_yaml['no playlist']['videos'] else '+'\n\n    def bu_singvid_click (b):\n      vl = playlists_yaml['no playlist']['videos']\n      if b.description == '+': vl.append (tx_singvid.value+' ')\n      if b.description == '-':\n        for filtered in [name for name in os.listdir() if tx_singvid.value in name]: os.remove (filtered)\n        vl.remove (tx_singvid.value+' ')\n      rb_vidsel.options=[v for v in vl]\n      playlists_yaml['no playlist']['videos'] = vl\n      yaml.dump (playlists_yaml, open('playlists.yml', 'w'))\n      selectVideo(None)\n      fromDescriptionButtonClick (bu_frodes)\n\n    tx_singvid.observe (tx_singvid_change, names=['value'])\n    bu_singvid.on_click (bu_singvid_click)\n\n  # display / globalize / unexpand accordion\n  display       (mainAccordion)\n  globalize     ()\n  mainAccordion.selected_index = None",
    "crumbs": [
      "<font size='0' color='#ffffff'>The lazy student notebook</font>"
    ]
  },
  {
    "objectID": "lazystudentnotebook.html#refactoring-goals",
    "href": "lazystudentnotebook.html#refactoring-goals",
    "title": "The lazy student notebook",
    "section": "Refactoring goals",
    "text": "Refactoring goals\nThe old version already contains one of the basic ideas of components, a graphical representation of themselves within a development environment. I achieve this here by using Colab forms, where form parameters serve as high-level settings of the component and Markdown comments provide the graphical representation.\nThis is one of the refactoring goals (component library). Let‚Äôs summarize all goals in a list:\n\nApplicationI want an application as result of the refactoring process with at least the same functionality but a new interface with a better ergonomie.\nComponont libraryThe idea behind it is to create functioning and stable components that the software should consist of. These are located in a library and can run independently of each other.\nUnit testingThe project is of course much too small to look at it with Scrum or XP eyes. But one artifact of agile software development can always (!) be recommended: Unit tests\nMediator PatternThe application serves as a mediator between the components. And that is exactly the design pattern that serves as the foundation of the application: the mediator pattern.\n\nMake it so‚Ä¶",
    "crumbs": [
      "<font size='0' color='#ffffff'>The lazy student notebook</font>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "lazystudent",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "lazystudent"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "lazystudent",
    "section": "Developer Guide",
    "text": "Developer Guide\nIf you are new to using nbdev here are some useful pointers to get you started.\n\nInstall lazystudent in Development mode\n# make sure lazystudent package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to lazystudent\n$ nbdev_prepare",
    "crumbs": [
      "lazystudent"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "lazystudent",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/frankausberlin/lazystudent.git\nor from conda\n$ conda install -c frankausberlin lazystudent\nor from pypi\n$ pip install lazystudent\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository‚Äôs pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "lazystudent"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "lazystudent",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don‚Äôt forget code examples:\n\n1+1\n\n2",
    "crumbs": [
      "lazystudent"
    ]
  },
  {
    "objectID": "yamler.html",
    "href": "yamler.html",
    "title": "Yamler",
    "section": "",
    "text": "source\n\nYamler\n\n Yamler (root='yamler', id_len=11, onInit={'config': False, 'files':\n         False, 'data': False}, mediator=None)\n\nset workingfolder, scan for yamls, load main yamls and build data object\n\n#big test\n!rm -rf yemler/; mkdir yemler; mkdir yemler/mathpl\n!echo \"test: 'hallo'\" &gt; yemler/01234567890.yml\n!echo \"test2: 'hallo2'\" &gt; yemler/01234567890_loop.yml\n!echo \"test3: 'hallo3'\" &gt; yemler/__info.yml\n!echo \"test4: 'hallo4'\" &gt; yemler/01234567890_de.yml\n!echo \"test: 'hallo'\" &gt; yemler/11234567890.yml\n!echo \"test2: 'hallo2'\" &gt; yemler/11234567890_loop.yml\n\n!echo \"test: 'hallo'\" &gt; yemler/mathpl/x1234567890.yml\n!echo \"test2: 'hallo2'\" &gt; yemler/mathpl/x1234567890_loop.yml\n!echo \"test3: 'hallo3'\" &gt; yemler/mathpl/__readme.yml\n!echo \"test4: 'hallo4'\" &gt; yemler/mathpl/x1234567890_de.yml\n!echo \"test: 'hallo'\" &gt; yemler/mathpl/x2234567890.yml\n!echo \"test2: 'hallo2'\" &gt; yemler/mathpl/x2234567890_loop.yml\n\ny = Yamler (root='yemler')\ny.activate()\n# conf\ny.data['01234567890']['_']['test'] += ' welta'\ny.data['01234567890']['loop']['test2'] += ' weltb'\ny.data['01234567890']['de']['test4'] += ' weltc'\ny.config['info']['test3'] += ' weltd'\ny.data['11234567890']['_']['test'] += ' weltx'\ny.data['11234567890']['loop']['test2'] += ' weltb'\ny.dump ()\n\ny.activate ('mathpl')\ny.data['x1234567890']['loop']['test2'] += ' weltx'\ny.data['x1234567890']['de']['test4'] += ' weltx'\ny.data['x1234567890']['_']['test'] += ' weltx'\ny.data['x2234567890']['_']['test'] += ' weltx'\ny.config['readme']['test3'] += ' weltx'\ny.dump ()\n\n\nprint ('root:')\n!cat yemler/01234567890.yml yemler/01234567890_loop.yml yemler/__conf.yml yemler/01234567890_de.yml yemler/11234567890.yml yemler/11234567890_loop.yml\nprint ('topic matpl:')\n!cat yemler/mathpl/x1234567890.yml yemler/mathpl/x1234567890_loop.yml yemler/mathpl/__cunf.yml yemler/mathpl/x1234567890_de.yml yemler/mathpl/x2234567890.yml yemler/mathpl/x2234567890_loop.yml\n\nroot:\ntest: hallo welta\ntest2: hallo2 weltb\ncat: yemler/__conf.yml: No such file or directory\ntest4: hallo4 weltc\ntest: hallo weltx\ntest2: hallo2 weltb\ntopic matpl:\ntest: hallo weltx\ntest2: hallo2 weltx\ncat: yemler/mathpl/__cunf.yml: No such file or directory\ntest4: hallo4 weltx\ntest: hallo weltx\ntest2: 'hallo2'",
    "crumbs": [
      "<font size='+2' color='#005F6A'>**Yamler**</font>"
    ]
  }
]