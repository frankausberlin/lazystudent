# <font size='0' color='#ffffff'>The lazy student notebook</font>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

<a href="https://colab.research.google.com/github/frankausberlin/lazystudent/blob/main/nbs/lazystudentnotebook.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

## What kind of notebook is this

- It contains an **application** called ‚ÄúLazy Student‚Äù which allows you
  to use **transcripts** of (lecture) **videos** as input for **AI
  prompts**.
- You can use it to **make chapters and summaries** or just **talk with
  an AI** about the video.
- If you just want to **use the software** go to the **last cell and
  run** it.

<font color='#005F6A'><i>But if you want a **quick peek** down the
rabbit hole of **modern software development**, go cell by cell.

Welcome to the notebook - it takes your laziness to a new level

<font size=5>üòâ</font>No, of course not, I‚Äôm just kidding.

The inspiration came when I came across prompt engineering. I thought, a
prompt like ‚ÄúCreate a summary‚Äù needs input, why not the transcription of
the lecture video I‚Äôm watching, and hey presto: the idea for ‚ÄúLazy
Student‚Äù was born.

So I started programming - and I programmed and programmed, and more and
more ideas came to me.

Maybe you remember being in a situation where you had to work hard to
get your code error-free and a voice inside you said: ‚ÄúThis isn‚Äôt good.
This code that can best be described as obese and it could be done
better. If I only had the time to do a careful refactoring.‚Äù

Well, I‚Äôm a guy who had this time.

And so, this is not just a tool to generate chapters, descriptions and
summaries from video transcriptions, it is much more about the following
key points:

**Refactoring** \* The first **faulty version** of Lazy Student can be
found right at the beginning \* Using **OO techniques** (inheritance,
classes, design patterns) in new version. \* Using a **Component
oriented** software design. \* ‚ÄòBig boys‚Äô development process -
**github, nbdev, pypi, conda**

**Python specials** \* Working with **ipywidgets**, **JavaScript**
integration and the **YouTube-API** \* Using **GDrive with Rclone** to
provide a **YAML**-based persistence mechanism \* Using the components
as **code snippets** collection for Google Colab. \* Using **nbdev** to
provide the components in a **library**, hosting on **pypi** and
**conda**.

**AI topics** \* It has a little **editor** for **prompt engineering**.
\* A loop function allows **using transcription** fragments **in
prompt**. \* Using **openai api** and its **chat completition**
mechanism. \* A chat client for **openai**, **gpt4all** and **compatible
models**

**PS**: The **flow of the refactoring process** is reflected in the
**order of the components**.

## View of the legacy

First we look at the code of the old version and try to find an answer
to the mother of all refactoring questions: ‚Äò[why my code is smelling so
bad?](https://en.wikipedia.org/wiki/Code_smell)‚Äô. Well, some points
immediately catch the eye.

- To much code for one cell.
- No object oriented sofware design - just globals and functions.
- No clear structuring into tasks or units.
- and so much more - look in the code

A word of explanation is needed here. LazyStudent is part of a notebook
called snippetpearls. This is a small collection of code snippets for
the Google Colab environment. Therefore, the code should be completely
in one cell. But as the functionality grew, I also moved away from the
basic idea of ‚Äã‚Äãthe ‚Äòcode snippet‚Äô.

I used the code snippet several times. Sometimes I needed these flex
wrap layout buttons, other times the YAML mechanism. Ultimately, all
these considerations led me to the decision to do a refactoring. And to
the decision to do this with a complete redesign of the software
architecture using a component-oriented approach. This means that I
divide the overall functionality into smaller, stable and self-contained
units, called components.

<table>

<tr>

<td align="center">

<font size=20>ü•≥</font><br><br><b>fun fact
</td>

<td>

Did you know that you can consider Colab notebooks as a component ware
and code snippets as components?<br>A component ware mainly has the
following features: \* Components can run independently, usually with an
exemplary default behavior or value. \* Possibility of using the
component at code level, e.g.¬†through inheritance. \* Provision of a
runtime environment in the form of a framework or middleware. \* A
development environment that enables the use of the component.

In this thought experiment, the code snippets are the components, Google
Forms ensure a graphical representation<br>and parameterization, the
runtime environment would then be the Jupyter runtime and the
development environment<br>would be the jupyter server. (I like to cite
Borland Delphi (RIP) as a classic example for component ware.)
</td>

</tr>

</table>

Ok, here comes the legacy‚Ä¶

<font size=5>üòâ</font> The author assumes no liability for psychological
damage caused by viewing the old code.

``` python
deactivate = True   #@param {type:"boolean"}
#@markdown [<font size='+2' color='#005F6A'>**lazy student**</font>](https://github.com/frankausberlin/lazy-student)<br>
#@markdown This is for the work-optimized student - openai's [prompt engineering](https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/) (**GPT**) with access to (collections of) video transicriptions, focused on bilingualism and yaml persistence.
#@markdown * Choose your language and (your collection - select a course and) a video - build your chapters - clean it, prompt it, loop it - be creative...
#@markdown * The prompt functions needs an **[openai](https://platform.openai.com/account/usage)** account for send your gpt request direct out of the widget.
#@markdown * It manages collections on your **session**, **gdrive** (~ 100 MB) or **local runtime** - there are some examples (new ones can easily be added):
#@markdown > * ['Practical Deeplearning for Coders'](https://course.fast.ai/) by Jeremy Howard (**folder dlfc**)
#@markdown > * ['MIT Introduction to Deep Learning'](http://introtodeeplearning.com/) by MIT (**folder mit**)
#@markdown > * [A collection by Stanford](https://www.youtube.com/@stanfordonline/playlists?view=50&sort=dd&shelf_id=4): CS221, CS224, CS229, CS330 (**folder stanford**).
#@markdown > * [StatQuest](https://statquest.org/) Collections by the singing guy [Josh Starmer](https://www.youtube.com/@statquest) (**folder statquest**).
#@markdown > * [Calculus](https://www.wikiwand.com/en/articles/Calculus) & Co - a math playlist collection from different sources (**folder mathpl**).
#@markdown * A **collection** is a list of several youtube **playlists** (playlists.yml) with its own **folder** for the **created yml** files.
#@markdown * As alternative to the collections there is a **single video** selection mode.
#@markdown * More questions? **Look in the help tab or code** - there are more detailed descriptions.
#@markdown ---

if not deactivate:
  helptext="""Basic concepts:
  * Bilangualism
    - The playlists.yml holds the description and the videos id of every playlist.
    - You have language specific (<cc>) yamls:
      - <vid>_<cc>.yml       - the transcription for a video
      - <vid>_loops_<cc>.yml - the loops for a video
    - Inside the Yamls 'prompts' and '<vid>_info.yml' you have have multi
      languages for every prompt / aichapters.
  * The yamls created
    - playlists.yml           : Infos and videos list for every playlist
    - prompts.yml             : The prompts - for all languages
    - <vid>_en.yml            : The english transcription
    - <vid>_<cc>.yml          : The <cc> transcription (see country codes below)
    - <vid>_info.yml          : Description, chapters and aichapters for video
    - <vid>_loops_<en|cc>.yml : Prompt loops history for video for a language
  * There is a persistence mechanic:
    - Select the correct working folder first:
      - if you use local runtime the working folder is located in your home folder
                        '~/<main_folder>'
      - if you are hosted and you checked 'use_gdrive...' your working folder is
                        '/gdrive/MyDrive/<main_folder>'
      - if you are hosted and you unchecked 'use_gdrive...' your working folder is
                        '/content/<main_folder>'
    - It only creates folders (main folder, collection folders) if not exists.
    - Yamls are only generated when they are needed:
      - playlists.yaml               by first run
      - *_en, *_<cc>, *_info files   by selection of a video
      - prompts.yml                  by save
      - *_loops_<cc>.yml             after doing loop.
    - Simple prompts are not stored.
  * Without api-key for openai the features using the api are disabled
    ('send', 'loop', 'build' and 'translate') but the prompt editor works.
  * The 'aichapters' prompt is a system prompt and can not be deleted but modified
    with a 70 char limit used for response.
  * The textareas does show the token count (the cyan text), the token factor
    ('*'-textfield, editable), the request temperatur ('¬∞'-textfield, editable).
  * Select a prompt (green button) and a chapter -> click show-button to create
    the prompt in the textarea and click send to send the textarea (!) as request
    and wait for response.
  * Between show and send you have the possibility to edit the prompt.
  * The loop mechanic takes the transcript from every chapter as input for the
    selected prompt and show the response in the textarea - be carefull it cannot
    be interupted (check token count in chapters - 16000 token max).
  * The api is not very stable - sometimes it hangs (about 1-3 minutes)
  * There are 3 attempts for all requests - so mostly the result is given.

  Notes UI:
  * When you run the cell it builds the widgets for the selected collection / mode.
  * You have a accordion tabed gridbox for every plalist and the prompt editor.
  * On start it takes first video of first playlist and try to create the chapters
    out of the description.
  * It creates the video radio buttons and the buttons to work with video:
      'all >>>>', 'clean', 'from description', 'auto', 'aichaps', 'build'
    and the prompt-buttons
  * If no chapters in description you can use the auto button. It takes the number
    (value left) as count for tokens in a chapter and generate a corresponding
    timestamp list for use for chapter buttons.
  * There are important infos in tooltips:
    - 'all >>>>'-button: the original description of the video.
    - prompt-buttons: the prompt textes
    - all other buttons: the description what they do.
  * There are are log message line below the accordion tab - shows current events.
  * With a small **editor** you have the possibility to have a little prompt
    engineering **fun** (note the 4000 token limit).
  * When you add a new prompt in the editor it will be shown as green prompt
    button for using with videos.

  Notes miscellaneous:
  * The current select video / playlist is set in globals: function globalize().
  * The request uses the textare text - you can reduce token len when you use
    the clean-button before send.
  * The libs pytube, youtubesearchpython, youtube_transcript_api and openai
    (if selected) will be installed.

  Widgets structure:

  mainAccordion
    |
    + [gb_maingb] - gridbox for every playlist -> set in globalize() to current selection
    |    + vb_vidsel - area left with video selection and buttons
    |    |    + wi_firstw - HTML youtube link / HBox[tx_singvid, bu_singvid]
    |    |    + rb_vidsel - the rbs for video selection
    |    |    + bu_allchp - the 'all >>>>' button
    |    |    + hb_cleanb
    |    |    |    + children0 txt for parameter - no global
    |    |    |    + bu_cleanb - clean button
    |    |    + bu_frodes - from description button
    |    |    + hb_autchp
    |    |    |    + children0 txt for parameter - no global
    |    |    |    + bu_autchp - auto button
    |    |    + hb_aichbu
    |    |    |    + bu_fromai, bu_aichap - buttons 'from ai' and 'aichaps'
    |    |    + [prompt_buttons] - button for every prompt
    |    + vb_chpare - big area with chapter selector and transcriptions
    |         + bx_chpsel - box for chapter selection
    |         |    + childrenN - button for every chapter
    |         + hb_contrl - control areas for en / xx
    |         |    + vb_enCtrl
    |         |    |    + hb_enCtrl
    |         |    |    |    + children0 (HTML) - token count - no global
    |         |    |    |    + children1 (Label) - prompt name - no global
    |         |    |    |    + children2 (Text) - input tf for temperatur - no global
    |         |    |    |    + bu_enShow, bu_enSend, bu_enLoop - buttons
    |         |    |    + hb_enSele
    |         |    |         + children0(Box)
    |         |    |              + bu_enView, bu_enResu - the green and red buttons
    |         |                   + [children2-n] - blue button for every loop
    |         |    |         + children1(Box)
    |         |    |              + bu_enLdel - the loop del button
    |         |    + vb_xxCtrl
    |         |         + hb_xxCtrl
    |         |         |    + children0 (HTML) - token count - no global
    |         |         |    + children1 (Label) - prompt name - no global
    |         |         |    + children2 (Text) - input tf for temperatur - no global
    |         |         |    + bu_xxShow, bu_xxSend, bu_xxLoop - buttons
    |         |         + hb_xxSele
    |         |              + children0(Box)
    |         |                   + bu_xxView, bu_xxResu - the green and red buttons
    |         |                   + [children2-n] - button for every loop
    |         |              + children1(Box)
    |         |                   + bu_xxLdel - the loop del button
    |         + hb_transc - area with transcriptions
    |              + ta_enTran - english transcription
    |              + ta_xxTran - xx transcription
    + gb_proedi - prompt editor tab
    |    + rb_prompt - the prompt radio-buttons
    |    + vb_proedi - parent for the prompt widgets
    |         + hb_probut - the buttons line
    |              + bu_addprmt, bu_delprmt, bu_savprmt, bu_transla
    |         + tx_protit - prompt title
    |         + hb_prompt - prompt text
    + ta_helper - help tab
  """
  import os, yaml, getpass, time
  try:
    from pytube                   import  Playlist
    from youtubesearchpython      import  Video
    from youtube_transcript_api   import  YouTubeTranscriptApi
  except:
    print ('stay tuned - installing stuff')
    os.system ('pip install pytube youtube-search-python youtube-transcript-api')
  from   ipywidgets               import  Accordion, VBox, HBox, Box, GridBox, HTML, Tab
  from   ipywidgets               import  Textarea, Text, RadioButtons, Button, Layout, Label
  from   datetime                 import  datetime
  from   pytube                   import  Playlist
  from   youtubesearchpython      import  Video
  from   youtube_transcript_api   import  YouTubeTranscriptApi

  # colab forms
  use_gdrive_for_persistence                = True   #@param {type:"boolean"}
  country_code_for_the_translation_language = 'de'   #@param {type:"string"}
  yes_i_have_this_chatgpt_openai_account    = False   #@param {type:"boolean"}
  use_english_for_ai_auto_chapters          = True  #@param {type:"boolean"}
  used_model                                = 'gpt-4-turbo' #@param ['gpt-3.5-turbo', 'gpt-3.5-instruct', 'gpt-4', 'gpt-4-turbo', 'gpt-4o']


  ####################################################################################################################################
  ################################################## defaults / customization ########################################################
  ####################################################################################################################################
  playlist_prefix       = 'https://www.youtube.com/playlist?list='
  video_prefix          = 'https://www.youtube.com/watch?v='
  main_folder           = 'lazy_collections'
  selected_collection   = 'Practical Deep Learning for Coders / fast.ai live coding & tutorials' #@param ['Calculus & Co - a math playlist collection', 'Single video selection','StatQuest!!!-Collections by the singing guy Josh Starmer','MIT courses around deep learning','Practical Deep Learning for Coders / fast.ai live coding & tutorials', "A collection of free Stanford courses: CS221, CS224, CS229, CS330"]

  #
  #         ||      your                                   /\
  #      \ \||/ /   collection                            /||\
  #       \ \/ /    here                                   ||
  #        \  /                              (don't forget: add to param list)
  #         \/
  #
  # if 'some unique' in selected_collection:
  #   courses = { 'Course 1'  : 'PL******',
  #               'Course 2'  : 'PL******',
  #               'Course 3'  : 'PL******'}
  #   folder_for_playlist_collection = 'yourfolder'

  # The collections
  if 'StatQuest' in selected_collection:
    courses = { 'Histograms Clearly Explained - #66DaysOfData'                                                : 'PLblh5JKOoLUJUNlfvCNhJMNjNNpt5ljcR',
                'Histograms Clearly Explained - Statistics Fundamentals'                                      : 'PLblh5JKOoLUK0FLuzwntyYI10UQFUhsY9',
                'A Gentle Introduction to Machine Learning'                                                   : 'PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI',
                'Neural Networks / Deep Learning'                                                             : 'PLblh5JKOoLUIxGDQs4LFFD--41Vzf-ME1' }
    folder_for_playlist_collection = 'statquest'

  if 'MIT courses' in selected_collection:
    courses = { '6.0001 Introduction to Computer Science and Programming in Python'                           : 'PLUl4u3cNGP63WbdFxL8giv4yhgdMGaZNA',
                'MIT 18.S096 Matrix Calculus For Machine Learning And Beyond'                                 : 'PLUl4u3cNGP62EaLLH92E_VCN4izBKK6OE',
                'MIT 6.S191: Introduction to Deep Learning'                                                   : 'PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI',
                'EfficientML.ai Lecture, Fall 2023, MIT 6.5940'                                               : 'PL80kAHvQbh-pT4lCkDT53zT8DKmhE0idB' }
    folder_for_playlist_collection = 'mit'

  if 'Stanford' in selected_collection:
    courses = { 'CS221:  2021 - Artificial Intelligence: Principles and Techniques (Percy Liang)'             : 'PLoROMvodv4rOca_Ovz1DvdtWuz8BfSWL2',
                'CS221:  2019 - Artificial Intelligence: Principles and Techniques (Percy Liang)'             : 'PLoROMvodv4rO1NB9TD4iUZ3qghGEGtqNX',
                'CS224N: 2021 - NLP with Deep Learning (Christopher Manning)'                                 : 'PLoROMvodv4rOSH4v6133s9LFPRHjEmbmJ',
                'CS224W: 2021 - Machine Learning with Graphs (Jure Leskovec)'                                 : 'PLoROMvodv4rPLKxIpqhjhPgdQy7imNkDn',
                'CS224U: 2021 - Natural Language Understanding (Christopher Potts)'                           : 'PLoROMvodv4rPt5D0zs3YhbWSZA8Q_DyiJ',
                'CS229:  2018 - Machine Learning Full Course (Andrew Ng)'                                     : 'PLoROMvodv4rMiGQp3WXShtMGgzqpfVfbU',
                'CS229:  2019 - Machine Learning Course (Anand Avati)'                                        : 'PLoROMvodv4rNH7qL6-efu_q2_bPuy0adh',
                'CS330:  2022 - Deep Multi-Task & Meta Learning - What is multi-task learning? (Chelsea Finn)': 'PLoROMvodv4rNjRoawgt72BBNwL2V7doGI' }
    folder_for_playlist_collection = 'stanford'

  if 'Deep Learning for Coders' in selected_collection:
    courses = { 'Practical Deep Learning for Coders 2022'                                                     : 'PLfYUBJiXbdtSvpQjSnJJ_PmDQB_VyT5iU',
                'Practical Deep Learning 2022 Part 2'                                                         : 'PLfYUBJiXbdtRUvTUYpLdfHHp9a58nWVXP',
                'fast.ai live coding & tutorials'                                                             : 'PLfYUBJiXbdtSLBPJ1GMx-sQWf6iNhb8mM',
                'APL & array programming'                                                                     : 'PLfYUBJiXbdtSgU6S_3l6pX-4hQYKNJZFU',
                'Practical Deep Learning for Coders (2020)'                                                   : 'PLfYUBJiXbdtRL3FMB3GoWHRI8ieU6FhfM',
                'Practical Deep Learning for Coders 2019'                                                     : 'PLfYUBJiXbdtSIJb-Qd3pw0cqCbkGeS0xn' }
    folder_for_playlist_collection = 'dlfc'

  if 'Calculus & Co' in selected_collection:
    courses = { 'Essence of calculus, by Grant Sanderson (3Blue1Brown)'                                       : 'PLZHQObOWTQDMsr9K-rj53DwVRMYO3t5Yr',
                'Computational Linear Algebra, by Rachel Thomas (fastai)'                                     : 'PLtmWHNX-gukIc92m1K0P6bIOnZb-mg0hY',}
    folder_for_playlist_collection = 'mathpl'


  ####################################################################################################################################
  ########################################## single video / folders / globals / playlists.yaml #######################################
  ####################################################################################################################################
  # Single video
  if 'Single video selection' in selected_collection:
    courses = {'Single video selection':'no playlist'}
    folder_for_playlist_collection = 'singles'

  # gdrive only for hosted runtime
  if use_gdrive_for_persistence and os.path.expanduser('~') == '/root':
    from google.colab import drive
    if not 'gdrive'  in os.listdir('/'): drive.mount('/gdrive')
    # working folder gdrive
    if not 'MyDrive' in os.getcwd(): os.chdir ('/gdrive/MyDrive')
  else:
    # working folder hosted / local
    if os.path.expanduser('~') == '/root':  os.chdir ('/content')
    else:                                   os.chdir (os.path.expanduser('~'))

  # create / change to main folder
  if main_folder in os.listdir():  os.chdir (main_folder)
  else:
    # check if parent main folder
    if main_folder in os.getcwd(): os.chdir('..')
    else:
      os.mkdir (main_folder)
      os.chdir(main_folder)

  # create / change to collection folder
  if folder_for_playlist_collection in os.listdir(): os.chdir (folder_for_playlist_collection)
  else:
    os.mkdir (folder_for_playlist_collection)
    os.chdir(folder_for_playlist_collection)

  # load
  if os.path.exists('playlists.yml'):
    playlists_yaml = yaml.load(open('playlists.yml', 'r'), Loader=yaml.FullLoader)
  # or new (language)
  try:    playlists_yaml['language'] = country_code_for_the_translation_language.split(' ')[0]
  except: playlists_yaml             = {'language':country_code_for_the_translation_language.split(' ')[0]}
  cc                                 = playlists_yaml['language']

  # playlist loop
  for i,title in enumerate(courses):
    # single video
    if courses[title] == 'no playlist':
      try:    vl = playlists_yaml['no playlist']['videos']
      except: vl = []
      playlists_yaml['no playlist'] = {'title':'single videos', 'description':'hand added videos', 'videos':vl}
      break

    # check if infos exists
    if not courses[title] in playlists_yaml:
      # lazy using pytube
      from pytube import Playlist
      try:      pl     = Playlist(f'{playlist_prefix}{courses[title]}')
      except:   raise    Exception ('BIG_OOPS')
      try:      descr  = pl.description
      except:   descr  = 'no description in pytube'
      try:      links  = [link for link in pl]
      except:   links  = []
      videos           = [f"{link.split('?v=')[-1]} Video {vnr+1}" for vnr, link in enumerate(links)]
      playlists_yaml[courses[title]] = {'title':title, 'description':descr, 'videos':videos}
  # write playlists.yml
  yaml.dump (playlists_yaml, open('playlists.yml', 'w'))


  ####################################################################################################################################
  ########################################################## helper ##################################################################
  ####################################################################################################################################
  def globalize ():
    """ set globals (widgets and relevant infos) to the current accordion tab / selected video
        see widgets structure in help text
    """
    # relevant infos
    global vPositions, videoInfos, enTrans, xxTrans, courses, playlists_yaml, cc, acIndex, plid, rbIndex, vid, countryCodes
    global store_en, store_xx
    # widgets
    global mainAccordion,        gb_maingb, vb_vidsel, vb_chpare, wi_firstw, rb_vidsel, bu_allchp, hb_cleanb, bu_frodes
    global hb_autchp, hb_aichbu, bu_cleanb, bu_autchp, bu_fromai, bu_aichap, bx_chpsel, hb_contrl, hb_transc, vb_enCtrl
    global vb_xxCtrl, hb_enCtrl, hb_xxCtrl, bu_enShow, bu_enSend, bu_enLoop, bu_xxShow, bu_xxSend, bu_xxLoop, hb_enSele
    global hb_xxSele, bu_enView, bu_enResu, bu_enLsel, bu_xxView, bu_xxResu, bu_xxLsel, ta_enTran, ta_xxTran

    # set globals to current displayed playlist
    gb_maingb                       = mainAccordion.children[mainAccordion.selected_index]
    vb_vidsel, vb_chpare            = gb_maingb.children[0], gb_maingb.children[1]

    # vb_vidsel - area left with video selection and buttons
    wi_firstw, rb_vidsel, bu_allchp = vb_vidsel.children[0], vb_vidsel.children[1], vb_vidsel.children[2]
    hb_cleanb, bu_frodes, hb_autchp = vb_vidsel.children[3], vb_vidsel.children[4], vb_vidsel.children[5]
    hb_aichbu                       = vb_vidsel.children[6]
    bu_cleanb, bu_autchp            = hb_cleanb.children[1], hb_autchp.children[1]
    bu_fromai, bu_aichap            = hb_aichbu.children[0], hb_aichbu.children[1]

    # vb_chpare - big area with chapter selector and transcriptions
    bx_chpsel, hb_contrl, hb_transc = vb_chpare.children[0], vb_chpare.children[1], vb_chpare.children[2]
    vb_enCtrl, vb_xxCtrl            = hb_contrl.children[0], hb_contrl.children[1]
    hb_enCtrl, hb_xxCtrl            = vb_enCtrl.children[0], vb_xxCtrl.children[0]
    bu_enShow, bu_enSend, bu_enLoop = hb_enCtrl.children[3],hb_enCtrl.children[4],hb_enCtrl.children[5]
    bu_xxShow, bu_xxSend, bu_xxLoop = hb_xxCtrl.children[3],hb_xxCtrl.children[4],hb_xxCtrl.children[5]
    hb_enSele, hb_xxSele            = vb_enCtrl.children[1], vb_xxCtrl.children[1]
    bu_enView, bu_enResu, bu_enLsel = hb_enSele.children[0].children[0],hb_enSele.children[0].children[1], hb_enSele.children[1].children[0]
    bu_xxView, bu_xxResu, bu_xxLsel = hb_xxSele.children[0].children[0],hb_xxSele.children[0].children[1], hb_xxSele.children[1].children[0]
    ta_enTran, ta_xxTran            = hb_transc.children[0], hb_transc.children[1]

    # current selection
    acIndex = mainAccordion.selected_index
    plid    = [courses[all] for all in courses][acIndex]
    rbIndex = rb_vidsel.options.index(rb_vidsel.value) if rb_vidsel.value else -1
    vid     = playlists_yaml[plid]['videos'][rbIndex][:11] if rbIndex > -1 else ''

  def parseChaptersFromDescription (description):
    lines = description.split('\n')
    chaps = []
    for l in lines:
      if ':' in l:
        for i,c in enumerate(l):
          if c == ':':
            if i > 0 and l[i-1].isdigit() and i < len(l)-1 and l[i+1].isdigit():
              start = i - (2 if i > 1 and l[i-2].isdigit() else 1)
              for end,c in enumerate (l[i+1:]):
                if not c.isdigit() and c != ':': break
              chaps.append(l[start:end+i+1]+' '+l[end+i+2:])
              break
    return chaps

  def timestampTabView (trans):
    """ make the transcription text format for the textareas """
    txt, max_block_line_len = '', 60
    for all in trans:
      tmp, block, sec = all['text'].replace('\xa0','').replace('\n',''), [], int(all['start'])
      h, i = sec//3600, len (tmp)
      m    = (sec - (h*3600)) // 60
      s    = sec - h*3600 - m*60
      # make a text block
      while len (tmp) > max_block_line_len:
        for i in reversed(range(max_block_line_len)):
          if tmp[i] == ' ': break
        block.append(tmp[:i])
        tmp = tmp[i+1:]
      block.append(tmp[:i])
      # and show it with tabs
      for i,l in enumerate (block):
        if i == 0: txt += f"{h}:{m:02d}:{s:02d}\t{l}\n"
        else:      txt += f"\t{l}\n"
    return txt

  def getStartEndFromChapterButton (b):
    gb_maingb                       = mainAccordion.children[mainAccordion.selected_index]
    vb_vidsel, vb_chpare            = gb_maingb.children[0], gb_maingb.children[1]
    bx_chpsel, hb_contrl, hb_transc = vb_chpare.children[0], vb_chpare.children[1], vb_chpare.children[2]

    # start ts from button
    ts = b.description.split(' ')[0]
    if len(ts.split(':')) == 2: start = int(ts.split(':')[0])*60+int(ts.split(':')[1])
    else: start = int(ts.split(':')[0])*3600+int(ts.split(':')[1])*60+int(ts.split(':')[2])

    # search next button
    nb = None
    for i,sb in enumerate(bx_chpsel.children):
      if b.description == sb.description: break

    # end ts from search
    if i >= len(bx_chpsel.children)-1: ts = '99:00:00'
    else: ts = bx_chpsel.children[i+1].description.split(' ')[0]
    if len(ts.split(':')) == 2: end = int(ts.split(':')[0])*60+int(ts.split(':')[1])
    else: end = int(ts.split(':')[0])*3600+int(ts.split(':')[1])*60+int(ts.split(':')[2])
    return start, end

  def makeAutoChapters (max,lines,tfac):
    # generate chapters (timestamp list)
    chapters = []
    while(True):
      # first in lines is new timestamp
      if lines[0].split('\t')[0] != '': chapters.append(lines[0].split('\t')[0])

      # search for the next timestamp so that the distance between the two timestamps (growRange)
      # is bigger than max tokens and rest is big enough for own chapter (1/5 max).
      for nextTS,l in enumerate (lines):
        growRange = len('\n'.join(lines[:nextTS]))//tfac
        restRange = len('\n'.join(lines[nextTS:]))//tfac
        if len(lines[nextTS]) and growRange > max and lines[nextTS][1]==':' and lines[nextTS][4]==':' and restRange > max/5: break

      # shrink lines or terminate
      if len(lines[:nextTS]) > 0:  lines = lines[nextTS:]
      else:                        break
    return chapters

  def taCleaner (lines,tsCount,bs=None):
    if tsCount > len (lines): tsCount = 1

    org, tmp, trigger = tsCount, '', False
    for i,l in enumerate(lines): # all lines
      if tsCount and not i%(len(lines)//org): # trigger if ts should create
        tsCount -= 1
        trigger = True
      if trigger and l != '' and l[1] == ':': # create ts
        if i > 0: tmp += '\n'
        tmp += l.split('\t')[0]+'\n'          # create blockline
        trigger = False
      if '\t' in l:
        tmp += l.split('\t')[1]+'\n'
    # return tmp - if no block wanted
    if bs == None: bs = 60
    lines, tmp2, nl = tmp.split('\n'), '', ''
    for i,l in enumerate(lines): # build block
      if len (l) > 1 and l[1] != ':':
        words = l.split(' ')
        for w in words:
          if len (nl+' '+w) < bs:
            nl += ' '+w
          else:
            tmp2 += nl + '\n'
            nl = w
      else:
        tmp2 += l+'\n'
    return tmp2.replace('\n ','\n')

  def storeLoop (vid, txt, ccode):
    lid = ''
    if txt[:13] == '... do prompt':
      # yaml
      if not os.path.exists(f'{vid}_loops_{ccode}.yml'): loops_yaml = {}
      else: loops_yaml = yaml.load (open(f'{vid}_loops_{ccode}.yml', 'r'), Loader=yaml.FullLoader)
      lid = datetime.now().strftime("%Y%m%d-%H%M%S")
      loops_yaml[lid] = txt
      yaml.dump (loops_yaml, open(f'{vid}_loops_{ccode}.yml', 'w'))
    return lid

  def resetTransArea ():
    globalize()

    # unselect prompt / clear textareas / message / lastState
    hb_enCtrl.children[1].value = hb_xxCtrl.children[1].value = '<<<select prompt>>>'
    ta_enTran.value, ta_xxTran.value = "... select chapter or click 'all >>>>'", '...'

    # buttonstyles
    for but in bx_chpsel.children: but.button_style   = ''
    bu_allchp.button_style                            = ''




  ####################################################################################################################################
  ################################################## openai-stuff: prompts ###########################################################
  ####################################################################################################################################
  # defaults
  summary_50_en = """Below is an excerpt from a transcription of a video that starts after this string '##x##'.
  The video is a course about Deep Learning.
  Create a summary of the content of the excerpt in 50 words or less.
  To do this, first clean up the raw text by removing the time stamps, merging the text, and ridding it of errors or clutter.
  ##x##
  """
  summary_50_de = """Im Folgenden findest du einen Auszug aus der Transkription eines Videos, das nach dieser Zeichenfolge '##x##' beginnt.
  Das Video ist ein Kurs √ºber Deep Learning.
  Erstelle eine Zusammenfassung des Inhalts des Auszugs in 50 W√∂rtern oder weniger.
  Bereinige dazu zun√§chst den Rohtext, indem du die Zeitstempel entfernst, den Text zusammenf√ºhrst und ihn von Fehlern oder Unordnung befreien.
  ##x##
  """
  keywords_en = """The text is an excerpt from the transcription of a video and it starts after this character sequence: '##x##'. Create a keyword list in the following structure:

  - Keyword 1
  - ...
  - Keyword n

  ##x##
  """
  keywords_de = """Bei dem Text handelt es sich um einen Auszug aus der Transkription eines Videos und er beginnt nach dieser Zeichenfolge: '##x##'. Erstelle eine Schlagwortliste in folgender Struktur:

  - Schlagwort 1
  - ...
  - Schlagwort n

  ##x##
  """
  hints_en = """The text is an excerpt from the transcription of a video and it starts after this character sequence: '##x##'. Create a hint list in the following structure:

  - Hint 1
  - ...
  - Hint n

  ##x##
  """
  hints_de = """Bei dem Text handelt es sich um einen Auszug aus der Transkription eines Videos und er beginnt nach dieser Zeichenfolge: '##x##'. Erstelle eine Liste von Hinweisen in folgender Struktur:

  - Hinweis 1
  - ...
  - Hinweis n

  ##x##
  """
  aichapters_de = """Bei dem Text handelt es sich um einen Auszug aus der Transkription eines Videos und er beginnt nach dieser Zeichenfolge: '##x##'.
  Das Video ist eines von vielen aus einer Tutorial Reihe zum Thema Deep Learning f√ºr Programmierer.
  Finde einen Titel f√ºr diese Sektions des Videos, der zusammenfassende Schlagw√∂rter beinhaltet und nicht mehr als 10 W√∂rter sein soll.
  Gib den nur Titel als ergebnis zur√ºck in deutscher Sprache.
  ##x##
  """
  aichapters_en = """The text is an excerpt from the transcription of a video and it starts after this string: '##x##'.
  The video is one of many in a tutorial series on Deep Learning for programmers.
  Find a title for this section of the video that includes summary keywords and should be no more than 10 words.
  Return only the title as the result.
  ##x##
  """
  profile_de = """Bei dem Text handelt es sich um einen Auszug aus der Transkription eines Videos und er beginnt nach dieser Zeichenfolge: ##x##. Erstelle eine Kapitelbeschreibung f√ºr den Text in folgender Struktur:

  Schlagw√∂rter:
  - Schlagwort 1
  - ...
  - Schlagwort n

  Hinweise:
  - Hinweis 1
  - ...
  - Hinweis n

  Zusammenfassung:
  <ein zusammenfassender Text mit nicht mehr als 100 W√∂rtern>

  ##x##
  """
  profile_en = """The text is an excerpt from the transcription of a video and starts after this character string: ##x##. Create a chapter description for the text in the following structure:

  Keywords:
  - Keyword 1
  - ...
  - Keyword n

  Notes:
  - Note 1
  - ...
  - Note n

  Summary:
  <a summary text with no more than 100 words>

  ##x##
  """
  # prompts_yaml
  if not os.path.exists('prompts.yml'):
    prompts_yaml = {'summary 50':   {'en':summary_50_en , 'de':summary_50_de},
                    'keywords':     {'en':keywords_en   , 'de':keywords_de},
                    'hints':        {'en':hints_en      , 'de':hints_de},
                    'profile':      {'en':profile_en    , 'de':profile_de},
                    '_aichapters_': {'en':aichapters_en , 'de':aichapters_de}}
    yaml.dump (prompts_yaml, open('prompts.yml', 'w'))
  else:
    prompts_yaml = yaml.load(open('prompts.yml', 'r'), Loader=yaml.FullLoader)


  ####################################################################################################################################
  ############################################ openai-stuff: libs / account / helper #################################################
  ####################################################################################################################################
  if yes_i_have_this_chatgpt_openai_account:
    default_temperature = 0.2
    default_chartokfac  = 3.1
    tmphm =  HTML("""Get <a href='https://platform.openai.com/account/api-keys' target='_blank'>here</a> your API-Key.""")
    display  (tmphm)
    try:     import openai
    except:  os.system ('pip install openai'); import openai
    try:     openai.api_key = os.environ["OPENAI_API_KEY"]
    except:  openai.api_key = getpass.getpass (prompt='Your API key: ')
    os.environ["OPENAI_API_KEY"] = openai.api_key
    tmphm.value = """<font color='green'>Set API-key done!</font>"""
    from openai import OpenAI
    chatclient = OpenAI()

  def get_completion(prompt, model=None,temperature=None):
    if not yes_i_have_this_chatgpt_openai_account: return 'no account'
    # do an openai api call
    if not model:         model         = used_model
    if not temperature:   temperature   = default_temperature
    messages, maxTry                    = [{"role": "user", "content": prompt}], 3
    for t in range (maxTry):
      try: # try maxTry times
        time.sleep (t+1)
        chatclient.chat.completions
        return chatclient.chat.completions.create(model=model, messages=messages, temperature=temperature).choices[0].message.content
        #return 'under construction'
      except Exception as e:
        print (f"\r\x1b[91mApi-Error: {e}",end=' ')
    return 'oops - something goes wrong...'

  def text_change(_):
    global textChangeFromYaml
    if textChangeFromYaml: return

    cyanbox = lambda s: "<table width='50'><tr><td align='center'><p style='background-color:#B0E0E6'>"+s+"</p></td></tr></table>"
    # compute tokens
    hb_enCtrl.children[0].value = cyanbox(str(int(len(ta_enTran.value) // default_chartokfac+1)))
    hb_xxCtrl.children[0].value = cyanbox(str(int(len(ta_xxTran.value) // default_chartokfac+1)))

    # store text
    for i,b in enumerate (hb_enSele.children[0].children):
      if b.layout.border != None: break
    if i >= 0 and i < 2: store_en[i] = ta_enTran.value

    for i,b in enumerate (hb_xxSele.children[0].children):
      if b.layout.border != None: break
    if i >= 0 and i < 2: store_xx[i] = ta_xxTran.value


  def refreshPrompts():
    # tab loop
    for gb_maingb in mainAccordion.children[:-2]:
      vb_vidsel      = gb_maingb.children[0]
      prompt_buttons = [Button (description=p,
                                tooltip=str(prompts_yaml[p]['en']) if 'en' in prompts_yaml[p] else '' + '\n' +
                                        str(prompts_yaml[p][cc])  if cc in prompts_yaml[p] else '',
                                style={'button_color':'lightgreen'}) for p in prompts_yaml if p[0] != '_']
      for b in prompt_buttons: b.on_click (promptButtonClick)
      firstPromptButtonPos = 3 # for safety
      for i,but in enumerate (vb_vidsel.children):
        try: # somtimes python is ... - hm ... - special
          if but.style.button_color == 'lightgreen':
            firstPromptButtonPos = i
            break
        except: pass
      for oldbut in vb_vidsel.children[firstPromptButtonPos:]:  del oldbut
      vb_vidsel.children = [*vb_vidsel.children[:firstPromptButtonPos],*prompt_buttons]


  ####################################################################################################################################
  ################################################ openai-stuff: buttons bi-transcription area #######################################
  ####################################################################################################################################
  def ccShowButtonClick (b,ccode):
    if ccode == 'en': hb_ccCtrl, bu_ccView, ta_ccTran = hb_enCtrl, bu_enView, ta_enTran
    else:             hb_ccCtrl, bu_ccView, ta_ccTran = hb_xxCtrl, bu_xxView, ta_xxTran
    # check prompt selected
    if hb_ccCtrl.children[1].value == '<<<select prompt>>>': return
    # select view areas
    if ccode == 'en':  areaSelect_en (bu_ccView)
    else: areaSelect_xx (bu_ccView)
    # generate prompts and show
    if len (prompts_yaml[hb_ccCtrl.children[1].value][ccode]) > 50:
      ta_ccTran.value = f"{prompts_yaml[hb_ccCtrl.children[1].value][ccode]}\n{ta_ccTran.value}"
  def enShowButtonClick (b): ccShowButtonClick (b,'en')
  def xxShowButtonClick (b): ccShowButtonClick (b,country_code_for_the_translation_language.split(' ')[0])

  def ccSendButtonClick (b, ccode):
    # set language and select result area
    if ccode == 'en':
      hb_ccCtrl, store_cc, ta_ccTran = hb_enCtrl, store_en, ta_enTran
      areaSelect_en(bu_enResu)
    else:
      hb_ccCtrl, store_cc, ta_ccTran = hb_xxCtrl, store_xx, ta_xxTran
      areaSelect_xx(bu_xxResu)

    # show wait message / response
    prompt = hb_ccCtrl.children[1].value
    hb_ccCtrl.children[1].value = '<<<select prompt>>>'
    if yes_i_have_this_chatgpt_openai_account:
      ta_ccTran.value = '... waiting for response'
      ta_ccTran.value = f'>>>>> response for prompt {prompt} >>>>>\n'+get_completion (store_cc[0],temperature=float(hb_ccCtrl.children[2].value))
    else:
      ta_ccTran.value = 'sorry - no account'

  def enSendButtonClick (b): ccSendButtonClick (b,'en')
  def xxSendButtonClick (b): ccSendButtonClick (b,country_code_for_the_translation_language.split(' ')[0])

  def ccLoopButtonClick (b,ccode):
    globalize ()
    if ccode == 'en': hb_ccCtrl, hb_ccSele, areaSelect_cc, store_cc, ta_ccTran, ccTrans = hb_enCtrl, hb_enSele, areaSelect_en, store_en, ta_enTran, enTrans
    else:             hb_ccCtrl, hb_ccSele, areaSelect_cc, store_cc, ta_ccTran, ccTrans = hb_xxCtrl, hb_xxSele, areaSelect_xx, store_xx, ta_xxTran, xxTrans

    # check prompt selected
    if hb_ccCtrl.children[1].value == '<<<select prompt>>>': return

    # create and select new loop button
    for bu in hb_ccSele.children[0].children: bu.layout = Layout (width='auto', height='15px')
    newbut = Button (layout=Layout(width='auto', height='15px', border='2px solid'), style={'button_color':'hotpink'},
                    tooltip='')
    newbut.on_click (areaSelect_cc)
    store_cc.append('')
    hb_ccSele.children[0].children = [*hb_ccSele.children[0].children, newbut]

    # show wait message / response
    prompt = hb_ccCtrl.children[1].value
    ta_ccTran.value = f'... do prompt <"'+prompt+'"> for ...\n'
    for b in bx_chpsel.children:
      ta_ccTran.value += '\n>>>>>>'+b.description + '>>>>>>\n'
      start, end       = getStartEndFromChapterButton (b)
      tmp              = taCleaner (timestampTabView ([t for t in ccTrans[vid] if t['start'] >= start and t['start'] < end]).split('\n'),0)
      response         = get_completion ( f"{prompts_yaml[prompt][ccode]}\n{tmp}", temperature=float(hb_ccCtrl.children[2].value) )
      ta_ccTran.value += f"{response}\n" if response[-1] != '\n' else f"{response}"

    # yaml it
    lid = storeLoop (vid, ta_ccTran.value, ccode)
    newbut.tooltip = f'{lid} - prompt: {prompt}'
    ta_ccTran.value += f"\n\n>>>>>> write to {f'{vid}_loops_{ccode}.yml >>>>>>'}"
  def enLoopButtonClick (b): ccLoopButtonClick (b,'en')
  def xxLoopButtonClick (b): ccLoopButtonClick (b,country_code_for_the_translation_language.split(' ')[0])

  textChangeFromYaml = False
  def areaSelect_cc (b, ccode):
    global textChangeFromYaml
    textChangeFromYaml = True

    if ccode == 'en': hb_ccSele, store_cc, ta_ccTran = hb_enSele, store_en, ta_enTran
    else:             hb_ccSele, store_cc, ta_ccTran = hb_xxSele, store_xx, ta_xxTran

    # save current textarea
    for i,bu in enumerate (hb_ccSele.children[0].children):
      if bu.layout.border: break
    if i >= 0 and i < 2: store_cc[i] = ta_ccTran.value

    # draw / undraw selection border
    for bu in hb_ccSele.children[0].children: bu.layout = Layout (width='auto', height='15px')
    b.layout = Layout (width='auto', height='15px', border='2px solid')

    # restore textarea
    for i,bu in enumerate (hb_ccSele.children[0].children):
      if bu == b: break
    if i >= 0 and i < len(store_cc): ta_ccTran.value = store_cc[i]
    textChangeFromYaml = False

  def areaSelect_en (b): areaSelect_cc (b,'en')
  def areaSelect_xx (b): areaSelect_cc (b,country_code_for_the_translation_language.split(' ')[0])

  def loopDelete_cc (ccode):
    if ccode == 'en': hb_ccSele, store_cc, areaSelect_cc, bu_ccView = hb_enSele, store_en, areaSelect_en, bu_enView
    else:             hb_ccSele, store_cc, areaSelect_cc, bu_ccView = hb_xxSele, store_xx, areaSelect_xx, bu_xxView
    # find selected loop area
    for i,b in enumerate (hb_ccSele.children[0].children):
      if b.layout.border != None: break
    if i >= 2 and i < len (hb_ccSele.children[0].children):
      # delete from txt store, button list and yaml file / select view area
      hb_ccSele.children[0].children = [*hb_ccSele.children[0].children[:i],*hb_ccSele.children[0].children[i+1:]]
      store_cc = [store_cc[:i],store_cc[i+1:]]
      areaSelect_cc (bu_ccView);
      try:
        loops_yaml = yaml.load(open(f'{vid}_loops_{ccode}.yml', 'r'), Loader=yaml.FullLoader)
        del loops_yaml[b.tooltip.split(' - ')[0]]
        yaml.dump (loops_yaml, open(f'{vid}_loops_{ccode}.yml', 'w'))
      except: pass
  def loopDelete_en (b): loopDelete_cc ('en')
  def loopDelete_xx (b): loopDelete_cc (country_code_for_the_translation_language.split(' ')[0])


  ####################################################################################################################################
  ####################################################### buttons left area ##########################################################
  ####################################################################################################################################
  def promptButtonClick (b):
    # set prompt actve -> show-button
    hb_enCtrl.children[1].value, hb_xxCtrl.children[1].value = b.description, b.description
    if 'info' in [b.button_style for b in [bu_allchp,*bx_chpsel.children]]: bu_enShow.disabled = bu_xxShow.disabled = False
    bu_enLoop.disabled = bu_xxLoop.disabled = False

  def chapbutClick (b):
    globalize ()

    # select view areas
    areaSelect_en (bu_enView); areaSelect_xx (bu_xxView)

    # buttonstyles
    for but in bx_chpsel.children: but.button_style   = ''
    bu_allchp.button_style, b.button_style            = '', 'info'

    # show complete text
    if b.description == 'all >>>>':
      ta_enTran.value = timestampTabView (enTrans[vid])
      ta_xxTran.value = timestampTabView (xxTrans[vid])
    # or chapter filtered
    else:
      start, end    = getStartEndFromChapterButton (b)
      ta_enTran.value = timestampTabView ([t for t in enTrans[vid] if t['start'] >= start and t['start'] < end])
      ta_xxTran.value = timestampTabView ([t for t in xxTrans[vid] if t['start'] >= start and t['start'] < end])

  def fromDescriptionButtonClick (_):
    globalize ()
    tmp = timestampTabView(enTrans[vid]).split('\n')

    # del old chapter buttons
    for oldbut in bx_chpsel.children: del oldbut

    # build buttons
    chapters = videoInfos[vid]['chapters']
    bu_allchp.tooltip = '>>>>Description from YouTube>>>\n'+str(videoInfos[vid]['description'])
    bu_allchp.button_style = ''
    bx_chpsel.children = [Button (description  = f'{c:.67}...' if len (c) > 70 else c,
                                tooltip      = c,
                                layout       = Layout(width='auto', height='21px'))
                        for i,c in enumerate (chapters)]
    for button in bx_chpsel.children: button.on_click(chapbutClick)

    # reset
    resetTransArea ()

  def autoButtonClick (_):
    globalize ()
    # select green
    areaSelect_en (bu_enView); areaSelect_xx (bu_xxView)

    tmp = timestampTabView(enTrans[vid]).split('\n')

    # makeAutoChapters
    chapters = makeAutoChapters (int(hb_autchp.children[0].value),tmp,default_chartokfac)

    bu_allchp.tooltip = str(videoInfos[vid]['description'])
    # del old chapter buttons
    for oldbut in bx_chpsel.children: del oldbut
    # and make new
    bx_chpsel.children = [Button (description  = f'{c:.67}...' if len (c) > 70 else c,
                                  tooltip      = c,
                                  layout       = Layout(width='auto', height='21px'))
                          for i,c in enumerate (chapters)]
    for button in bx_chpsel.children: button.on_click(chapbutClick)

    # reset
    resetTransArea ()

  def cleanButtonClick (_):
    # parse blocksize - check > 40 and < 200
    val = hb_cleanb.children[0].value
    if not ',' in val:  bs = None
    else:               bs = int(val.split(',')[1]) if int(val.split(',')[1]) < 200 and int(val.split(',')[1]) > 40 else None
    if "select chapter or click 'all >>>>'" in ta_enTran.value: return

    # rebuild ts view (if button clicked twice or mor)
    if not '\t' in ta_enTran.value:
      if bu_allchp.button_style == 'info': chapbutClick (bu_allchp)
      else: chapbutClick ([b for b in bx_chpsel.children if b.button_style=='info'][0])

    # use taCleaner (<linelist>,<count timestamps>,<blocksize>)
    ta_enTran.value = taCleaner ([l for l in ta_enTran.value.split('\n') if l != ''], int(val.split(',')[0]), bs)
    ta_xxTran.value = taCleaner ([l for l in ta_xxTran.value.split('\n') if l != ''], int(val.split(',')[0]), bs)

  def aiShowButtonClick (_):
    globalize ()

    # select green
    areaSelect_en (bu_enView); areaSelect_xx (bu_xxView)

    if use_english_for_ai_auto_chapters: ccode = 'en'
    else: ccode = cc
    tmp = timestampTabView(enTrans[vid]).split('\n')

    # del old chapter buttons
    for oldbut in bx_chpsel.children: del oldbut

    # build ai chapter buttons
    chapters, lastTS = videoInfos[vid]['aichapters'][ccode] if ccode in videoInfos[vid]['aichapters'] else [], 0
    for child in bx_chpsel.children: del child
    bx_chpsel.children = [Button (description  = f'{c:.67}...' if len (c) > 70 else c,
                                  tooltip      = c,
                                  layout       = Layout(width='auto', height='21px'))
                        for i,c in enumerate (chapters)]
    for button in bx_chpsel.children: button.on_click(chapbutClick)

    # reset
    resetTransArea ()

  def aiBuildButtonClick (_):
    globalize ()

    # select green
    areaSelect_en (bu_enView); areaSelect_xx (bu_xxView)

    # use existing chapters from buttons or do makeAutoChapters first
    if len(bx_chpsel.children) > 0:  chapters = [b.description.split(' ')[0] for b in bx_chpsel.children]
    else:                            chapters = makeAutoChapters (int(hb_autchp.children[0].value),tmp,tfac)

    # use existing chapters from buttons or do makeAutoChapters first
    if len(bx_chpsel.children) > 0:  chapters = [b.description.split(' ')[0] for b in bx_chpsel.children]
    else:                            chapters = makeAutoChapters (int(hb_autchp.children[0].value),timestampTabView(enTrans[vid]).split('\n'),default_chartokfac)

    # del old buttons
    for oldbut in bx_chpsel.children: del oldbut
    # and make new
    bx_chpsel.children = [Button (description  = f'{c:.67}...' if len (c) > 70 else c,
                                  tooltip      = c,
                                  layout       = Layout(width='auto', height='21px'))
                        for i,c in enumerate (chapters)]

    # wait message and start loop over chapters
    ta_enTran.value, ta_xxTran.value = "... please wait - chapter building in progress >>>>'", '...'
    for b in bx_chpsel.children:
      start, end = getStartEndFromChapterButton (b)
      # get ai chapter title
      tmp = []
      if use_english_for_ai_auto_chapters:
        ccode = 'en'
        tmp   = taCleaner (timestampTabView ([t for t in enTrans[vid] if t['start'] >= start and t['start'] < end]).split('\n'),0)
        title = get_completion ( f"{prompts_yaml['_aichapters_']['en']}\n{tmp}", temperature=float(hb_enCtrl.children[2].value) )
      else:
        ccode = cc
        tmp   = taCleaner (timestampTabView ([t for t in xxTrans[vid] if t['start'] >= start and t['start'] < end]).split('\n'),0)
        title = get_completion (f"{prompts_yaml['_aichapters_'][cc]}\n{tmp}", temperature=float(hb_xxCtrl.children[2].value))

      # set new title as button description
      if len (title) > 0:
        if title[0] == '"' or title[0] == "'":   title = title[1:]
        if title[-1] == '"' or title[-1] == "'": title = title[:-1]
      b.description = b.description.split(' ')[0]+' '+title
    for button in bx_chpsel.children: button.on_click(chapbutClick)

    # reset
    resetTransArea ()

    # store in yaml
    videoInfos[vid]['aichapters'][ccode] = [button.description for button in bx_chpsel.children]
    yaml.dump (videoInfos[vid], open(f'{vid}_info.yml', 'w'))


  ####################################################################################################################################
  #################################### openai-stuff: buttons prompt editor ###########################################################
  ####################################################################################################################################
  def prompt_add (_):
    # make new empty prompt
    tx_protit.value, tx_protit.disabled = '', False
    bu_addprmt.disabled, hb_protxt.children[0].value, hb_protxt.children[1].value = True, '', ''

  def prompt_save (_):
    # save yaml / refresh widgets
    prompts_yaml[tx_protit.value] = { 'en':hb_protxt.children[0].value, cc: hb_protxt.children[1].value}
    rb_prompts.options  = tuple ([tx_protit.value,*rb_prompts.options]) if not tx_protit.value in rb_prompts.options else rb_prompts.options
    rb_prompts.disabled = bu_addprmt.disabled = False
    yaml.dump (prompts_yaml, open('prompts.yml', 'w'))
    refreshPrompts()

  def prompt_translate (_):
    # prompt text from textarea - using german as prompt text of cause the language names
    # delivered by the api are in german - idontknow if it works with google accounts in other languages.
    en_ta, xx_ta     = hb_protxt.children[0], hb_protxt.children[1]
    prompt_ex        = f'√úbersetze die Arbeitsanweisung nach dem Doppelpunkt von Englisch nach {countryCodes[cc]} und beachte die Arbeitsanweisung nicht auszuf√ºhren sonder nur zu √ºbersetzen und zwar exakt und wort f√ºr wort: '
    prompt_xe        = f'√úbersetze die Arbeitsanweisung nach dem Doppelpunkt von {countryCodes[cc]} nach Englisch und beachte die Arbeitsanweisung nicht auszuf√ºhren sonder nur zu √ºbersetzen und zwar exakt und wort f√ºr wort: '
    org_xx, org_en   = xx_ta.value, en_ta.value

    # translate
    if len (org_en) > 10: xx_ta.value  += f'\n>>>>> translate from en to {cc} >>>>>>\n'
    if len (org_xx) > 10: en_ta.value  += f'\n>>>>> translate from {cc} to en >>>>>>\n'
    if len (org_en) > 10: xx_ta.value  += get_completion (prompt_ex + org_en)
    if len (org_xx) > 10: en_ta.value  += get_completion (prompt_xe + org_xx)

  def prompt_del (_):
    if tx_protit.value[0] == '_' : return
    # remove prompt from rb-list / save yaml / trigger refresh prompt buttons
    if tx_protit.value in rb_prompts.options:
      if tx_protit.value in prompts_yaml:
        del prompts_yaml[tx_protit.value]
        yaml.dump (prompts_yaml, open('prompts.yml', 'w'))
      rb_prompts.options = tuple ([o for o in rb_prompts.options if o != tx_protit.value])
    else: promptSelect(None)
    rb_prompts.disabled = bu_addprmt.disabled = False
    refreshPrompts()

  def promptSelect (_):
    global cc
    # set prompt title in en/xx areas
    hb_protxt.children[0].value = prompts_yaml[rb_prompts.value]['en'] if 'en' in prompts_yaml[rb_prompts.value] else ''
    hb_protxt.children[1].value = prompts_yaml[rb_prompts.value][cc]   if cc   in prompts_yaml[rb_prompts.value] else ''
    tx_protit.value, tx_protit.disabled = rb_prompts.value, True


  ####################################################################################################################################
  ########################################## select video -> build yamls / build widgets #############################################
  ####################################################################################################################################
  videoInfos, enTrans, xxTrans, store_en, store_xx = {}, {}, {}, ['',''], ['','']
  def getTraTra (vid, cc):
    try:
      ret = YouTubeTranscriptApi.list_transcripts (vid).find_generated_transcript([cc, 'en']).translate(cc).fetch()
    except:
      ret = [{}]
      for transcript in YouTubeTranscriptApi.list_transcripts (vid):
        if transcript.is_translatable:
          ret = transcript.translate(cc).fetch()
    return ret
  def buildYamls (vid):
    if vid == '': return
    global store_en, store_xx
    # create info yaml if not exists
    if not os.path.exists (f'{vid}_info.yml'):
      if not vid in videoInfos:
        videoInfo = Video.getInfo(video_prefix+vid)
        description = videoInfo['description']

        # parse chapter list / infoYml
        chapters        = parseChaptersFromDescription (description)
        videoInfos[vid] = {'description':description, 'chapters':chapters, 'aichapters': {}}

      # write infoYml
      yaml.dump (videoInfos[vid], open(f'{vid}_info.yml', 'w'))
      print (f"\r\x1b[34mwrite {vid}_info.yml",end=' | ')

    # load infoYml
    else:
      if not vid in videoInfos:
        videoInfos[vid] = yaml.load(open(f"{vid}_info.yml", 'r'), Loader=yaml.FullLoader)
        print (f"\r\x1b[34mload {vid}_info.yml",end=' | ')
      else: print (f"\r\x1b[34mmemory {vid}_info.yml",end=' | ')

    # create en transcription if not exists
    if not os.path.exists (f"{vid}_en.yml"):
      # get transcriptions from youtube / write to yaml
      enTrans[vid] = YouTubeTranscriptApi.get_transcript (vid)
      yaml.dump (enTrans[vid], open(f'{vid}_en.yml', 'w'))
    # load en transcription
    else:
      if not vid in enTrans:
        enTrans[vid] = enYml = yaml.load(open(f"{vid}_en.yml", 'r'), Loader=yaml.FullLoader)
        print (f"\x1b[34mload {vid}_en",end=' | ')
      else: print (f"\x1b[34mmemory {vid}_en",end=' | ')

    # create xx transcription if not exists
    if not os.path.exists (f"{vid}_{cc}.yml"):
      # get transcriptions from youtube / transcriptions-dict / write to yaml
      xxTrans[vid] = getTraTra (vid,cc)
      yaml.dump (xxTrans[vid], open(f'{vid}_{cc}.yml', 'w'))
    # load xx transcription
    else:
      if not vid in xxTrans:
        xxTrans[vid] = xxYml = yaml.load(open(f"{vid}_{cc}.yml", 'r'), Loader=yaml.FullLoader)
        print (f"\x1b[34mload {vid}_{cc}.yml",end='')
      else: print (f"\x1b[34mmemory {vid}_{cc}.yml",end='')

    # loops
    try:
      loops_yaml, store_en  = yaml.load(open(f'{vid}_loops_en.yml', 'r'), Loader=yaml.FullLoader), store_en[:2]
      for ts in loops_yaml: store_en.append (loops_yaml[ts])
    except: pass
    try:
      loops_yaml, store_xx  = yaml.load(open(f'{vid}_loops_{cc}.yml', 'r'), Loader=yaml.FullLoader), store_xx[:2]
      for ts in loops_yaml: store_xx.append (loops_yaml[ts])
    except: pass


  def selectVideo (_):
    # if help or prompt editor do nothing
    if mainAccordion.selected_index == None or mainAccordion.selected_index >= len(mainAccordion.children) - 2: return

    # set widgets and actual infos
    globalize()
    if vid == '': return

    # log line / disable rb-selection during work
    print ('\r\x1b[35mplease wait a moment ...',end='')
    rb_vidsel.disabled = True

    # check if single v mode
    if 'no playlist' == plid: tx_singvid.value = vid

    # create or load yamls
    buildYamls (vid)

    # chapters / tooltip
    chapters = videoInfos[vid]['chapters']
    bu_allchp.tooltip = '>>>>Description from YouTube>>>\n'+str(videoInfos[vid]['description'])

    # only if the video changed inside a playlist box
    if vPositions[acIndex] != rbIndex:

      # reset
      resetTransArea ()

      # new chapter buttons
      for child in bx_chpsel.children: del child
      bx_chpsel.children = [Button (description  = f'{c:.67}...' if len (c) > 70 else c,
                                    tooltip      = c,
                                    layout       = Layout(width='auto', height='21px'))
                            for i,c in enumerate (chapters)]
      for button in bx_chpsel.children: button.on_click(chapbutClick)
      vPositions[acIndex] = rbIndex

      # build area buttons en / xx
      hb_enSele.children[0].children = [bu_enView, bu_enResu,*xareaSelectors('en')]
      hb_xxSele.children[0].children = [bu_xxView, bu_xxResu,*xareaSelectors(cc)]

      # draw / undraw selection border
      for bu in hb_enSele.children[0].children: bu.layout = Layout (width='auto', height='15px')
      hb_enSele.children[0].children[0].layout = Layout (width='auto', height='15px', border='2px solid')
      for bu in hb_xxSele.children[0].children: bu.layout = Layout (width='auto', height='15px')
      hb_xxSele.children[0].children[0].layout = Layout (width='auto', height='15px', border='2px solid')


    # one time geting country codes - note: the language names are in the language of your google account.
    if not '\nAvailable country codes:\n' in ta_helper.value:
      countryCodes = {}
      for transcript in YouTubeTranscriptApi.list_transcripts(vid):
        for l in transcript.translation_languages: countryCodes[l['language_code']] = l['language']
      ta_helper.value += "\nAvailable country codes:\n\n"+'\n'.join([', '.join([c for c in countryCodes][i:i+20]) for i in range (0,len([c for c in countryCodes]),20)])

    # re-enable rb's
    rb_vidsel.disabled = False


  def xareaSelectors (ccode):
    if ccode == 'en': areaSelect_cc = areaSelect_en
    else:             areaSelect_cc = areaSelect_xx
    # build area buttons en / xx
    buttons = []
    try:
      loops_yaml = yaml.load(open(f'{vid}_loops_{ccode}.yml', 'r'), Loader=yaml.FullLoader)
      buttons    = [Button (layout=Layout(width='auto', height='15px'),
                            style={'button_color':'hotpink'},
                            tooltip=f"{id} - {loops_yaml[id].split('prompt <')[1].split('> for ...')[0]}" )
                for id in loops_yaml]
      for b in buttons: b.on_click (areaSelect_cc)
    except: pass
    return buttons


  ####################################################################################################################################
  ############################################################ main ##################################################################
  ####################################################################################################################################
  # prompt editor widgets
  prompt_buttons            = [Button (description  = p,
                                      tooltip      = str(prompts_yaml[p]['en']) if 'en' in prompts_yaml[p] else '' + '\n' +
                                                      str(prompts_yaml[p][cc])   if cc   in prompts_yaml[p] else '',
                                      style        = {'button_color':'lightgreen'}) for p in prompts_yaml if p[0] != '_']
  rb_prompts, bu_addprmt    = RadioButtons(options=[p for p in prompts_yaml]), Button (description='add prompt',tooltip='add empty prompt')
  bu_delprmt, bu_savprmt    = Button (description='del prompt',tooltip='delete prompt'), Button (description='save',tooltip='save prompt')
  bu_transla                = Button (description='translate',tooltip='translate prompt if not empty')
  hb_probut, tx_protit      = HBox (children=[bu_addprmt,bu_delprmt,bu_savprmt,bu_transla]), Text (layout=Layout(width='auto'))
  hb_protxt                 = HBox (children=[Textarea(layout=Layout(width='50%',height='400px')),
                                              Textarea(layout=Layout(width='50%',height='400px'))])
  vb_proedi                 = VBox (children=[hb_probut,tx_protit,hb_protxt])
  gb_proedi                 = GridBox (children=[rb_prompts,vb_proedi],
                                      layout=Layout (grid_template_rows='auto',
                                                      grid_template_columns='150px auto',
                                                      grid_template_areas='"sidebar main"'))
  # events
  for b in prompt_buttons: b.on_click (promptButtonClick)
  bu_addprmt                .on_click (prompt_add)
  bu_savprmt                .on_click (prompt_save)
  bu_transla                .on_click (prompt_translate)
  bu_delprmt                .on_click (prompt_del)
  rb_prompts                .observe  (promptSelect,names=['value'])
  # show first
  promptSelect(None)

  # help tab
  ta_helper = Textarea(value=helptext.replace('\n*','\n\n*'),layout=Layout(width='auto',height='600px'))

  # build and config widgets
  mainLayout    = Layout    (grid_template_rows='auto', grid_template_columns='150px auto', grid_template_areas='"sidebar main"')
  mainAccordion = Accordion (children = [GridBox(layout=mainLayout) for all in courses] if len (courses) else [GridBox(layout=mainLayout)])
  mainAccordion.children = tuple([*mainAccordion.children,gb_proedi,ta_helper])
  mainAccordion.set_title(len(mainAccordion.children)-2,'prompt editor')
  mainAccordion.set_title(len(mainAccordion.children)-1,'help')

  # the pos of selected video inside a playlist box
  vPositions = len(courses)*[-1]

  # loop to build playlist related widgets structure - the object-names are used consistently
  # and will be set in globalize() to the current displayed widgets: accordion tab / selected video
  for i,title in enumerate(courses):

    # the widgets for a playlist
    mainAccordion.set_title(i,f'Playlist: {title}')
    pl        = playlists_yaml[courses[title]]
    gb_maingb = mainAccordion.children[i]
    wi_firstw = HTML          (f'<a href="{playlist_prefix}{courses[title]}" title="{playlist_prefix}{courses[title]}" target="_blank">youtube</a>')
    rb_vidsel = RadioButtons  (options=[v[12:] if len (v) > 12 else v for v in pl['videos']],layout=Layout(height='300px',overflow='scroll'))
    bu_allchp = Button        (description='all >>>>',tooltip='',layout=Layout(width='auto'))
    bu_frodes = Button        (description='from description',tooltip='Try parsing chapters out of video description.',
                              layout=Layout(width='auto'),style={'button_color':'powderblue'})
    bu_autchp = Button        (description='auto',tooltip='Division of the video into sections with max. tokens.',
                              layout=Layout(width='60%'),style={'button_color':'powderblue'})
    hb_autchp = HBox          (children=[Text (value='500',layout=Layout(width='40%')),bu_autchp])
    bu_fromai = Button        (description='from ai',tooltip='Show the ai generated chapters',
                              layout=Layout(width='50%'),style={'button_color':'powderblue'})
    bu_aichap = Button        (description='aichaps',tooltip='(Re)build the ai chapters - uses the token len from auto as chapter size.',
                              layout=Layout(width='50%'),style={'button_color':'hotpink'},disabled=not yes_i_have_this_chatgpt_openai_account)
    hb_aichbu = HBox          (children=[bu_fromai,bu_aichap])
    bu_cleanb = Button        (description='clean',tooltip='Comma seperated the number of generated timestamps and the max line lenght.',
                              layout=Layout(width='60%'))
    hb_cleanb = HBox          (children=[Text (value='3, 70',layout=Layout(width='40%')),bu_cleanb])
    #                                        0        1         2          3         4        5         6
    vb_vidsel = VBox          (children=[wi_firstw,rb_vidsel,bu_allchp,hb_cleanb,bu_frodes,hb_autchp,hb_aichbu,*prompt_buttons],layout=Layout(overflow="hidden"))
    bx_chpsel = Box           (layout=Layout(display='flex', flex_flow='wrap'))
    ta_enTran = Textarea      (layout=Layout(width='50%',height='400px'))
    ta_xxTran = Textarea      (layout=Layout(width='50%',height='400px'))
    hb_transc = HBox          (children=[ta_enTran,ta_xxTran])
    bu_enShow = Button        (description='show', style={'button_color':'lightgreen'}, layout=Layout(width='10%'),
                              tooltip='paste the prompt at the top of the textarea - do this before send')
    bu_enSend = Button        (description='send', style={'button_color':'orange'}, layout=Layout(width='10%'),
                              tooltip='send the hole textarea content to gpt and shows response - be careful it sends everything that stands there')
    bu_enLoop = Button        (description='loop', style={'button_color':'hotpink'}, layout=Layout(width='10%'),
                              tooltip='make auto chapters and loop over all to: clean it (0,60), send with selected prompt to gpt and show response in new loop area')
    bu_xxShow = Button        (description='show', style={'button_color':'lightgreen'}, layout=Layout(width='10%'),
                              tooltip=bu_enShow.tooltip)
    bu_xxSend = Button        (description='send', style={'button_color':'orange'}, layout=Layout(width='10%'),disabled=not yes_i_have_this_chatgpt_openai_account,
                              tooltip=bu_enSend.tooltip)
    bu_xxLoop = Button        (description='lopp', style={'button_color':'hotpink'}, layout=Layout(width='10%'),disabled=not yes_i_have_this_chatgpt_openai_account,
                              tooltip=bu_enLoop.tooltip)
    bu_enView = Button        (layout=Layout(width='auto', height='15px', border='2px solid'), style={'button_color':'lightgreen'},
                              tooltip='Area for the prompt: first select text than select prompt and show.')
    bu_enResu = Button        (layout=Layout(width='auto', height='15px'), style={'button_color':'orange'},
                              tooltip='Area with the result from gpt for the sended prompt.')
    bu_enLdel = Button        (layout=Layout(width='auto', height='15px'), style={'button_color':'Crimson'},
                              tooltip='delete selected loop out off the yaml')
    bu_xxView = Button        (layout=Layout(width='auto', height='15px', border='2px solid'), style={'button_color':'lightgreen'}, tooltip=bu_enView.tooltip)
    bu_xxResu = Button        (layout=Layout(width='auto', height='15px'), style={'button_color':'orange'},tooltip=bu_enResu.tooltip)
    bu_xxLdel = Button        (layout=Layout(width='auto', height='15px'), style={'button_color':'Crimson'},tooltip=bu_enLdel.tooltip)
    hb_enSele = HBox          (children=[Box(children=[bu_enView, bu_enResu],
                                            layout=Layout(display='flex', flex_flow='row', border='1px solid', width='95%')),
                                        Box(children=[bu_enLdel],
                                            layout=Layout(display='flex', flex_flow='row', border='1px solid', width='5%')) ])
    hb_xxSele = HBox          (children=[Box(children=[bu_xxView, bu_xxResu],
                                            layout=Layout(display='flex', flex_flow='row', border='1px solid', width='95%')),
                                        Box(children=[bu_xxLdel],
                                            layout=Layout(display='flex', flex_flow='row', border='1px solid', width='5%')) ])
    hb_enCtrl = HBox          (children=[HTML(value='',layout=Layout(width='10%')),
                                        Label(value='<<<select prompt>>>',layout=Layout(width='40%')),
                                        Text(description='¬∞',value='0.1',layout=Layout(width='20%'),tooltip='temperature for api call'),
                                        bu_enShow, bu_enSend, bu_enLoop], layout=Layout(border='1px solid black',width='auto'))
    hb_xxCtrl = HBox          (children=[HTML(value='',layout=Layout(width='10%')),
                                        Label(value='<<<select prompt>>>',layout=Layout(width='40%')),
                                        Text(description='¬∞',value='0.1',layout=Layout(width='20%')),
                                        bu_xxShow, bu_xxSend, bu_xxLoop], layout=Layout(border='1px solid black',width='auto'))
    vb_enCtrl = VBox          (children=[hb_enCtrl,hb_enSele],layout=Layout(width='50%'))
    vb_xxCtrl = VBox          (children=[hb_xxCtrl,hb_xxSele],layout=Layout(width='50%'))
    hb_contrl = HBox          (children=[vb_enCtrl,vb_xxCtrl])
    vb_chpare = VBox          (children=[bx_chpsel,hb_contrl,hb_transc])
    gb_maingb                 .children = [vb_vidsel,vb_chpare]

    # events
    rb_vidsel                 .observe  (selectVideo, names=['value'])
    mainAccordion             .observe  (selectVideo, names=['selected_index'])
    bu_allchp                 .on_click (chapbutClick)
    bu_enShow                 .on_click (enShowButtonClick)
    bu_xxShow                 .on_click (xxShowButtonClick)
    bu_enSend                 .on_click (enSendButtonClick)
    bu_xxSend                 .on_click (xxSendButtonClick)
    bu_enLoop                 .on_click (enLoopButtonClick)
    bu_xxLoop                 .on_click (xxLoopButtonClick)
    bu_autchp                 .on_click (autoButtonClick)
    bu_frodes                 .on_click (fromDescriptionButtonClick)
    bu_cleanb                 .on_click (cleanButtonClick)
    bu_fromai                 .on_click (aiShowButtonClick)
    bu_aichap                 .on_click (aiBuildButtonClick)
    ta_enTran                 .observe  (text_change, names=['value'])
    ta_xxTran                 .observe  (text_change, names=['value'])
    bu_enView                 .on_click (areaSelect_en)
    bu_enResu                 .on_click (areaSelect_en)
    bu_xxView                 .on_click (areaSelect_xx)
    bu_xxResu                 .on_click (areaSelect_xx)
    bu_enLdel                 .on_click (loopDelete_en)
    bu_xxLdel                 .on_click (loopDelete_xx)

  # add / del / id input for single videos - no need for globalize
  if 'no playlist' in playlists_yaml:
    tx_singvid, bu_singvid = Text (layout=Layout(width='100px')), Button (description='+',tooltip='delete known, add unknown')

    # kick wi_firstw HTML - replace with HBox
    vb_vidsel.children = [HBox (children=[tx_singvid, bu_singvid],layout=Layout(width='auto')), *vb_vidsel.children[1:]]

    # events
    def tx_singvid_change (_):
      bu_singvid.disabled    = len (tx_singvid.value) != 11
      bu_singvid.description = '-' if tx_singvid.value+' ' in playlists_yaml['no playlist']['videos'] else '+'

    def bu_singvid_click (b):
      vl = playlists_yaml['no playlist']['videos']
      if b.description == '+': vl.append (tx_singvid.value+' ')
      if b.description == '-':
        for filtered in [name for name in os.listdir() if tx_singvid.value in name]: os.remove (filtered)
        vl.remove (tx_singvid.value+' ')
      rb_vidsel.options=[v for v in vl]
      playlists_yaml['no playlist']['videos'] = vl
      yaml.dump (playlists_yaml, open('playlists.yml', 'w'))
      selectVideo(None)
      fromDescriptionButtonClick (bu_frodes)

    tx_singvid.observe (tx_singvid_change, names=['value'])
    bu_singvid.on_click (bu_singvid_click)

  # display / globalize / unexpand accordion
  display       (mainAccordion)
  globalize     ()
  mainAccordion.selected_index = None
```

## Refactoring goals

The old version already contains one of the basic ideas of components, a
graphical representation of themselves within a development environment.
I achieve this here by using Colab forms, where form parameters serve as
high-level settings of the component and Markdown comments provide the
graphical representation.

This is one of the refactoring goals (component library). Let‚Äôs
summarize all goals in a list:

- **Application**<br>I want an application as result of the refactoring
  process with at least the same functionality but a new interface with
  a better ergonomie.

- **Componont library**<br>The idea behind it is to create functioning
  and stable components that the software should consist of. These are
  located in a library and can run independently of each other.

- **Unit testing**<br>The project is of course much too small to look at
  it with Scrum or XP eyes. But one artifact of agile software
  development can always (!) be recommended: Unit tests

- **Mediator Pattern**<br>The application serves as a mediator between
  the components. And that is exactly the design pattern that serves as
  the foundation of the application: the mediator pattern.

Make it so‚Ä¶

# ButtonBox

The ButtonBox is used by the app to select chapters in a lecture
transcription. We have the situation that the chapter headings are
sometimes long and sometimes short. I want to make optimal use of an
area to display selection options. The Flex Wrap layout is well suited
for this.

------------------------------------------------------------------------

<table>

<tr>

<td align="center">

<font size=20>üß≠</font><br><br><b>orientation
</td>

<td>

**The structure of the chapters** with the individual components is
always the same.

1.  The name of the component with a short description of what it does
    within the app.

2.  This is followed by a cell with the component. The Google Forms
    mechanism hides the source<br>code of the cell, shows a short
    description and enables top-level settings for the component.

3.  And finally there is a cell with the unit test. Here you can use
    form parameters to determine<br>the desired output behavior.

PS: Even if the parameter ‚Äòrun_test\_‚Ä¶‚Äô is deactivated, the test is
‚Äòregistered‚Äô as soon as you run the cell.<br>As soon as you start a test
run with ‚Äòunittest.main(‚Ä¶)‚Äô, every existing test is executed.
</td>

</tr>

</table>

``` python
#@markdown <font size='+2' color='#005F6A'>**ButtonBox**</font><br>
#@markdown * An alternative for the Tab widget for selecting **large amount of items**
#@markdown * Uses **Buttons** and a **Box** with **flex wrap layout**.
#@markdown * Provide a **mechanism for select, append and delete** an item .
#@markdown <table><tr><td><font size='+2'>
#@markdown
#@markdown ```python
#@markdown def showSelection (bbox):
#@markdown     try:    textarea.value = plain (render_doc(bbox.button.tooltip))
#@markdown     except: textarea.value = 'error calling render_doc with '+bbox.button.tooltip
#@markdown #
#@markdown textarea  = Textarea  (layout=Layout(width='1000px', height='300px'))
#@markdown buttonbox = ButtonBox (__builtins__.__dict__.keys(), clicker=showSelection)
#@markdown display (buttonbox.widget, textarea)
#@markdown ```
from ipywidgets import Button, Box, Layout, Textarea

class ButtonBox ():
  def __init__ (self, descriptions, clicker=None, maxchar=60, color='powderblue'):
    # remember stuff - list to set
    self.descriptions = descriptions if len (descriptions) == len (set (descriptions)) else set (descriptions)
    self.clicker, self.maxchar, self.color, self.position, self.button = clicker, maxchar, color, -1, None

    # make buttons
    self.buttons = [Button (description = i if len (i) <= maxchar else f'{i[:(maxchar-3)]}...',
                            layout      = Layout(width='auto', height='21px'),
                            tooltip     = f'{i}')
                    for i in descriptions]

    # put them in a box / bind event
    self.widget = Box (layout   = Layout (display='flex', flex_flow='wrap'),
                       children = self.buttons)
    for button in self.buttons: button.on_click (self._clicker)

  # An alternative for the Tab widget
  def _clicker (self, b):
    # search clicked button and remember
    self.position, self.button = [(i,but) for i, but in enumerate(self.buttons) if b == but][0]

    # unselect (color) all buttons and select new (list of colors here: https://www.quackit.com/css/css_color_codes.cfm)
    self.unselect()
    self.buttons[self.position].style={'button_color':self.color}

    # fire event
    if self.clicker: self.clicker (self)

  def append (self, description, select=True):
    # add new selctor button at the end
    b = Button (description = description if len (description) <= self.maxchar else f'{description[:(self.maxchar-3)]}...',
                layout      = Layout(width='auto', height='21px'),
                tooltip     = f'{description}')
    self.buttons.append(b)
    self.widget.children = [*self.widget.children, b]

    # select new button / bind event
    if select:
      self.button, self.position = b, len(self.buttons) - 1
      self._clicker (b)
    b.on_click (self._clicker)

  def remove (self, position=None):
    # remove selected if no position given
    if not position: position = self.position
    if not position or not position < len(self.buttons) or position < 0: return

    # clean up
    self.widget.children = [*self.widget.children[:position], *self.widget.children[position+1:]]
    self.buttons = [*self.buttons[:position], *self.buttons[position+1:]]
    self.button, self.position = None, -1

  def unselect (self):
    # unselect all buttons
    for b in self.buttons: b.style={'button_color':None}

# ___________________________________________________________
#|______________________hello_component______________________|

from ipywidgets   import Layout, Textarea, Button
from pydoc        import plain, render_doc

def showSelection (bbox):
  try:    textarea.value = plain (render_doc(bbox.button.tooltip))
  except: textarea.value = 'error calling render_doc with '+bbox.button.tooltip

textarea  = Textarea  (layout=Layout(width='1000px', height='300px'))
buttonbox = ButtonBox (__builtins__.__dict__.keys(), clicker=showSelection)
display   (buttonbox.widget, textarea)

(del_but := Button (description="delete")).on_click (lambda b: buttonbox.remove ())
(app_but := Button (description="append")).on_click (lambda b: buttonbox.append ('new button'))
display  (app_but, del_but)
```

    Box(children=(Button(description='__name__', layout=Layout(height='21px', width='auto'), style=ButtonStyle(), ‚Ä¶

    Textarea(value='', layout=Layout(height='300px', width='1000px'))

    Button(description='append', style=ButtonStyle())

    Button(description='delete', style=ButtonStyle())

``` python
import unittest
from IPython.display import clear_output
only_register_test_ButtonBox = True # @param {type:"boolean"}
register_and_run_test_ButtonBox = False # @param {type:"boolean"}

if only_register_test_ButtonBox or register_and_run_test_ButtonBox:
  class Test_ButtonBox (unittest.TestCase):
    def setUp (self):
      self.data       = ['aaaa_item_a', 'bbbb_item_b', 'cccc_item_c']
      self.maxchar    = 8
      self.buttonBox  = ButtonBox (self.data, maxchar=self.maxchar, color='powderblue')

    def sub_allUnselect (self):
      with self.subTest(msg='check if all buttons are unselected'):
        # test all buttons
        for b in self.buttonBox.buttons:
          self.assertEqual (b.style.button_color, None)

      with self.subTest(msg='check no button marked as selected'):
        self.assertEqual (self.buttonBox.button, None)
        self.assertEqual (self.buttonBox.position, -1)

    def sub_selectionCorrect (self, bnr):
      with self.subTest(msg=f'check if button {bnr} selected correct'):
        # test all buttons
        for i in range (3):
          # check if wrong not selected
          if i != bnr:
            self.assertNotEqual (self.buttonBox.button, self.buttonBox.buttons[i])
            self.assertEqual (self.buttonBox.buttons[i].style.button_color, None)
          # check if correct selected
          else:
            self.assertEqual (self.buttonBox.button, self.buttonBox.buttons[i])
            self.assertEqual (self.buttonBox.buttons[i].style.button_color, 'powderblue')

    def test_ButtonBox_selection (self):
      # test init state
      self.sub_allUnselect ()

      # click every button
      for bnr in range (3):
        self.buttonBox._clicker (self.buttonBox.buttons[bnr])
        self.sub_selectionCorrect (bnr)

    def test_ButtonBox_maxchar_and_tooltip (self):
      self.assertEqual (self.buttonBox.buttons[0].description, 'aaaa_...')
      self.assertEqual (self.buttonBox.buttons[1].description, 'bbbb_...')
      self.assertEqual (self.buttonBox.buttons[2].description, 'cccc_...')
      self.assertEqual (self.buttonBox.buttons[0].tooltip, 'aaaa_item_a')
      self.assertEqual (self.buttonBox.buttons[1].tooltip, 'bbbb_item_b')
      self.assertEqual (self.buttonBox.buttons[2].tooltip, 'cccc_item_c')

    def test_ButtonBox_remove (self):
      self.buttonBox.remove (1)
      self.assertEqual (len(self.buttonBox.buttons),2)
      self.assertEqual (self.buttonBox.position, -1)
      self.assertEqual (self.buttonBox.button, None)

    def test_ButtonBox_append_with_select (self):
      self.buttonBox.append ('0123456789_test', select=True)
      self.assertEqual (len(self.buttonBox.buttons[-1].description),self.maxchar)
      self.assertEqual (len(self.buttonBox.buttons),4)
      self.sub_selectionCorrect (3)

    def test_ButtonBox_append_without_select (self):
      self.buttonBox.append ('0123456789_test', select=False)
      self.assertEqual (len(self.buttonBox.buttons[-1].description),self.maxchar)
      self.assertEqual (len(self.buttonBox.buttons),4)
      self.sub_allUnselect ()

if register_and_run_test_ButtonBox:
  result = unittest.main(argv=[""], verbosity=2, exit=False).result
  if result.wasSuccessful() and show_only_fails: clear_output()
```

# Selectable

------------------------------------------------------------------------

``` python
""" Colab Code-Snippets
It uses colab forms to make a top-level setting of the code snippet (optional) and give
a little description. You can run the cell to execute the code snippet.
"""
#@markdown <font size='+2' color='#005F6A'>**Selectable**</font><br>
#@markdown * Provides a mechanism for selecting items with either **radio** or **multi-select** behavior.
#@markdown * Uses **Buttons** to represent selectable items.
#@markdown * Allows for custom behavior on first selection and subsequent selections.
#@markdown <table><tr><td><font size='+2'>
#@markdown
#@markdown ```python
#@markdown class MySelectable (Selectable):
#@markdown   def setInitState (self):            self.setItemWidget (Label (value="initial state"))
#@markdown   def onItemSelect (self, posList):   print ('Your selection:',posList)
#@markdown   def __init__(self, item, items, behave='radio'):
#@markdown     super().__init__(item, items, behave=behave, selector=self.onItemSelect)
#@markdown #
#@markdown lst = []
#@markdown display (HBox (children = [MySelectable('a', lst, behave='multi').widget,
#@markdown                            MySelectable('b', lst, behave='multi').widget]) )
#@markdown ```
#@markdown </td></tr></table>
from ipywidgets import Button, HTML, HBox, VBox, Label

class Selectable:
  """A class representing a selectable item with customizable behavior.
  This code snippet demonstrates the use of a custom selectable widget class
  in a Jupyter notebook. It allows for the selection of items using either
  radio button behavior or multi-select behavior.

  Attributes
  ----------
  * item: obj
    The item can be a object or a string or something else
  * items: list
    A list with Selectable objects.
  * behave: str
    The behavior type ('multi' or 'radio' or 'radiox') for selection.
  * onSelect: function | default: None
    A callback function triggered upon selection.
  * widget: HBox
    The widget representing the selectable item.

  Methods
  -------
  * doBehavior() | -> none
    Executes the selection behavior based on the specified type.
  * _onSelectorClick(b: Button) | -> none
    Handles the click event for the selector button.
  * setItemWidget(widget) | -> none
    Sets the widget to display for the item.
  * setInitState() | -> none
    Initializes the state of the item (to be implemented in subclasses).
  * onFirstSelect(posList) | -> none
    Defines behavior on the first selection (to be implemented in subclasses).

  Behavior
  -------
  * You can set the behavior to 'radio' or 'multi' (radio button or multi selection).
  * On creation it calls the setInitState abstract function where you can build your
    own widget (e.g. HTML-object) and register it with setItemWidget.
  * When you select an item the abstract function onFirstSelect is called so you can
    set your widget in a 'working' state.
  * Every selection triggers the callback function onSelect if set.

  Use cases
  ---------
  * Make your own class, inherit from Selectable and implement the onFirstSelect
    and setInitState function.
  * To react on a select you can give a listener in the super constructor call.
  * To combine several selectable objects to a set you have to give the same list
    on construction.
  * Display an item with the .widget attribute.

  Example
  -------
  class MySelectable (Selectable):
    def setInitState (self):            self.setItemWidget (Label (value="initial state"))
    def onFirstSelect (self, posList):  self.itemWidget.value = "initialized "+self.item
    def onSelection (self, posList):    print ('Your selection:',posList)
    def __init__(self, item, items, behave='radio'):
      super().__init__(item, items, behave, self.onSelection)

  # example: two sets of Selectable objects (two lines radio button / one line multi select)
  a, b = [] , []
  #
  display (HBox (children = [MySelectable('a', a).widget, MySelectable('b', a).widget, MySelectable('c', a).widget] ))
  display (HBox (children = [MySelectable('d', a).widget, MySelectable('e', a).widget, MySelectable('f', a).widget] ))
  display (HTML(value='<hr>'))
  #
  display (HBox (children = [MySelectable('a', b, 'multi').widget, MySelectable('b', b, 'multi').widget,
                             MySelectable('c', b, 'multi').widget, MySelectable('d', b, 'multi').widget,
                             MySelectable('e', b, 'multi').widget, MySelectable('f', b, 'multi').widget] ))

  """
  def __init__(self, item, items, behave, selector=None):
    """Initializes the class with given parameters.
    set attributes, generate widgets, bind events and set initial state.
    """
    self.isSelected, self.item, self.items, self.behave = False, item, items, behave
    self.bu_selector = Button(style={'button_color': '#99bfc3'}, layout={'width': '22px', 'height': '22px'})
    self.widget = HBox(children=[self.bu_selector], layout={'min_height': '24px', 'overflow': 'hidden'})
    self.items.append(self)
    self.bu_selector.on_click(self.select)
    self.setInitState()
    self.selector = selector


  def doBehavior (self):
    """Executes the selection behavior based on the specified type.
    """
    self.posList = []

    if self.behave == 'radiox':
      state         = self.items[self.lastSelect].isSelected
      for item in self.items: item.bu_selector.style.button_color, item.isSelected = '#99bfc3', False
      if state:     self.items[self.lastSelect].bu_selector.style.button_color, self.items[self.lastSelect].isSelected = '#99bfc3', False
      else:         self.items[self.lastSelect].bu_selector.style.button_color, self.items[self.lastSelect].isSelected = '#005F6A', True
      self.posList  = [p for p in range (len(self.items)) if self.items[p].isSelected]

    elif self.behave == 'radio':
      for item in self.items: item.bu_selector.style.button_color, item.isSelected = '#99bfc3', False
      self.bu_selector.style.button_color, self.isSelected, self.posList = '#005F6A', True, [self.lastSelect]

    elif self.behave == 'multi':
      state         = self.items[self.lastSelect].isSelected
      if state:     self.items[self.lastSelect].bu_selector.style.button_color, self.items[self.lastSelect].isSelected = '#99bfc3', False
      else:         self.items[self.lastSelect].bu_selector.style.button_color, self.items[self.lastSelect].isSelected = '#005F6A', True
      self.posList  = [p for p in range (len(self.items)) if self.items[p].isSelected]

    else: raise Exception('unknown behavior: '+self.behave)

  def setItemWidget (self, widget):
    """Sets the widget to display for the item.
    """
    self.itemWidget, self.widget.children = widget, (*self.widget.children, widget)

  def setInitState (self): raise NotImplementedError
  def onSelection (self, posList): raise NotImplementedError

  def select (self, b=None):
    """Handles the click event for the selector button.
    """
    for buttonPos in range (len(self.items)):
      if self.items[buttonPos].bu_selector == self.bu_selector: break
    if buttonPos < len(self.items):   self.lastSelect = buttonPos
    else:                             self.lastSelect = -1
    self.doBehavior ()
    if self.selector: self.selector (self.posList)


# ___________________________________________________________
#|______________________hello_component______________________|
class MySelectable (Selectable):
  def setInitState (self):            self.setItemWidget (Label (value="initial state"))
  def onItemSelect (self, posList):   print ('\rYour selection:',posList, end='')
  def __init__(self, item, items, behave='radio'):
    super().__init__(item, items, behave, self.onItemSelect)

# example: two sets of Selectable objects (two lines radio button / one line multi select)
a, b, c = [] , [], []
#
display (HTML(value='<font size=+1>behave: radio'))
display (HBox (children = [MySelectable('a', a).widget, MySelectable('b', a).widget, MySelectable('c', a).widget] ))
display (HBox (children = [MySelectable('d', a).widget, MySelectable('e', a).widget, MySelectable('f', a).widget] ))
#
display (HTML(value='<hr><font size=+1>behave: multi'))
display (HBox (children = [MySelectable('a', b, 'multi').widget, MySelectable('b', b, 'multi').widget,
                           MySelectable('c', b, 'multi').widget, MySelectable('d', b, 'multi').widget,
                           MySelectable('e', b, 'multi').widget, MySelectable('f', b, 'multi').widget] ))

#
display (HTML(value='<hr><font size=+1>behave: radiox'))
display (HBox (children = [MySelectable('a', c, 'radiox').widget, MySelectable('b', c, 'radiox').widget,
                           MySelectable('c', c, 'radiox').widget, MySelectable('d', c, 'radiox').widget,
                           MySelectable('e', c, 'radiox').widget, MySelectable('f', c, 'radiox').widget] ))
```

    HTML(value='<font size=+1>behave: radio')

    HBox(children=(HBox(children=(Button(layout=Layout(height='22px', width='22px'), style=ButtonStyle(button_colo‚Ä¶

    HBox(children=(HBox(children=(Button(layout=Layout(height='22px', width='22px'), style=ButtonStyle(button_colo‚Ä¶

    HTML(value='<hr><font size=+1>behave: multi')

    HBox(children=(HBox(children=(Button(layout=Layout(height='22px', width='22px'), style=ButtonStyle(button_colo‚Ä¶

    HTML(value='<hr><font size=+1>behave: radiox')

    HBox(children=(HBox(children=(Button(layout=Layout(height='22px', width='22px'), style=ButtonStyle(button_colo‚Ä¶

``` python
import unittest
from IPython.display import clear_output
only_register_test_Selectable = True # @param {type:"boolean"}
register_and_run_test_Selectable = False # @param {type:"boolean"}

if only_register_test_Selectable or register_and_run_test_Selectable:
  class Test_Selectable (unittest.TestCase):
    def setUp (self):
      # class for test inherits from Selectable
      class MySelectable (Selectable):
        def setInitState (self):            self.setItemWidget (Label (value="initial state"))
        def onItemSelect (self, posList):   pass
        def __init__(self, item, items, behave='radio'): super().__init__(item, items, behave, self.onItemSelect)

      # example sets a, b, c for radio, multi, radiox
      self.a, self.b, self.c, myPositions = [], [] , [], lambda l: [i for i, s in enumerate(l) if s.isSelected]

      MySelectable('a1', self.a,  'radio'), MySelectable('a2', self.a,  'radio'), MySelectable('a3', self.a,  'radio')
      MySelectable('b1', self.b,  'multi'), MySelectable('b2', self.b,  'multi'), MySelectable('b3', self.b,  'multi')
      MySelectable('c1', self.c, 'radiox'), MySelectable('c2', self.c, 'radiox'), MySelectable('c3', self.c, 'radiox')

    def selectedPositions (items): return [pos for pos, i in enumerate(items) if i.isSelected]

    def test_Selectable_generation (self):
      # test generation
      self.assertEqual (len(self.a), 3)
      self.assertEqual (len(self.b), 3)
      self.assertEqual (len(self.c), 3)
      self.assertEqual ([i.itemWidget.value for i in self.a], ['initial state', 'initial state', 'initial state'])
      self.assertEqual ([i.itemWidget.value for i in self.b], ['initial state', 'initial state', 'initial state'])
      self.assertEqual ([i.itemWidget.value for i in self.c], ['initial state', 'initial state', 'initial state'])

    def test_Selectable_behave_radio (self):
      # simulate button clicks and test effects
      self.a[0].select(self.a[0].widget) # click once
      self.assertEqual ([0], Test_Selectable.selectedPositions (self.a))
      self.assertEqual ([self.a[0].isSelected, self.a[1].isSelected, self.a[2].isSelected], [True,False,False])
      self.a[0].select(self.a[0].widget) # click two times
      self.assertEqual ([0], Test_Selectable.selectedPositions (self.a))
      self.assertEqual ([self.a[0].isSelected, self.a[1].isSelected, self.a[2].isSelected], [True,False,False])
      self.a[1].select(self.a[1].widget) # click once
      self.assertEqual ([1], Test_Selectable.selectedPositions (self.a))
      self.assertEqual ([self.a[0].isSelected, self.a[1].isSelected, self.a[2].isSelected], [False,True,False])
      self.a[1].select(self.a[1].widget) # click two times
      self.assertEqual ([1], Test_Selectable.selectedPositions (self.a))
      self.assertEqual ([self.a[0].isSelected, self.a[1].isSelected, self.a[2].isSelected], [False,True,False])
      self.a[2].select(self.a[2].widget) # click once
      self.assertEqual ([2], Test_Selectable.selectedPositions (self.a))
      self.assertEqual ([self.a[0].isSelected, self.a[1].isSelected, self.a[2].isSelected], [False,False,True])
      self.a[2].select(self.a[2].widget) # click two times
      self.assertEqual ([2], Test_Selectable.selectedPositions (self.a))
      self.assertEqual ([self.a[0].isSelected, self.a[1].isSelected, self.a[2].isSelected], [False,False,True])

    def test_Selectable_behave_multi (self):
      # simulate button clicks and test effects
      self.b[0].select(b[0].widget)
      self.assertEqual ([0],Test_Selectable.selectedPositions(self.b))
      self.assertEqual ([self.b[0].isSelected,self.b[1].isSelected,self.b[2].isSelected], [True,False,False])
      self.b[1].select(self.b[1].widget)
      self.assertEqual ([0,1],Test_Selectable.selectedPositions(self.b))
      self.assertEqual ([self.b[0].isSelected,self.b[1].isSelected,self.b[2].isSelected], [True,True,False])
      self.b[2].select(self.b[2].widget)
      self.assertEqual ([0,1,2],Test_Selectable.selectedPositions(self.b))
      self.assertEqual ([self.b[0].isSelected,self.b[1].isSelected,self.b[2].isSelected], [True,True,True])
      self.b[1].select(self.b[1].widget)
      self.assertEqual ([0,2],Test_Selectable.selectedPositions(self.b))
      self.assertEqual ([self.b[0].isSelected,self.b[1].isSelected,self.b[2].isSelected], [True,False,True])
      self.b[2].select(self.b[2].widget)
      self.assertEqual ([0],Test_Selectable.selectedPositions(self.b))
      self.assertEqual ([self.b[0].isSelected,self.b[1].isSelected,self.b[2].isSelected], [True,False,False])

    def test_Selectable_behave_radiox (self):
      # simulate button clicks and test effects
      self.c[0].select(self.c[0].widget) # click once
      self.assertEqual ([0], Test_Selectable.selectedPositions (self.c))
      self.assertEqual ([self.c[0].isSelected, self.c[1].isSelected, self.c[2].isSelected], [True,False,False])
      self.c[0].select(self.c[0].widget) # click two times
      self.assertEqual ([], Test_Selectable.selectedPositions (self.c))
      self.assertEqual ([self.c[0].isSelected, self.c[1].isSelected, self.c[2].isSelected], [False,False,False])
      self.c[1].select(self.c[1].widget) # click once
      self.assertEqual ([1], Test_Selectable.selectedPositions (self.c))
      self.assertEqual ([self.c[0].isSelected, self.c[1].isSelected, self.c[2].isSelected], [False,True,False])
      self.c[1].select(self.c[1].widget) # click two times
      self.assertEqual ([], Test_Selectable.selectedPositions (self.c))
      self.assertEqual ([self.c[0].isSelected, self.c[1].isSelected, self.c[2].isSelected], [False,False,False])
      self.c[2].select(self.c[2].widget) # click once
      self.assertEqual ([2], Test_Selectable.selectedPositions (self.c))
      self.assertEqual ([self.c[0].isSelected, self.c[1].isSelected, self.c[2].isSelected], [False,False,True])
      self.c[2].select(self.c[2].widget) # click two times
      self.assertEqual ([], Test_Selectable.selectedPositions (self.c))
      self.assertEqual ([self.c[0].isSelected, self.c[1].isSelected, self.c[2].isSelected], [False,False,False])

if register_and_run_test_Selectable:
  result = unittest.main(argv=[""], verbosity=2, exit=False).result
  if result.wasSuccessful() and show_only_fails: clear_output()
```

# Yamler

``` python
#@markdown <font size='+2' color='#005F6A'>**Yamler**</font><br>This class (optional) **scans** a **folder** and its **subfolders** for special **YAML**'s named by **ID** and provides an **organization** and **serialization**<br>mechanism for the files. The following **concept** are implemented:<table><tr></tr><tr><td><table><tr></tr><tr><td><b>id</td><td>a unique id-sting with a given length</td></tr><tr><td><b>item</td><td>a yaml file &lt;id>.yml</td></tr><tr><td><b>tag</td><td>a yaml file &lt;id>\_&lt;tag>.yml</td></tr><tr><td><b>config</td><td>a yaml file __&lt;config>.yml (starts with two underlines) </td></tr><tr><td><b>topic</td><td>a topic representing folder with &lt;id>, &lt;id>_&lt;tag> and __&lt;config> yml files</td></tr><tr><td><b>root</td><td>the base folder with all the topic folders and its own yml files</td></tr></table></td><td>Using
#@markdown
#@markdown ```python
#@markdown yamler = Yamler (folder='yamlerfolder',   # root folder
#@markdown                  onInit={'config':True})  # scan config yml's
#@markdown obj = yamler.store ('01234567890')        # create 01234567890.yml
#@markdown obj['_'] = {'msg': 'hello'}               # add value
#@markdown yamler.config['init']['some'] = 'is set'  # use '__init.yml' from folder
#@markdown yamler.dump ()                            # write changes to yamls
#@markdown ```
#@markdown </td></tr></table>
import os, yaml
from pathlib import Path
class Yamler:
  def __init__(self, root, id_len=11, onInit={'config':False, 'files':False, 'data':False}, mediator=None):
    """ set workingfolder, scan for yamls, load main yamls and build data object
    """
    # init attributes
    self.tags, self.id_len, self.topics, self.original, self.onInit, self.mediator = set(),  id_len, {}, {}, onInit, mediator
    # init current working topic - can be root ('_') or an other topic from self.topics
    self.data, self.folder, self.files, self.topic, self.config = None, None, None, '_', None

    # replace ~, create root folder if not exists
    folder = os.path.expanduser(root)
    if not os.path.exists (folder): os.makedirs (root)

    # create Yamler root dict with empty file list, folder and empty data / config objects
    self.topics['_'] = {'files':[], 'folder':root, 'data': {}, 'config': {}}

    # set root to working folder
    self.switch()

    # load yamls like in onInit
    self.initialize ()

    # use the subfolders as topics
    for item in os.listdir(f"{self.folder}/"):
      if os.path.isdir(os.path.join(f"{self.topics['_']['folder']}/", item)):

        # create empty topic
        self.topics[item] = {'files':[], 'data': {}, 'config': {}, 'folder': f"{self.topics['_']['folder']}/{item}"}

        # load yamls like in onInit
        self.initialize (topic=item)

    # set root to working folder back - it changed by initializing topics
    self.switch()

    # say ready
    if self.mediator: self.mediator.notify ("onYamlerReady", list(self.topics.keys()))


  def create (self, topic):
    folder = f"{self.topics['_']['folder']}/{topic}"
    if not os.path.exists (folder): os.makedirs (folder)
    # create empty topic
    self.topics[topic] = {'files':[], 'data': {}, 'config': {}, 'folder': f"{folder}"}


  def initialize (self, topic=None):
    if topic: self.switch (topic)

    # build file list
    if self.onInit['files']: self.scan ('files')

    # config data ('__')
    if self.onInit['config']: self.scan ('config')

    # load all yamls for id
    if self.onInit['data']: self.scan ('data')


  def switch (self, topic=None):
    if not topic: topic = '_'

    # set topic to current
    self.topic, self.data,                  self.config,                  self.folder,                  self.files =\
    topic,      self.topics[topic]['data'], self.topics[topic]['config'], self.topics[topic]['folder'], self.topics[topic]['files']


  def scan (self, part='all'):
    somethingIn = False
    if part == 'files' or part == 'data' or part == 'all':
      for f in os.listdir(f"{self.folder}"):
        if f.split('.')[-1] == 'yml' and not f in self.files:
          self.files.append(f)
      somethingIn = len (self.files) > 0

    if (part == 'config' or part == 'all') and not self.config:
      #from IPython.core.debugger import Pdb; Pdb().set_trace()
      files = self.files if self.files else [f for f in os.listdir(f"{self.folder}") if f.split('.')[-1] == 'yml']
      for f in files:
        if f[:2] == '__' and not f[2:-4] in self.config:
          somethingIn = True
          with open (f"{self.folder}/{f}", 'r') as stream:
            self.config[f[2:-4]] = yaml.safe_load(stream)
          self.original[f"{self.folder}/{f}"] = Yamler.dictcopy (self.config[f[2:-4]])

    if (part == 'data' or part == 'all') and not self.data:
      for id in self.ids():
        # only if not done before
        if id in self.data: continue # already loaded
        # main-yaml
        self.data[id] = {'_':{}} # empty data obj for id
        with open (f"{self.folder}/{id}.yml", 'r') as stream:
          self.data[id]['_'] = yaml.safe_load(stream)
        self.original[f"{self.folder}/{id}.yml"] = Yamler.dictcopy (self.data[id]['_'])
        somethingIn = True

        # tag-yamls
        taglist = [f[self.id_len+1:-4] for f in self.files if len(f) > self.id_len+5 and f[self.id_len] == '_']
        for tag in taglist:
          # remember found tags
          if tag not in self.tags: self.tags.add(tag)
          try: # load if exists
            with open (f"{self.folder}/{id}_{tag}.yml", 'r') as stream: self.data[id][tag] = yaml.safe_load(stream)
            self.original[f"{self.folder}/{id}_{tag}.yml"] = Yamler.dictcopy (self.data[id][tag])
          except: pass

    if somethingIn and self.mediator: self.mediator.notify ("onYamlerTopicScanned", self.topics[topic])


  def _dumpChanged (self,fname,obj):
    count = 0
    # only if new or changed
    if not fname in self.original or self.original[fname] != obj:
      # write it
      with open(fname, 'w') as file: yaml.dump(obj, file)
      count += 1
      # delete old original
      if fname in self.original: del self.original[fname]
      # make a copy to compare if changed by next dump
      self.original[fname] = Yamler.dictcopy (obj)
    return count


  def dump (self):
    count = 0
    # write __<config>.yml's
    for config_yml in self.config:
      fname, obj = f"{self.folder}/__{config_yml}.yml", self.config[config_yml]
      count += self._dumpChanged (fname, obj)

    #from IPython.core.debugger import Pdb; Pdb().set_trace()

    # write <id>.yml's
    for id in self.data:

      # main-yaml
      if not '_' in self.data[id]: continue
      fname, obj = f"{self.folder}/{id}.yml", self.data[id]['_']
      count += self._dumpChanged (fname, obj)

      # tag-yamls
      for tag in self.tags:
        if not tag in self.data[id]: continue
        fname, obj = f"{self.folder}/{id}_{tag}.yml", self.data[id][tag]
        count += self._dumpChanged (fname, obj)
    return count


  def ids(self):
    # get files
    files = self.files if self.files else [f for f in os.listdir(f"{self.folder}") if f.split('.')[-1] == 'yml']
    # parse ids - criterias: fname don't start with '__', correkt len and its a .yml-file
    return list(set([f[:-4] for f in files if f[:2] != '__' and len (f) == (self.id_len+4) and f[-4:] == '.yml']))


  def dictcopy (d):
    ret = {}
    if type(d) == dict: # data is dict
      ret = {}
      for k in d: # keys
        if type(d[k]) == dict: ret[k] = Yamler.dictcopy(d[k])
        if type(d[k]) == list: ret[k] = Yamler.dictcopy(d[k])
        else:                  ret[k] = d[k]
    elif type(d) == list: # data is list
      ret = []
      for i in d: # items
        if type(i) == dict: ret.append (Yamler.dictcopy(i))
        if type(i) == list: ret.append (Yamler.dictcopy(i))
        else:               ret.append (i)
    return ret



  def store (self, id, tag=None):
    """ create empty id-object(s) for serialize after check
        check fails if wrong id or id exists and no tag or tag exists already for id
    """
    # check plausibility of id and tag parameter
    if (not id or len (id) != self.id_len): return None
    if (id in self.data and not tag):       return self.data[id]

    # create dict for id-object in data[id]['_']
    if not id in self.data: self.data[id] = {'_':{}}

    # tag already in data
    if tag and tag in self.data[id]: return self.data[id]

    # create empty tag object for id and append tag to tags if not in
    if tag: self.data[id][tag] = ''
    if tag and tag not in self.tags: self.tags.add(tag)

    # return id-object
    return self.data[id]


  def remove (self, id, deleteFiles=True, isTag=False, isConfig=False, isTopic=False):
    if isTopic:
      if not id in self.topics or id == '_': return
      if self.topic == id: self.switch()
      tmp = []
      for fname in self.original:
        if fname[:len(id)+1] == id+'/': tmp.append (fname)
      for fname in tmp: del self.original[fname]
      del self.topics[id]
      if deleteFiles: os.system (f'rm -rf {self.folder}/{id}')

    elif isTag:
      if not '.' in id or len(id.split('.')[0]) != self.id_len: return
      id, tag = id.split('.')[0], id.split('.')[1]
      if not id in self.data: return
      if not tag in self.data[id]: return
      del self.data[id][tag]
      fname = f'{self.folder}/{id}_{tag}.yml'
      if deleteFiles and os.path.exists(fname): os.system (f'rm {fname}')
      if fname in self.original: del self.original [fname]

    elif isConfig:
      if not id in self.config: return
      del self.config[id]
      fname = f'{self.folder}/__{id}.yml'
      if deleteFiles and os.path.exists(fname): os.system (f'rm {fname}')
      if fname in self.original: del self.original [fname]

    else:
      if not id in self.data: return
      del self.data[id]
      if deleteFiles: os.system (f'rm {self.folder}/{id}*.yml')
      tmp = []
      for fname in self.original:
        if id in fname: tmp.append (fname)
      for fname in tmp: del self.original[fname]

    # rebuild tags
    self.tags = set([f.split('/')[-1].split('.')[0][self.id_len+1:] for f in self.original if f.split('/')[-1].split('.')[0][self.id_len+1:]])


# # ___________________________________________________________
# #|______________________hello_component______________________|

# make folder for yamler and yamler
!rm -rf test_yamler/; mkdir test_yamler

# new yamler in folder test_yamler and new id-object
yamler = Yamler ('test_yamler')
obj    = yamler.store ('01234567890')
obj['_'] = {'msg': 'hello'}

# access data and dump data
print (yamler.data['01234567890']['_'], obj == yamler.data['01234567890'])
yamler.dump ()

# check yaml files and remove all
!ls -lsa test_yamler/; cat test_yamler/01234567890.yml; rm -rf test_yamler
```

    {'msg': 'hello'} True
    total 12
    4 drwxrwxr-x  2 frank frank 4096 Dec 21 02:34 .
    4 drwxrwxr-x 21 frank frank 4096 Dec 21 02:34 ..
    4 -rw-rw-r--  1 frank frank   11 Dec 21 02:34 01234567890.yml
    msg: hello

``` python
import unittest
from IPython.display import clear_output
only_register_test_Yamler = True # @param {type:"boolean"}
register_and_run_test_Yamler = False # @param {type:"boolean"}

if only_register_test_Yamler or register_and_run_test_Yamler:
  class Test_Yamler (unittest.TestCase):
    def setUp (self):
      self.workFolder, self.yamler = 'test_yamler', None
      !rm -rf $self.workFolder/; mkdir $self.workFolder

    def tearDown (self):
      !rm -rf $self.workFolder/

    def sub_check_file_exist (self, fname, checkNotExist=False):
      if checkNotExist:
        with self.subTest(msg=f'check file {fname} not exists'): self.assertEqual (os.path.exists(fname), False)
      else:
        with self.subTest(msg=f'check file {fname} exists'):     self.assertEqual (os.path.exists(fname), True)


    def sub_check_serialize (self, fname, obj):
      # check file exists
      self.sub_check_file_exist (fname)

      # load yaml
      with open (fname, 'r') as stream: yml = yaml.safe_load(stream)

      # ceck is correct and is in self.original
      with self.subTest(msg=f'check file {fname} is correct'):      self.assertEqual (yml, obj)
      with self.subTest(msg=f'check file {fname} is in original'):  self.assertEqual (fname in self.yamler.original, True)


    def sub_check_item_lifecycle (self, yamler, id):
      with self.subTest(msg=f'check item {id} lifecycle'):
        y, wf, topic = yamler, self.workFolder, yamler.topic
        if topic != '_': wf = f'{wf}/{topic}'

        # create item / check init values
        obj = y.store ('01234567890')
        self.assertEqual ((obj, y.config, y.files, y.folder, y.topic, y.tags, y.original, y.data),
                        ({'_': {}}, {}, [], wf, topic, set(), {}, {'01234567890': {'_': {}}}))

        # dump empty item / check count, file
        count = y.dump ()
        self.assertEqual (count, 1)
        self.sub_check_serialize (f'{wf}/01234567890.yml', {})

        # create 3 tags
        obj = y.store ('01234567890','tag1')
        y.store ('01234567890','tag2')
        y.store ('01234567890','tag3')
        obj['tag2'] = 'hallo tag2'
        obj['tag3'] = {'msg':'hallo tag3'}
        count = y.dump ()
        self.assertEqual (count, 3)
        self.sub_check_serialize (f'{wf}/01234567890_tag1.yml', '')
        self.sub_check_serialize (f'{wf}/01234567890_tag2.yml', 'hallo tag2')
        self.sub_check_serialize (f'{wf}/01234567890_tag3.yml', {'msg':'hallo tag3'})

        # remove a tag
        y.remove ('01234567890.tag2',isTag=True)
        self.sub_check_file_exist (f'{wf}/01234567890_tag2.yml', checkNotExist=True)
        self.assertEqual (f'{wf}/01234567890_tag2.yml' in y.original, False)
        self.assertEqual ('tag2' in y.data['01234567890'], False)

        # remove an other tag
        y.remove ('01234567890.tag3',isTag=True)
        self.sub_check_file_exist (f'{wf}/01234567890_tag3.yml', checkNotExist=True)
        self.assertEqual ('tag3' in y.data['01234567890'], False)

        # remove item
        y.remove ('01234567890')
        self.sub_check_file_exist (f'{wf}/01234567890.yml', checkNotExist=True)
        self.sub_check_file_exist (f'{wf}/01234567890_tag1.yml', checkNotExist=True)
        self.sub_check_file_exist (f'{wf}/01234567890_tag2.yml', checkNotExist=True)
        self.sub_check_file_exist (f'{wf}/01234567890_tag3.yml', checkNotExist=True)
        self.assertEqual (f'{wf}/01234567890.yml' in y.original, False)
        self.assertEqual (f'{wf}/01234567890_tag1.yml' in y.original, False)
        self.assertEqual (f'{wf}/01234567890_tag2.yml' in y.original, False)
        self.assertEqual (f'{wf}/01234567890_tag3.yml' in y.original, False)
        self.assertEqual ('01234567890' in y.data, False)


    def sub_check_config_lifecycle (self, yamler, id):
      with self.subTest(msg=f'check config lifecycle in root and topic {id}'):
        y, wf, topic = yamler, self.workFolder, yamler.topic
        if topic != '_': wf = f'{wf}/{topic}'

        # change config, dump and check
        y.config['init'] = {'test': 'hallo config'}
        count = y.dump ()
        self.assertEqual (count, 1)
        self.sub_check_serialize (f'{wf}/__init.yml', y.config['init'])

        # delete config element / make new one / dump / check
        del y.config['init']['test']
        y.config['init'] = {'test2': 'hallo config'}
        count = y.dump ()
        self.assertEqual (count, 1)
        self.sub_check_serialize (f'{wf}/__init.yml', y.config['init'])

        # remove config
        y.remove ('init',isConfig=True)
        self.assertEqual ('init' in y.config, False)
        self.sub_check_file_exist (f'{wf}/__init.yml', checkNotExist=True)

    def prepare_scenario (scenario, wf):
      if scenario == 'two_ids_with_tag_and_two_configs_in_root':
        !echo "test1: 'hallo1'"               > $wf/__info1.yml
        !echo "test2: 'hallo2'"               > $wf/__info2.yml
        !echo "item1: 'halloitem1'"           > $wf/01234567890.yml
        !echo "itemtag1: 'halloitemtag1'"     > $wf/01234567890_tag1.yml
        !echo "item2: 'halloitem2'"           > $wf/11234567890.yml
        !echo "itemtag2: 'halloitemtag2'"     > $wf/11234567890_tag2.yml

      if scenario == 'two_ids_with_tag_and_two_configs_in_test_topic':
        !mkdir $wf/test_topic
        !echo "test3: 'hallo3'"               > $wf/test_topic/__info1.yml
        !echo "test4: 'hallo4'"               > $wf/test_topic/__info3.yml
        !echo "item3: 'halloitem3'"           > $wf/test_topic/21234567890.yml
        !echo "itemtag1: 'halloitemtag1'"     > $wf/test_topic/21234567890_tag1.yml
        !echo "item4: 'halloitem4'"           > $wf/test_topic/31234567890.yml
        !echo "itemtag3: 'halloitemtag3'"     > $wf/test_topic/31234567890_tag3.yml

      if scenario == 'two_configs_in_root_and_test_topic':
        !mkdir $wf/test_topic
        !echo "test1: 'hallo1'"               > $wf/__info1.yml
        !echo "test2: 'hallo2'"               > $wf/__info2.yml
        !echo "test3: 'hallo3'"               > $wf/test_topic/__info1.yml
        !echo "test4: 'hallo4'"               > $wf/test_topic/__info3.yml


    def test_Yamler_item_and_config_in_empty_root_no_scan (self):
      # create yamler
      self.yamler = y = Yamler (wf := self.workFolder, id_len=11, onInit={'config': False, 'files': False, 'data': False})

      # test in empty root
      self.sub_check_item_lifecycle (y, '01234567890')
      self.sub_check_config_lifecycle (y, 'test_config')

      # test in topic folder
      y.create ('test_topic')
      y.switch ('test_topic')
      self.sub_check_item_lifecycle (y, 't1234567890')
      self.sub_check_config_lifecycle (y, 'test_config')

    def test_Yamler_item_and_config_in_not_empty_root_no_scan (self):
      # prepare
      Test_Yamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_root', wf=self.workFolder)
      Test_Yamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_test_topic', wf=self.workFolder)

      # create yamler
      self.yamler = y = Yamler (wf := self.workFolder, id_len=11, onInit={'config': False, 'files': False, 'data': False})

      # test yamls ignored
      self.assertEqual (y.topics['_'], {'files': [], 'folder': 'test_yamler', 'data': {}, 'config': {}})
      self.assertEqual (y.topics['test_topic'], {'files': [], 'data': {}, 'config': {}, 'folder': 'test_yamler/test_topic'})

      # test in not empty root
      self.sub_check_item_lifecycle (y, '01234567890')
      self.sub_check_config_lifecycle (y, 'test_config')

      # test in topic folder
      y.switch ('test_topic')
      self.sub_check_item_lifecycle (y, 't1234567890')
      self.sub_check_config_lifecycle (y, 'test_config')


    def test_Yamler_scan_config (self):
      # prepare
      Test_Yamler.prepare_scenario (scenario='two_configs_in_root_and_test_topic', wf=self.workFolder)

      # create yamler with activated confg scan
      self.yamler = y = Yamler (wf := self.workFolder, id_len=11, onInit={'config': True, 'files': False, 'data': False})
      self.assertEqual (y.config, {'info1': {'test1': 'hallo1'}, 'info2': {'test2': 'hallo2'}})

      # change a value and dump
      y.config['info1']['test1'] = 'new hallo1'
      count = y.dump ()
      self.assertEqual (count, 1)
      self.sub_check_serialize (f'{wf}/__info1.yml', {'test1': 'new hallo1'})

      # remove a config
      y.remove ('info1',isConfig=True)
      self.assertEqual ('info1' in y.config, False)
      self.sub_check_file_exist (f'{wf}/__info1.yml', checkNotExist=True)

      # test standard lifecycle
      self.sub_check_config_lifecycle (y, '_')

      # # test in topic folder
      y.switch ('test_topic')
      wf += '/test_topic'
      self.assertEqual (y.config, {'info1': {'test3': 'hallo3'}, 'info3': {'test4': 'hallo4'}})

      # change a value and dump
      y.config['info1']['test3'] = 'new hallo3'
      count = y.dump ()
      self.assertEqual (count, 1)
      self.sub_check_serialize (f'{wf}/__info1.yml', {'test3': 'new hallo3'})

      # remove a config
      y.remove ('info1',isConfig=True)
      self.assertEqual ('info1' in y.config, False)
      self.sub_check_file_exist (f'{wf}/__info1.yml', checkNotExist=True)

      # test standard lifecycle
      self.sub_check_config_lifecycle (y, 'test_topic')

    def test_Yamler_scan_files (self):
      # prepare
      Test_Yamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_root', wf=self.workFolder)
      Test_Yamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_test_topic', wf=self.workFolder)

      # create yamler with activated confg scan
      self.yamler = y = Yamler (wf := self.workFolder, id_len=11, onInit={'config': False, 'files': True, 'data': False})
      self.assertEqual (sorted (y.files), sorted (['__info1.yml', '11234567890_tag2.yml', '01234567890.yml', '__info2.yml', '01234567890_tag1.yml', '11234567890.yml']))
      self.assertEqual ((y.data, y.config, y.original),({}, {}, {}))

      # switch and check files
      y.switch ('test_topic')
      self.assertEqual (sorted (y.files), sorted (['__info3.yml', '31234567890.yml', '__info1.yml', '21234567890_tag1.yml', '31234567890_tag3.yml', '21234567890.yml']))
      self.assertEqual ((y.data, y.config, y.original),({}, {}, {}))

    def test_Yamler_scan_data (self):
      Test_Yamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_root', wf=self.workFolder)
      Test_Yamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_test_topic', wf=self.workFolder)

      # create yamler with activated confg scan
      self.yamler = y = Yamler (wf := self.workFolder, id_len=11, onInit={'config': False, 'files': False, 'data': True})
      self.assertEqual (y.data['01234567890'], {'_': {'item1': 'halloitem1'}, 'tag1': {'itemtag1': 'halloitemtag1'}})
      self.assertEqual (y.data['11234567890'], {'_': {'item2': 'halloitem2'}, 'tag2': {'itemtag2': 'halloitemtag2'}})
      self.assertEqual (sorted (y.files), sorted (['__info1.yml', '11234567890_tag2.yml', '01234567890.yml', '__info2.yml', '01234567890_tag1.yml', '11234567890.yml']))
      self.assertEqual (y.config,{})

      y.switch ('test_topic')
      self.assertEqual (y.data['21234567890'], {'_': {'item3': 'halloitem3'}, 'tag1': {'itemtag1': 'halloitemtag1'}})
      self.assertEqual (y.data['31234567890'], {'_': {'item4': 'halloitem4'}, 'tag3': {'itemtag3': 'halloitemtag3'}})
      self.assertEqual (sorted (y.files), sorted (['__info3.yml', '31234567890.yml', '__info1.yml', '21234567890_tag1.yml', '31234567890_tag3.yml', '21234567890.yml']))
      self.assertEqual (y.config,{})


if register_and_run_test_Yamler:
  result = unittest.main(argv=[""], verbosity=2, exit=False).result
```

# CloudYamler

``` python
#@markdown <font size='+2' color='#005F6A'>**CloudYamler**</font><br>This class serialize a Yamler with the cloud.  You have two situations:<br>
#@markdown > * **hosted runtime** (google colab)<br>It uses the **colab gdrive** integration and works **directly** with the **data**. In this situation you are **forced to use gdrive**.
#@markdown > * **local runtime**<br>It uses **rclone** (any cloud service) to sync **from the cloud to the local** system **first**, then **syncs to the cloud** after **each change**.<br>It **creates in current** location a **folder** with the **name of the cloud folder**.

#from google.colab import drive
#drive.mount('/content/drive')
import sys, os, subprocess

class CloudYamler (Yamler):
  # statics: form-parameters and analyse situation (isLocal and hasRclone)
  cloud_service  = 'gdrive:'   #@param {type:"string"}
  cloud_folder   = 'cloud_yamler'   #@param {type:"string"}
  isLocal        = not ('google.colab' in sys.modules and os.path.expanduser('~') == '/root')
  hasRclone      = os.system ('rclone -V >/dev/null 2>&1') == 0

  def __init__(self, id_len=11, mediator=None, onInit={'config':False, 'files':False, 'data':False}, cloud_folder=None):
    # set new cloud folder if given
    self.cloud_folder = CloudYamler.cloud_folder if not cloud_folder else cloud_folder

    # becomes true when something has gone wrong
    failed = False

    # Situation: local runtime
    if CloudYamler.isLocal:

      # and rclone installed -> init
      if CloudYamler.hasRclone: failed = self.init_local_runtime ()

    # Situation: hosted runtime (google colab) -> init
    else: failed = self.init_hosted_runtime ()

    # if all ok
    if not failed:

      # init yamler
      if CloudYamler.isLocal:

        # local with cloud_folder as root
        folder = self.cloud_folder
      else:

        # hosted with '/gdrive/MyDrive/<cloud_folder> as root (cloud_service is allways gdrive)
        folder = f"/gdrive/MyDrive/{self.cloud_folder}"

      # super with correct root
      super().__init__ (root=folder, id_len=id_len, mediator=mediator, onInit=onInit)

    # if failed
    else:

      # in local
      if  CloudYamler.isLocal:

        # allert correct message
        if not CloudYamler.hasRclone: print ('\x1b[106m please install rclone ')
        else: print (f"\n\x1b[106m to reconnect rclone execute this command \x1b[0m\n\n    rclone config reconnect {CloudYamler.cloud_service}")

      # in hosted only one possible message
      else: print (f"\x1b[106m can't mount gdrive from colab \x1b[0m")

      # raise failed
      raise Exception ('CloudYamler init failed')


  def init_hosted_runtime (self):
    # mount gdrive
    failed = False
    try:
      from google.colab import drive
      if not 'gdrive' in os.listdir('/'): drive.mount ('/gdrive')
    except: failed = True
    return failed


  def init_local_runtime (self):
    # check service
    failed = False
    allowedRemotes = str(subprocess.check_output("rclone listremotes", shell=True))
    if CloudYamler.cloud_service not in allowedRemotes:
      failed = True
      print ('\x1b[106m please enter valid rclone service ')

    # service ok
    else:

      # check cloud_folder
      try:
        cloud_ls = str (subprocess.check_output(f"rclone lsd {CloudYamler.cloud_service}", shell=True))
      except:
        failed = True
        print ("\x1b[106m can't read cloud folder ")

      # cloud_folder ok
      else:

        # is in cloud: sync cloud->local
        if self.cloud_folder in cloud_ls:
          try:
            os.system(f"rclone sync {CloudYamler.cloud_service}/{self.cloud_folder} {self.cloud_folder}")
          except:
            print (f"\x1b[106m can't sync cloud folder {self.cloud_folder} ")
            failed = True
        else:

          # is not in cloud -> create
          try:
            os.system(f"rclone mkdir {CloudYamler.cloud_service}/{self.cloud_folder} >/dev/null 2>&1")
          except:
            failed = True
            print (f"\x1b[106m can't create cloud folder {self.cloud_folder} ")
    return failed

  def dump (self, force=False):
    #from IPython.core.debugger import Pdb; Pdb().set_trace()
    # make 'normal' dump
    count = super().dump ()

    # sync if needed
    if (CloudYamler.isLocal and count > 0) or force :
      try:
        os.system(f"rclone sync {self.cloud_folder} {CloudYamler.cloud_service}/{self.cloud_folder}")
      except:
        print (f"\x1b[106m can't sync local folder {self.cloud_folder} to cloud folder {CloudYamler.cloud_service}/{self.cloud_folder} ")
        raise Exception ('can not sync local folder to cloud folder')

    # return from super
    return count

  def remove (self, id, deleteFiles=True, isTag=False, isConfig=False, isTopic=False):
    super().remove (id, deleteFiles=deleteFiles, isTag=isTag, isConfig=isConfig, isTopic=isTopic)
    # forces dump to sync
    if deleteFiles: self.dump (force=True)

# ___________________________________________________________
#|______________________hello_component______________________|
execute_hello_world_example = True #@param {type:"boolean"}
if execute_hello_world_example:
  cloudYamler     = CloudYamler (cloud_folder='dummy_cloud_yamler')
  obj             = cloudYamler.store ('01234567890')
  obj['_']['msg'] = {'hello':'world'}
  cloudYamler     .dump ()

  # cat and remove dummy from cloud
  if CloudYamler.isLocal: # in local runtime
    !rclone cat $CloudYamler.cloud_service$cloudYamler.cloud_folder/01234567890.yml
    !rclone purge $CloudYamler.cloud_service$cloudYamler.cloud_folder >/dev/null 2>&1
    !rm -rf $cloudYamler.cloud_folder
  else: # or in hosted runtime
    !cat $cloudYamler.folder/01234567890.yml
    !rm -rf $cloudYamler.folder
```

    msg:
      hello: world

``` python
import unittest
from IPython.display import clear_output
only_register_test_CloudYamler = False # @param {type:"boolean"}
register_and_run_test_CloudYamler = True # @param {type:"boolean"}

if only_register_test_CloudYamler or register_and_run_test_CloudYamler:
  # folder for test
  CloudYamler.cloud_folder = 'test_CloudYamler'

  # test case
  class Test_CloudYamler (unittest.TestCase):
    tmp_cloud_folder = 'tmp_test_cloud_folder' # for overall consistence test
    def setUp (self):
      # CloudYamler for tests
      self.yamler = None

      # Situation: local runtime
      if CloudYamler.isLocal: self.workFolder = CloudYamler.cloud_folder

      # Situation: hosted runtime
      else: self.workFolder = f'/gdrive/MyDrive/{CloudYamler.cloud_folder}'

    def tearDown (self):
      # Situation: local runtime
      if CloudYamler.isLocal and CloudYamler.hasRclone:
        os.system (f'rclone purge {CloudYamler.cloud_service}{CloudYamler.cloud_folder} >/dev/null 2>&1')

      # both situations
      !rm -rf $self.workFolder
      !rm -rf $Test_CloudYamler.tmp_cloud_folder

    def sub_check_file_exist (self, fname, checkNotExist=False):
      if checkNotExist:
        with self.subTest(msg=f'check file {fname} not exists'): self.assertEqual (os.path.exists(fname), False)
      else:
        with self.subTest(msg=f'check file {fname} exists'):     self.assertEqual (os.path.exists(fname), True)


    def sub_check_serialize (self, fname, obj):
      # check file exists
      self.sub_check_file_exist (fname)

      # load yaml
      with open (fname, 'r') as stream: yml = yaml.safe_load(stream)

      # ceck is correct and is in self.original
      with self.subTest(msg=f'check file {fname} is correct'):      self.assertEqual (yml, obj)
      with self.subTest(msg=f'check file {fname} is in original'):  self.assertEqual (fname in self.yamler.original, True)

    def sub_check_cloud_consistence (self):
      if not CloudYamler.isLocal: return
      failed = False
      with self.subTest(msg='check consistence cloud / local'):
        try:    os.system(f"rclone sync {CloudYamler.cloud_service}/{CloudYamler.cloud_folder} {Test_CloudYamler.tmp_cloud_folder}")
        except:
          failed = True
          self.assertEqual (failed,False)
        else:
          # check both root folders
          ls_org = sorted (os.listdir(f"{CloudYamler.cloud_folder}"))
          ls_tst = sorted (os.listdir(f"{Test_CloudYamler.tmp_cloud_folder}"))
          self.assertEqual (ls_org, ls_tst)

          # check both contents
          for item in ls_tst:
            # check subfolders
            if os.path.isdir(os.path.join(f"{Test_CloudYamler.tmp_cloud_folder}/", item)):
              with self.subTest(msg='check consistence cloud / local - subfolder'):
                sub_ls_org = sorted (os.listdir(f"{CloudYamler.cloud_folder}/{item}"))
                sub_ls_tst = sorted (os.listdir(f"{Test_CloudYamler.tmp_cloud_folder}/{item}"))
                self.assertEqual (sub_ls_org, sub_ls_tst)
                for sub_item in sub_ls_tst:
                  with open (f"{Test_CloudYamler.tmp_cloud_folder}/{item}/{sub_item}", 'r') as stream: sub_yml_tst = yaml.safe_load(stream)
                  with open (f"{CloudYamler.cloud_folder}/{item}/{sub_item}", 'r') as stream: sub_yml_org = yaml.safe_load(stream)
                  self.assertEqual (sub_yml_tst, sub_yml_org)

            # check files
            else:
              with open (f"{Test_CloudYamler.tmp_cloud_folder}/{item}", 'r') as stream: yml_tst = yaml.safe_load(stream)
              with open (f"{CloudYamler.cloud_folder}/{item}", 'r') as stream: yml_org = yaml.safe_load(stream)
              self.assertEqual (yml_tst, yml_org)


    def sub_check_item_lifecycle (self, yamler, id):
      with self.subTest(msg=f'check item {id} lifecycle'):
        y, wf, topic = yamler, self.workFolder, yamler.topic
        if topic != '_': wf = f'{wf}/{topic}'

        # create item / check init values
        obj = y.store ('01234567890')
        self.assertEqual ((obj, y.config, y.files, y.folder, y.topic, y.tags, y.original, y.data),
                        ({'_': {}}, {}, [], wf, topic, set(), {}, {'01234567890': {'_': {}}}))

        # dump empty item / check count, file
        count = y.dump ()
        self.assertEqual (count, 1)
        self.sub_check_serialize (f'{wf}/01234567890.yml', {})

        # create 3 tags
        obj = y.store ('01234567890','tag1')
        y.store ('01234567890','tag2')
        y.store ('01234567890','tag3')
        obj['tag2'] = 'hallo tag2'
        obj['tag3'] = {'msg':'hallo tag3'}
        count = y.dump ()
        self.assertEqual (count, 3)
        self.sub_check_serialize (f'{wf}/01234567890_tag1.yml', '')
        self.sub_check_serialize (f'{wf}/01234567890_tag2.yml', 'hallo tag2')
        self.sub_check_serialize (f'{wf}/01234567890_tag3.yml', {'msg':'hallo tag3'})

        # check overall constistence
        self.sub_check_cloud_consistence ()

        # remove a tag
        y.remove ('01234567890.tag2',isTag=True)
        self.sub_check_file_exist (f'{wf}/01234567890_tag2.yml', checkNotExist=True)
        self.assertEqual (f'{wf}/01234567890_tag2.yml' in y.original, False)
        self.assertEqual ('tag2' in y.data['01234567890'], False)

        # remove an other tag
        y.remove ('01234567890.tag3',isTag=True)
        self.sub_check_file_exist (f'{wf}/01234567890_tag3.yml', checkNotExist=True)
        self.assertEqual ('tag3' in y.data['01234567890'], False)

        # check overall constistence
        self.sub_check_cloud_consistence ()

        # remove item
        y.remove ('01234567890')
        self.sub_check_file_exist (f'{wf}/01234567890.yml', checkNotExist=True)
        self.sub_check_file_exist (f'{wf}/01234567890_tag1.yml', checkNotExist=True)
        self.sub_check_file_exist (f'{wf}/01234567890_tag2.yml', checkNotExist=True)
        self.sub_check_file_exist (f'{wf}/01234567890_tag3.yml', checkNotExist=True)
        self.assertEqual (f'{wf}/01234567890.yml' in y.original, False)
        self.assertEqual (f'{wf}/01234567890_tag1.yml' in y.original, False)
        self.assertEqual (f'{wf}/01234567890_tag2.yml' in y.original, False)
        self.assertEqual (f'{wf}/01234567890_tag3.yml' in y.original, False)
        self.assertEqual ('01234567890' in y.data, False)

        # check overall constistence
        self.sub_check_cloud_consistence ()


    def sub_check_config_lifecycle (self, yamler, id):
      with self.subTest(msg=f'check config lifecycle in root and topic {id}'):
        y, wf, topic = yamler, self.workFolder, yamler.topic
        if topic != '_': wf = f'{wf}/{topic}'

        # change config, dump and check
        y.config['init'] = {'test': 'hallo config'}
        count = y.dump ()
        self.assertEqual (count, 1)
        self.sub_check_serialize (f'{wf}/__init.yml', y.config['init'])

        # check overall constistence
        self.sub_check_cloud_consistence ()

        # delete config element / make new one / dump / check
        del y.config['init']['test']
        y.config['init'] = {'test2': 'hallo config'}
        count = y.dump ()
        self.assertEqual (count, 1)
        self.sub_check_serialize (f'{wf}/__init.yml', y.config['init'])

        # remove config
        y.remove ('init',isConfig=True)
        self.assertEqual ('init' in y.config, False)
        self.sub_check_file_exist (f'{wf}/__init.yml', checkNotExist=True)

        # check overall constistence
        self.sub_check_cloud_consistence ()

    def prepare_scenario (scenario, wf=None):
      # create folders / working folder and service
      wf = CloudYamler.cloud_folder if not wf else wf
      if not os.path.exists (wf):
        !mkdir $wf

      if scenario == 'two_ids_with_tag_and_two_configs_in_root':
        !echo "test1: 'hallo1'"               > $wf/__info1.yml
        !echo "test2: 'hallo2'"               > $wf/__info2.yml
        !echo "item1: 'halloitem1'"           > $wf/01234567890.yml
        !echo "itemtag1: 'halloitemtag1'"     > $wf/01234567890_tag1.yml
        !echo "item2: 'halloitem2'"           > $wf/11234567890.yml
        !echo "itemtag2: 'halloitemtag2'"     > $wf/11234567890_tag2.yml

      if scenario == 'two_ids_with_tag_and_two_configs_in_test_topic':
        if not os.path.exists (f'{wf}/test_topic'):
          !mkdir $wf/test_topic
        !echo "test3: 'hallo3'"               > $wf/test_topic/__info1.yml
        !echo "test4: 'hallo4'"               > $wf/test_topic/__info3.yml
        !echo "item3: 'halloitem3'"           > $wf/test_topic/21234567890.yml
        !echo "itemtag1: 'halloitemtag1'"     > $wf/test_topic/21234567890_tag1.yml
        !echo "item4: 'halloitem4'"           > $wf/test_topic/31234567890.yml
        !echo "itemtag3: 'halloitemtag3'"     > $wf/test_topic/31234567890_tag3.yml

      if scenario == 'two_configs_in_root_and_test_topic':
        if not os.path.exists (f'{wf}/test_topic'):
          !mkdir $wf/test_topic
        !echo "test1: 'hallo1'"               > $wf/__info1.yml
        !echo "test2: 'hallo2'"               > $wf/__info2.yml
        !echo "test3: 'hallo3'"               > $wf/test_topic/__info1.yml
        !echo "test4: 'hallo4'"               > $wf/test_topic/__info3.yml

    def syncTmpTestToCloud ():
      # sync to cloud and remove local (if isLocal)
      if CloudYamler.hasRclone:
        os.system(f"rclone sync {Test_CloudYamler.tmp_cloud_folder} {CloudYamler.cloud_service}/{CloudYamler.cloud_folder}")
        !rm -rf $Test_CloudYamler.tmp_cloud_folder

    def test_CloudYamler_item_and_config_in_empty_root_no_scan (self):
      # create yamler
      self.yamler = y = CloudYamler (id_len=11, onInit={'config': False, 'files': False, 'data': False})

      # test in empty root
      self.sub_check_item_lifecycle (y, '01234567890')
      self.sub_check_config_lifecycle (y, 'test_config')

      # test in topic folder
      y.create ('test_topic')
      y.switch ('test_topic')
      self.sub_check_item_lifecycle (y, 't1234567890')
      self.sub_check_config_lifecycle (y, 'test_config')

    def test_CloudYamler_item_and_config_in_not_empty_root_no_scan (self):
      # prepare testdata in tmp folder or org cloud_folder if hosted
      if CloudYamler.isLocal:  wf = Test_CloudYamler.tmp_cloud_folder
      else:                    wf = f'/gdrive/MyDrive/{CloudYamler.cloud_folder}'
      Test_CloudYamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_root',wf=wf)
      Test_CloudYamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_test_topic',wf=wf)

      # sync tmp folder to cloud and remove local (if isLocal) and wf back to correct folder
      if CloudYamler.isLocal:
        wf = CloudYamler.cloud_folder
        Test_CloudYamler.syncTmpTestToCloud ()

      # create yamler
      self.yamler = y = CloudYamler (id_len=11, onInit={'config': False, 'files': False, 'data': False})

      # test yamls ignored
      self.assertEqual (y.topics['_'], {'files': [], 'folder': f'{wf}', 'data': {}, 'config': {}})
      self.assertEqual (y.topics['test_topic'], {'files': [], 'data': {}, 'config': {}, 'folder': f'{wf}/test_topic'})

      # test in not empty root
      self.sub_check_item_lifecycle (y, '01234567890')
      self.sub_check_config_lifecycle (y, 'test_config')

      # test in topic folder
      y.switch ('test_topic')
      self.sub_check_item_lifecycle (y, 't1234567890')
      self.sub_check_config_lifecycle (y, 'test_config')


    def test_CloudYamler_scan_config (self):
      # prepare
      if CloudYamler.isLocal:  wf = Test_CloudYamler.tmp_cloud_folder
      else:                    wf = f'/gdrive/MyDrive/{CloudYamler.cloud_folder}'
      Test_CloudYamler.prepare_scenario (scenario='two_configs_in_root_and_test_topic',wf=wf)

      # sync tmp folder to cloud and remove local (if isLocal)
      if CloudYamler.isLocal:
        wf = CloudYamler.cloud_folder
        Test_CloudYamler.syncTmpTestToCloud ()

      # create yamler with activated confg scan
      self.yamler = y = CloudYamler (id_len=11, onInit={'config': True, 'files': False, 'data': False})
      self.assertEqual (y.config, {'info1': {'test1': 'hallo1'}, 'info2': {'test2': 'hallo2'}})

      # change a value and dump
      y.config['info1']['test1'] = 'new hallo1'
      count = y.dump ()
      self.assertEqual (count, 1)
      self.sub_check_serialize (f'{wf}/__info1.yml', {'test1': 'new hallo1'})

      # remove a config
      y.remove ('info1',isConfig=True)
      self.assertEqual ('info1' in y.config, False)
      self.sub_check_file_exist (f'{wf}/__info1.yml', checkNotExist=True)

      # test standard lifecycle
      self.sub_check_config_lifecycle (y, '_')

      # # test in topic folder
      y.switch ('test_topic')
      wf += '/test_topic'
      self.assertEqual (y.config, {'info1': {'test3': 'hallo3'}, 'info3': {'test4': 'hallo4'}})

      # change a value and dump
      y.config['info1']['test3'] = 'new hallo3'
      count = y.dump ()
      self.assertEqual (count, 1)
      self.sub_check_serialize (f'{wf}/__info1.yml', {'test3': 'new hallo3'})

      # remove a config
      y.remove ('info1',isConfig=True)
      self.assertEqual ('info1' in y.config, False)
      self.sub_check_file_exist (f'{wf}/__info1.yml', checkNotExist=True)

      # test standard lifecycle
      self.sub_check_config_lifecycle (y, 'test_topic')

    def test_CloudYamler_scan_files (self):
      # prepare
      if CloudYamler.isLocal:  wf = Test_CloudYamler.tmp_cloud_folder
      else:                    wf = f'/gdrive/MyDrive/{CloudYamler.cloud_folder}'
      Test_CloudYamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_root', wf=wf)
      Test_CloudYamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_test_topic', wf=wf)

      # sync tmp folder to cloud and remove local (if isLocal)
      if CloudYamler.isLocal:
        wf = CloudYamler.cloud_folder
        Test_CloudYamler.syncTmpTestToCloud ()

      # create yamler with activated confg scan
      self.yamler = y = CloudYamler (id_len=11, onInit={'config': False, 'files': True, 'data': False})
      self.assertEqual (sorted (y.files), sorted (['__info1.yml', '11234567890_tag2.yml', '01234567890.yml', '__info2.yml', '01234567890_tag1.yml', '11234567890.yml']))
      self.assertEqual ((y.data, y.config, y.original),({}, {}, {}))

      # switch and check files
      y.switch ('test_topic')
      self.assertEqual (sorted (y.files), sorted (['__info3.yml', '31234567890.yml', '__info1.yml', '21234567890_tag1.yml', '31234567890_tag3.yml', '21234567890.yml']))
      self.assertEqual ((y.data, y.config, y.original),({}, {}, {}))

    def test_CloudYamler_scan_data (self):
      if CloudYamler.isLocal:  wf = Test_CloudYamler.tmp_cloud_folder
      else:                    wf = f'/gdrive/MyDrive/{CloudYamler.cloud_folder}'
      Test_CloudYamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_root', wf=wf)
      Test_CloudYamler.prepare_scenario (scenario='two_ids_with_tag_and_two_configs_in_test_topic', wf=wf)

      # sync tmp folder to cloud and remove local (if isLocal)
      if CloudYamler.isLocal:
        wf = CloudYamler.cloud_folder
        Test_CloudYamler.syncTmpTestToCloud ()

      # create yamler with activated confg scan
      self.yamler = y = CloudYamler (id_len=11, onInit={'config': False, 'files': False, 'data': True})
      self.assertEqual (y.data['01234567890'], {'_': {'item1': 'halloitem1'}, 'tag1': {'itemtag1': 'halloitemtag1'}})
      self.assertEqual (y.data['11234567890'], {'_': {'item2': 'halloitem2'}, 'tag2': {'itemtag2': 'halloitemtag2'}})
      self.assertEqual (sorted (y.files), sorted (['__info1.yml', '11234567890_tag2.yml', '01234567890.yml', '__info2.yml', '01234567890_tag1.yml', '11234567890.yml']))
      self.assertEqual (y.config,{})

      y.switch ('test_topic')
      self.assertEqual (y.data['21234567890'], {'_': {'item3': 'halloitem3'}, 'tag1': {'itemtag1': 'halloitemtag1'}})
      self.assertEqual (y.data['31234567890'], {'_': {'item4': 'halloitem4'}, 'tag3': {'itemtag3': 'halloitemtag3'}})
      self.assertEqual (sorted (y.files), sorted (['__info3.yml', '31234567890.yml', '__info1.yml', '21234567890_tag1.yml', '31234567890_tag3.yml', '21234567890.yml']))
      self.assertEqual (y.config,{})


if register_and_run_test_CloudYamler:
  result = unittest.main(argv=[""], verbosity=2, exit=False).result
```

    test_ButtonBox_append_with_select (__main__.Test_ButtonBox.test_ButtonBox_append_with_select) ... ok
    test_ButtonBox_append_without_select (__main__.Test_ButtonBox.test_ButtonBox_append_without_select) ... ok
    test_ButtonBox_maxchar_and_tooltip (__main__.Test_ButtonBox.test_ButtonBox_maxchar_and_tooltip) ... ok
    test_ButtonBox_remove (__main__.Test_ButtonBox.test_ButtonBox_remove) ... ok
    test_ButtonBox_selection (__main__.Test_ButtonBox.test_ButtonBox_selection) ... ok
    test_CloudYamler_item_and_config_in_empty_root_no_scan (__main__.Test_CloudYamler.test_CloudYamler_item_and_config_in_empty_root_no_scan) ... ok
    test_CloudYamler_item_and_config_in_not_empty_root_no_scan (__main__.Test_CloudYamler.test_CloudYamler_item_and_config_in_not_empty_root_no_scan) ... ok
    test_CloudYamler_scan_config (__main__.Test_CloudYamler.test_CloudYamler_scan_config) ... ok
    test_CloudYamler_scan_data (__main__.Test_CloudYamler.test_CloudYamler_scan_data) ... ok
    test_CloudYamler_scan_files (__main__.Test_CloudYamler.test_CloudYamler_scan_files) ... ok
    test_Selectable_behave_multi (__main__.Test_Selectable.test_Selectable_behave_multi) ... ok
    test_Selectable_behave_radio (__main__.Test_Selectable.test_Selectable_behave_radio) ... ok
    test_Selectable_behave_radiox (__main__.Test_Selectable.test_Selectable_behave_radiox) ... ok
    test_Selectable_generation (__main__.Test_Selectable.test_Selectable_generation) ... ok
    test_Yamler_item_and_config_in_empty_root_no_scan (__main__.Test_Yamler.test_Yamler_item_and_config_in_empty_root_no_scan) ... ok
    test_Yamler_item_and_config_in_not_empty_root_no_scan (__main__.Test_Yamler.test_Yamler_item_and_config_in_not_empty_root_no_scan) ... ok
    test_Yamler_scan_config (__main__.Test_Yamler.test_Yamler_scan_config) ... ok
    test_Yamler_scan_data (__main__.Test_Yamler.test_Yamler_scan_data) ... ok
    test_Yamler_scan_files (__main__.Test_Yamler.test_Yamler_scan_files) ... ok

    ----------------------------------------------------------------------
    Ran 19 tests in 164.459s

    OK

# Collections

``` python
import os, yaml
from ipywidgets import Text, Button, HBox, VBox, HTML, Dropdown
from ipywidgets import Button, Box, Layout, Textarea

class Collections ():
  def _onSelectTopic (self, change):
    # set current topic
    self.topic = change['new']

    # build collection dropdown
    self.buildCollections ()

    # tell it the boss
    if self.mediator: self.mediator.notify ("onCollections_topicSelect",id=self.topic,obj=self.dd_topics.options[change['owner'].index][0])

    # triggers new collection
    self._onSelectCollection ({'new':0, 'owner':self.dd_collections})


  def _onSelectCollection (self, change):
    # set attributes
    self.title = change['owner'].options[change['owner'].value][1]
    self.index = change['owner'].value

    # tell it the boss
    if self.mediator: self.mediator.notify ("onCollections_CollectionSelect",id=self.index,obj=self.title)


  def buildCollections (self):
    # check if collections for topic exists
    if self.topic in self.collections:
      # build options for dropdown - tuple with title (or folder name) and position in collection list
      self.dd_collections.options = [(c['title'],i) for i,c in enumerate (self.collections[self.topic]['collections'])]
      self.widget.children = [self.dd_topics, self.dd_collections]
    else:
      self.widget.children = [self.dd_topics]


  def __init__(self, root, id_len=11, mediator=None):
    # init attributes
    self.topic,  self.topics,    self.collection, self.collections, self.mediator, self.root =\
    '',         [],             '',              {},               mediator,      root
    self.index, self.title =\
    -1,         ''

    # scan root - ignore if no __collection.yml
    if os.path.exists(f"{self.root}/__collection.yml"):
      with open (f"{self.root}/__collection.yml", 'r') as stream: self.collections['_'] = yaml.safe_load(stream)
      self.topic, titleFromYml = '_', self.collections['_']['title'] if 'title' in self.collections['_'] else 'ROOT'
      self.topics.append ((titleFromYml, '_'))

    # scan topics (folders) - ignore if no __collection.yml
    for item in os.listdir(f"{self.root}"):
      if os.path.isdir(os.path.join(f"{self.root}/", item)):
        if os.path.exists(f"{self.root}/{item}/__collection.yml"):
          with open (f"{self.root}/{item}/__collection.yml", 'r') as stream: self.collections[item] = yaml.safe_load(stream)
          titleFromYml = self.collections[item]['title'] if item in self.collections else item
          self.topics.append((titleFromYml,item))
          if not self.topic: self.topic = item

    # widgets
    line                = HTML (value='<font size=-2><hr>')
    self.dd_topics      = Dropdown(options=self.topics,layout={'width':'auto'})
    self.dd_collections = Dropdown(layout={'width':'auto'})
    self.widget         = VBox (children=[self.dd_topics, line],layout={'width':'160px'})

    # build collections dropdown after observe triggers _onSelectCollection
    self.buildCollections ()

    # events
    self.dd_topics      .observe (self._onSelectTopic,      names='value')
    self.dd_collections .observe (self._onSelectCollection, names='value')

    #from IPython.core.debugger import Pdb; Pdb().set_trace()


    # simulate dropdown change to trigger notify
    if self.mediator: self._onSelectTopic ({'new':self.topic, 'owner':self.dd_topics})


def write_dummy_data (folder):
  #little test
  _collections_topics=yaml.safe_load("""
  _:
    title: "My favorites"
    description: "playlists by different themes"
    collections:
    - title: "Dance Music"
      description: "shake your ass"
      loaded: False
    - title: "Dreaming"
      description: "slow spheric sounds"
      loaded: False
  rock:
    title: "Rock Music"
    description: "Collections of rock music"
    collections:
    - title: "Heavy Metal"
      description: "classic heavy metal"
      loaded: False
    - title: "Glam Rock"
      description: "the 70's glam rock"
      loaded: False
  punk:
    title: "Punk Rock"
    description: "Collections of Punk Rock music"
    collections:
    - title: "Hardcore punk"
      description: "Boston style hardcore punk"
      loaded: False
    - title: "Celtic punk"
      description: "Irish and Celtic punk"
      loaded: False
  classic:
    title: "Classic Music"
    description: "Collections of classic music"
    collections:
    - title: "Opera"
      description: "Opera music"
      loaded: False
    - title: "Baroque"
      description: "Music from the baroque epoch"
      loaded: False
  """[1:])

  # clean new folder
  !rm -rf $folder; mkdir $folder

  # write dummys and make topic-folders
  for topic in _collections_topics:
    if topic == '_':
      with open(f'{folder}/__collection.yml', 'w') as file: yaml.dump(_collections_topics[topic], file)
    else:
      !mkdir $folder/$topic
      with open(f'{folder}/{topic}/__collection.yml', 'w') as file: yaml.dump(_collections_topics[topic], file)


class DummyMediator:
  def __init__(self):
    pass
  def notify (self, msg, id, obj=None):
    print (f"{msg} {id} {obj}")

write_dummy_data ('_collections')

c = Collections (root='_collections', mediator=DummyMediator())
!rm -rf _collections

c.widget
```

    onCollections_topicSelect _ My favorites
    onCollections_CollectionSelect 0 0

    VBox(children=(Dropdown(layout=Layout(width='auto'), options=(('My favorites', '_'), ('Punk Rock', 'punk'), ('‚Ä¶

``` python
c.topic
```

    '_'

``` python
import unittest
from IPython.display import clear_output
only_register_test_Collections = False # @param {type:"boolean"}
register_and_run_test_Collections = True # @param {type:"boolean"}

if only_register_test_Collections or register_and_run_test_Collections:
  # test case
  class Test_Collections (unittest.TestCase):
    folder_for_test = '_collections_test'
    _collections_only_in_root=yaml.safe_load("""
    _:
      title: "My favorites"
      description: "playlists by different themes"
      collections:
      - title: "Dance Music"
        description: "shake your ass"
        loaded: False
      - title: "Dreaming"
        description: "slow spheric sounds"
        loaded: False
    """[1:])
    _collections_only_in_topics=yaml.safe_load("""
    rock:
      title: "Rock Music"
      description: "Collections of rock music"
      collections:
      - title: "Heavy Metal"
        description: "classic heavy metal"
        loaded: False
      - title: "Glam Rock"
        description: "the 70's glam rock"
        loaded: False
    classic:
      title: "Classic Music"
      description: "Collections of classic music"
      collections:
      - title: "Opera"
        description: "Opera music"
        loaded: False
      - title: "Baroque"
        description: "Music from the baroque epoch"
        loaded: False
    """[1:])
    _collections_in_root_and_topics=yaml.safe_load("""
    _:
      title: "My favorites"
      description: "playlists by different themes"
      collections:
      - title: "Dance Music"
        description: "shake your ass"
        loaded: False
      - title: "Dreaming"
        description: "slow spheric sounds"
        loaded: False
    rock:
      title: "Rock Music"
      description: "Collections of rock music"
      collections:
      - title: "Heavy Metal"
        description: "classic heavy metal"
        loaded: False
      - title: "Glam Rock"
        description: "the 70's glam rock"
        loaded: False
    punk:
      title: "Punk Rock"
      description: "Collections of Punk Rock music"
      collections:
      - title: "Hardcore punk"
        description: "Boston style hardcore punk"
        loaded: False
      - title: "Celtic punk"
        description: "Irish and Celtic punk"
        loaded: False
    classic:
      title: "Classic Music"
      description: "Collections of classic music"
      collections:
      - title: "Opera"
        description: "Opera music"
        loaded: False
      - title: "Baroque"
        description: "Music from the baroque epoch"
        loaded: False
    """[1:])


    def write_test_dummy_data (topics):
      # write dummys and make topic-folders
      for topic in topics:
        if topic == '_':
          with open(f'{Test_Collections.folder_for_test}/__collection.yml', 'w') as file: yaml.dump(Test_Collections._collections_topics[topic], file)
        else:
          !mkdir $Test_Collections.folder_for_test/$topic
          with open(f'{Test_Collections.folder_for_test}/{topic}/__collection.yml', 'w') as file: yaml.dump(Test_Collections._collections_topics[topic], file)

    def setUp (self):
      # remove and create folder
      !rm -rf $Test_Collections.folder_for_test; mkdir $Test_Collections.folder_for_test

    def xtest_Collections_empty_root (self):
      cl = Collections (root=Test_Collections.folder_for_test)
      self.assertEqual ((cl.topics, cl.collections), ([], {}))

    def xtest_Collections_root_with_topics_no_files (self):
      Test_Collections.write_test_dummy_data (_collections_topics)
      global cl
      cl = Collections (root=Test_Collections.folder_for_test)
      self.assertEqual (sorted (cl.topics), [('Collection of classic music', 'classic'),
                                             ('Collections of Punk Rock music', 'punk'),
                                             ('Collections of Rock music', 'rock'),
                                             ('My favorites', '_')])
      self.assertEqual ((c.dd_topics.options[c.dd_topics.index][0], c.dd_topics.value), ('My favorites','_'))

    def test_collections_only_in_topics (self):
      Test_Collections.write_test_dummy_data (Test_Collections._collections_only_in_topics)
      global cl
      cl = Collections (root=Test_Collections.folder_for_test)
      self.assertEqual (sorted (cl.topics), [('Collection of classic music', 'classic'),
                                             ('Collections of Rock music', 'rock')])

if register_and_run_test_Collections:
  result = unittest.main(argv=[""], verbosity=2, exit=False).result
```

    test_CloudYamler_item_and_config_in_not_empty_root_no_scan (__main__.Test_CloudYamler) ... ok
    test_collections_only_in_topics (__main__.Test_Collections) ... ERROR

    ======================================================================
    ERROR: test_collections_only_in_topics (__main__.Test_Collections)
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "<ipython-input-13-857e59b0b2ae>", line 116, in test_collections_only_in_topics
        Test_Collections.write_test_dummy_data (Test_Collections._collections_only_in_topics)
      File "<ipython-input-13-857e59b0b2ae>", line 95, in write_test_dummy_data
        with open(f'{Test_Collections.folder_for_test}/{topic}/__collection.yml', 'w') as file: yaml.dump(Test_Collections._collections_topics[topic], file)
    AttributeError: type object 'Test_Collections' has no attribute '_collections_topics'

    ----------------------------------------------------------------------
    Ran 2 tests in 2.150s

    FAILED (errors=1)

``` python
cl.topics, cl.collections
```

    ([], {})

# YoutubeList

``` python
#@markdown <font size='+2' color='#005F6A'>**YoutubeList**</font><br>
#@markdown <table><tr><td><font size=+2>
#@markdown
#@markdown ```python
#@markdown vlist = ['8SF_h3xF3cE', 'F4tvM4Vb3A0', 'hBBOjCiFcuo',
#@markdown          'toUgBQv1BT8', '_rXzeWq4C6w', 'AdhG64NF76E']
#@markdown links = YoutubeVideoList (vlist, height=80)
#@markdown
#@markdown display (links.widget)
#@markdown ```
#@markdown </td></tr></table>

import os
from ipywidgets import Text, Button, HBox, VBox, HTML, Dropdown
from ipywidgets import Button, Box, Layout, Textarea
try:      from youtubesearchpython import Video
except:   os.system ('pip install youtube-search-python')
finally:  from youtubesearchpython import Video

# Import necessary modules and handle the installation of the youtube-search-python package if not already installed.
from ipywidgets import Text
from youtubesearchpython import Video

#chapterizer

class YoutubeListItem (Selectable):
  """A class representing a YouTube list item that extends the Selectable class.
  This class fetches video information from YouTube and displays it in a selectable format.

  Methods
  -------
  * getVideoInfoFromApi(video_id) | -> dict or None
    Fetches video information from YouTube using the video ID.
  * onFirstSelect(posList) | -> none
    Defines behavior when the item is selected for the first time.
  * onSelection(posList) | -> none
    Defines behavior on subsequent selections.
  * setInitState() | -> none
    Initializes the state of the item with a link to the video.
  """

  def setInitState (self):
    """Initializes the state of the item with a link to the video."""
    self.hm_link = HTML(value=f"<font size='+0'><a href='https://www.youtube.com/watch?v={self.id}'>{self.id}</a> ", layout={'width':'200px'})
    self.setItemWidget (self.hm_link)
    if self.mediator: self.mediator.notify ("onYoutubeListItem_widgetInitState",id=self.id, obj=self.hm_link)

  def __init__(self, item, items, mediator=None, selector=None, behave='radio'):
    """Initializes the YoutubeListItem with given parameters."""
    self.mediator, self.selector = mediator, selector
    if type (item) == str: self.id, self.item = item, None
    else: self.description, self.id, self.title, self.link = item['description'], item['id'], item['title'], item['link']
    super().__init__(item, items, behave, selector)

    #self.chapterSelector = None



class YoutubeList:
  """A class representing a list of YouTube videos with selectable items.

  Attributes
  ----------
  * idList: list
    A list of YouTube video IDs.
  * mediator: obj
    An optional mediator object for handling events.
  * height: int
    The height of the video list display.

  Methods
  -------
  * checkAndStore(vid) | -> bool
    Checks if a video ID is valid and stores its information.
  * _onActionClick(b: Button) | -> none
    Handles the click event for the action button.
  * _onIdChange(_) | -> none
    Handles changes in the video ID input field.
  * _onSelect(positions) | -> none
    Handles the selection of a video item.
  """

  def __init__(self, idList=None, mediator=None, yamler=None, height=200):
    """Initializes the YoutubeVideoList with given parameters."""
    self.youtubeListItem, self.youtubeListItems, self.videoInfo = None, [], None
    self.mediator, self.idList, self.yamler, self.isValid = mediator, idList, yamler, False
    # widgets
    self.bu_action     = Button (description=' ', layout={'width':'70px'}, style={'button_color': 'powderblue'}, disabled=True )
    self.tx_videoid    = Text(placeholder='Topic' if yamler and yamler.topic else 'Video-ID', disabled=False, layout={'width':'110px'} )
    self.hb_idedit     = HBox (children=[self.tx_videoid, self.bu_action])
    self.vb_inner      = VBox(layout={'height':f'{height}px', 'width':'100%', 'overflow':'auto'})
    self.bx_outer      = Box (children=[self.vb_inner], layout={'width':'100%','overflow':'auto'})
    self.widget        = VBox (children=[self.bx_outer],layout={'width':'210px','border':'1px solid', 'height':'100%'})
    self.dd_collection = Dropdown(layout={'width':'auto'})
    self.dd_topic      = Dropdown(layout={'width':'auto'})

    # # build widgets by id list
    # if idList: self.buildByIdList ()
    # # build widgets by yamler
    # elif yamler: self.buildByYamler()
    self.buildByYamler()

    # bind events
    self.listening = True
    self.bu_action    .on_click (self._onActionClick)
    self.tx_videoid   .observe  (self._onIdChange, names=['value'])
    self.dd_collection.observe  (self._onSelectPlaylist, names=['value'])
    self.dd_topic     .observe  (self._onSelectTopic, names=['value'])

  def buildByIdList (self):
    # create items for ids
    items = [YoutubeListItem (id, self.youtubeListItems, mediator=self.mediator, selector=self.selector) for id in self.idList]

    # for id in self.idList:
    #   dmp = [{}]
    #   with open(f'{self.folder}/{id}.yml', 'w') as file: yaml.dump(_collections_yml['mathpl'], file)

    if not self.yamler: self.yamler = Yamler(root=self.folder)
    options = [('ROOT','ROOT')]
    if self.yamler.topics:
      # loop all topic
      for topic in self.yamler.topics:
        # collection-topic or normal topic
        if not 'collection' in self.yamler.topics[topic]['config']: item = options.append ((topic, topic))
        else: item = options.append ((self.yamler.topics[topic]['config']['collection']['title'], topic))
      self.dd_topic.options, self.widget.children = options, (self.dd_topic, self.bx_outer)

    for vid in self.idList:
      if not vid in self.youtubeListItems:
        self.vb_inner.children = (*self.vb_inner.children, YoutubeListItem (vid, self.youtubeListItems, mediator=self.mediator, selector=self.selector).widget)

  def buildByYamler (self):
    # remove old controls
    self.widget.children = [self.bx_outer]

    # if '__collection.yml' in folder: dropdown playlists (courses)
    if self.yamler.topic and 'collection' in self.yamler.config:
      items = [(c['title'], i) for i,c in enumerate (self.yamler.config['collection']['courses'])]
      self.dd_collection.options, self.widget.children = items, (self.dd_collection, self.bx_outer)

    # no collection -> id-edit instead dropdown
    else:  self.widget.children = (self.hb_idedit, *self.widget.children)

    # topic dropdown
    options = [('ROOT','ROOT')]
    if self.yamler.topics:
      # loop all topic
      for topic in self.yamler.topics:
        # collection-topic or normal topic
        if not 'collection' in self.yamler.topics[topic]['config']: item = options.append ((topic, topic))
        else: item = options.append ((self.yamler.topics[topic]['config']['collection']['title'], topic))
      self.dd_topic.options, self.widget.children = options, (self.dd_topic, *self.widget.children)

    # build list items
    self.vb_inner.children = []
    for vid in self.yamler.ids():
      if not vid in self.youtubeListItems:
        self.vb_inner.children = (*self.vb_inner.children,
                                  YoutubeListItem (vid,                    # video id
                                                   self.youtubeListItems,  # item list (put itself on it)
                                                   mediator=self.mediator, # for notify mediator
                                                   selector=self.selector) # event for item select
                                  .widget) # the item widget for the box

  def checkAndStore (self, vid):
    """Checks if a video ID is valid and stores its information."""
    if self.videoInfo and self.videoInfo['id'] == vid: return
    try:    self.videoInfo = Video.getInfo('https://www.youtube.com/watch?v='+vid)
    except: self.isValid = False
    else:   self.isValid = True
    if self.isValid  and self.mediator:
      self.mediator.notify ("onYoutubeList_videoInfoCheckedAndStored",id=self.videoInfo['id'], obj=self.videoInfo)
    return  self.isValid

  def _onSelectTopic (self, _):
    if not self.listening: return
    self.listening = False
    if _['new'] == 'ROOT': yamler.activate()
    else:                  yamler.activate(_['new'])
    self.buildByYamler()
    self.listening = True

  def _onSelectPlaylist (self, _):
    if not self.listening: return
    if self.mediator:
      value = self.dd_collection.value
      #obj = (self.dd_collection.value , self.yamler.config['collection']['courses][self.dd_collection.value])
      self.mediator.notify ("onYoutubeList_selectPlaylist", (0, 'mathpl'))

  def _onActionClick (self, b):
    if not self.listening: return
    """Handles the click event for the action button."""
    if b.description == 'add':
      self.youtubeListItem = YoutubeListItem (self.videoInfo, self.youtubeListItems, mediator=self.mediator, selector=self.selector)
      self.bx_outer.children[0].children = (*self.bx_outer.children[0].children, self.youtubeListItem.widget)
      self.tx_videoid.value=''
      self.bu_action.disabled, self.bu_action.style, self.bu_action.description = False, {'button_color': 'orange'}, 'del'
      if self.mediator: self.mediator.notify ("onYoutubeList_add",id=self.videoInfo['id'])

    elif b.description == 'del':
      for i in range (len (self.youtubeListItems)):
        if self.youtubeListItems[i].id == self.youtubeListItem.id: break
      self.youtubeListItem = None
      self.bu_action.disabled, self.bu_action.style, self.bu_action.description = True, {'button_color': 'powderblue'}, ' '
      self.vb_inner.children = (*self.vb_inner.children[:i], *self.vb_inner.children[i+1:])
      del self.youtubeListItems[i]
      self.tx_videoid.unobserve_all ()
      self.tx_videoid.value = ''
      self.tx_videoid.observe (self._onIdChange, names=['value'])
      #if self.mediator: self.mediator.notify ("onYoutubeList_del")

  def _onIdChange (self, _):
    if not self.listening: return
    """Handles changes in the video ID input field."""
    if len (self.tx_videoid.value) == 11:
      if sum ([v.id == self.tx_videoid.value for v in self.youtubeListItems]):
        self.bu_action.disabled, self.bu_action.style, self.bu_action.description = False, {'button_color': 'orange'}, 'del'
        [v for v in self.youtubeListItems if v.id == self.tx_videoid.value][0].select()
      elif self.checkAndStore (self.tx_videoid.value):
        self.bu_action.disabled, self.bu_action.style, self.bu_action.description = False, {'button_color': 'lightgreen'}, 'add'
      else:
        self.bu_action.disabled, self.bu_action.style, self.bu_action.description = True, {'button_color': 'powderblue'}, ' '
    else:
      self.bu_action.disabled, self.bu_action.style, self.bu_action.description = True, {'button_color': 'powderblue'}, ' '

  def selector (self, positions):
    if not self.listening: return
    """Handles the selection of a video item."""
    self.tx_videoid.unobserve_all ()
    self.youtubeListItem = self.youtubeListItems[positions[0]]
    self.tx_videoid.value = self.youtubeListItem.id
    self.bu_action.disabled, self.bu_action.style, self.bu_action.description = False, {'button_color': 'orange'}, 'del'
    self.tx_videoid.observe (self._onIdChange, names=['value'])

    if self.mediator: self.mediator.notify ("onYoutubeList_select",id=self.youtubeListItem.id)


deepLearningForCodersVideos = \
['8SF_h3xF3cE', 'F4tvM4Vb3A0', 'hBBOjCiFcuo', 'toUgBQv1BT8', '_rXzeWq4C6w', 'AdhG64NF76E', 'p4ZZq0736Po', 'htiNBPxcXgo', '_7rMfsA24Ls',
 '6StU6UtZEbU', 'Tf-8F5q8Xww', '_xIzPbCgutY', 'vGdB4eI4KBs', 'veqj0DsZSXU', '0Hi2r4CaHvk', '9YZaYjRKuEc', 'vGsc_NbU7xc', 'nlVOG2Nzc3k']
# 'CGpR2ILao5M' - no description chapters

#yamler=Yamler(folder='yemler'); yvl = YoutubeList(yamler=yamler)
#yvl = YoutubeList(deepLearningForCodersVideos)

yvl = YoutubeList(yamler=Yamler(root='yamler'))
yvl.widget
```

    VBox(children=(Dropdown(layout=Layout(width='auto'), options=(('ROOT', 'ROOT'), ('_', '_')), value='ROOT'), HB‚Ä¶

    AttributeError: 'Yamler' object has no attribute 'activate'
    [0;31m---------------------------------------------------------------------------[0m
    [0;31mAttributeError[0m                            Traceback (most recent call last)
    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/ipywidgets/widgets/widget.py:757[0m, in [0;36mWidget._handle_msg[0;34m(self, msg)[0m
    [1;32m    755[0m         [38;5;28;01mif[39;00m [38;5;124m'[39m[38;5;124mbuffer_paths[39m[38;5;124m'[39m [38;5;129;01min[39;00m data:
    [1;32m    756[0m             _put_buffers(state, data[[38;5;124m'[39m[38;5;124mbuffer_paths[39m[38;5;124m'[39m], msg[[38;5;124m'[39m[38;5;124mbuffers[39m[38;5;124m'[39m])
    [0;32m--> 757[0m         [38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43mset_state[49m[43m([49m[43mstate[49m[43m)[49m
    [1;32m    759[0m [38;5;66;03m# Handle a state request.[39;00m
    [1;32m    760[0m [38;5;28;01melif[39;00m method [38;5;241m==[39m [38;5;124m'[39m[38;5;124mrequest_state[39m[38;5;124m'[39m:

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/ipywidgets/widgets/widget.py:621[0m, in [0;36mWidget.set_state[0;34m(self, sync_data)[0m
    [1;32m    616[0m         [38;5;28mself[39m[38;5;241m.[39m_send(msg, buffers[38;5;241m=[39mecho_buffers)
    [1;32m    618[0m [38;5;66;03m# The order of these context managers is important. Properties must[39;00m
    [1;32m    619[0m [38;5;66;03m# be locked when the hold_trait_notification context manager is[39;00m
    [1;32m    620[0m [38;5;66;03m# released and notifications are fired.[39;00m
    [0;32m--> 621[0m [43m[49m[38;5;28;43;01mwith[39;49;00m[43m [49m[38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43m_lock_property[49m[43m([49m[38;5;241;43m*[39;49m[38;5;241;43m*[39;49m[43msync_data[49m[43m)[49m[43m,[49m[43m [49m[38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43mhold_trait_notifications[49m[43m([49m[43m)[49m[43m:[49m
    [1;32m    622[0m [43m    [49m[38;5;28;43;01mfor[39;49;00m[43m [49m[43mname[49m[43m [49m[38;5;129;43;01min[39;49;00m[43m [49m[43msync_data[49m[43m:[49m
    [1;32m    623[0m [43m        [49m[38;5;28;43;01mif[39;49;00m[43m [49m[43mname[49m[43m [49m[38;5;129;43;01min[39;49;00m[43m [49m[38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43mkeys[49m[43m:[49m

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/contextlib.py:144[0m, in [0;36m_GeneratorContextManager.__exit__[0;34m(self, typ, value, traceback)[0m
    [1;32m    142[0m [38;5;28;01mif[39;00m typ [38;5;129;01mis[39;00m [38;5;28;01mNone[39;00m:
    [1;32m    143[0m     [38;5;28;01mtry[39;00m:
    [0;32m--> 144[0m         [38;5;28mnext[39m([38;5;28mself[39m[38;5;241m.[39mgen)
    [1;32m    145[0m     [38;5;28;01mexcept[39;00m [38;5;167;01mStopIteration[39;00m:
    [1;32m    146[0m         [38;5;28;01mreturn[39;00m [38;5;28;01mFalse[39;00m

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/traitlets/traitlets.py:1510[0m, in [0;36mHasTraits.hold_trait_notifications[0;34m(self)[0m
    [1;32m   1508[0m [38;5;28;01mfor[39;00m changes [38;5;129;01min[39;00m cache[38;5;241m.[39mvalues():
    [1;32m   1509[0m     [38;5;28;01mfor[39;00m change [38;5;129;01min[39;00m changes:
    [0;32m-> 1510[0m         [38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43mnotify_change[49m[43m([49m[43mchange[49m[43m)[49m

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/ipywidgets/widgets/widget.py:687[0m, in [0;36mWidget.notify_change[0;34m(self, change)[0m
    [1;32m    684[0m     [38;5;28;01mif[39;00m name [38;5;129;01min[39;00m [38;5;28mself[39m[38;5;241m.[39mkeys [38;5;129;01mand[39;00m [38;5;28mself[39m[38;5;241m.[39m_should_send_property(name, [38;5;28mgetattr[39m([38;5;28mself[39m, name)):
    [1;32m    685[0m         [38;5;66;03m# Send new state to front-end[39;00m
    [1;32m    686[0m         [38;5;28mself[39m[38;5;241m.[39msend_state(key[38;5;241m=[39mname)
    [0;32m--> 687[0m [38;5;28;43msuper[39;49m[43m([49m[43mWidget[49m[43m,[49m[43m [49m[38;5;28;43mself[39;49m[43m)[49m[38;5;241;43m.[39;49m[43mnotify_change[49m[43m([49m[43mchange[49m[43m)[49m

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/traitlets/traitlets.py:1525[0m, in [0;36mHasTraits.notify_change[0;34m(self, change)[0m
    [1;32m   1523[0m [38;5;28;01mdef[39;00m [38;5;21mnotify_change[39m([38;5;28mself[39m, change: Bunch) [38;5;241m-[39m[38;5;241m>[39m [38;5;28;01mNone[39;00m:
    [1;32m   1524[0m [38;5;250m    [39m[38;5;124;03m"""Notify observers of a change event"""[39;00m
    [0;32m-> 1525[0m     [38;5;28;01mreturn[39;00m [38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43m_notify_observers[49m[43m([49m[43mchange[49m[43m)[49m

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/traitlets/traitlets.py:1568[0m, in [0;36mHasTraits._notify_observers[0;34m(self, event)[0m
    [1;32m   1565[0m [38;5;28;01melif[39;00m [38;5;28misinstance[39m(c, EventHandler) [38;5;129;01mand[39;00m c[38;5;241m.[39mname [38;5;129;01mis[39;00m [38;5;129;01mnot[39;00m [38;5;28;01mNone[39;00m:
    [1;32m   1566[0m     c [38;5;241m=[39m [38;5;28mgetattr[39m([38;5;28mself[39m, c[38;5;241m.[39mname)
    [0;32m-> 1568[0m [43mc[49m[43m([49m[43mevent[49m[43m)[49m

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/ipywidgets/widgets/widget_selection.py:235[0m, in [0;36m_Selection._propagate_index[0;34m(self, change)[0m
    [1;32m    233[0m     [38;5;28mself[39m[38;5;241m.[39mlabel [38;5;241m=[39m label
    [1;32m    234[0m [38;5;28;01mif[39;00m [38;5;28mself[39m[38;5;241m.[39mvalue [38;5;129;01mis[39;00m [38;5;129;01mnot[39;00m value:
    [0;32m--> 235[0m     [38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43mvalue[49m [38;5;241m=[39m value

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/traitlets/traitlets.py:716[0m, in [0;36mTraitType.__set__[0;34m(self, obj, value)[0m
    [1;32m    714[0m [38;5;28;01mif[39;00m [38;5;28mself[39m[38;5;241m.[39mread_only:
    [1;32m    715[0m     [38;5;28;01mraise[39;00m TraitError([38;5;124m'[39m[38;5;124mThe [39m[38;5;124m"[39m[38;5;132;01m%s[39;00m[38;5;124m"[39m[38;5;124m trait is read-only.[39m[38;5;124m'[39m [38;5;241m%[39m [38;5;28mself[39m[38;5;241m.[39mname)
    [0;32m--> 716[0m [38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43mset[49m[43m([49m[43mobj[49m[43m,[49m[43m [49m[43mvalue[49m[43m)[49m

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/traitlets/traitlets.py:706[0m, in [0;36mTraitType.set[0;34m(self, obj, value)[0m
    [1;32m    702[0m     silent [38;5;241m=[39m [38;5;28;01mFalse[39;00m
    [1;32m    703[0m [38;5;28;01mif[39;00m silent [38;5;129;01mis[39;00m [38;5;129;01mnot[39;00m [38;5;28;01mTrue[39;00m:
    [1;32m    704[0m     [38;5;66;03m# we explicitly compare silent to True just in case the equality[39;00m
    [1;32m    705[0m     [38;5;66;03m# comparison above returns something other than True/False[39;00m
    [0;32m--> 706[0m     [43mobj[49m[38;5;241;43m.[39;49m[43m_notify_trait[49m[43m([49m[38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43mname[49m[43m,[49m[43m [49m[43mold_value[49m[43m,[49m[43m [49m[43mnew_value[49m[43m)[49m

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/traitlets/traitlets.py:1513[0m, in [0;36mHasTraits._notify_trait[0;34m(self, name, old_value, new_value)[0m
    [1;32m   1512[0m [38;5;28;01mdef[39;00m [38;5;21m_notify_trait[39m([38;5;28mself[39m, name: [38;5;28mstr[39m, old_value: t[38;5;241m.[39mAny, new_value: t[38;5;241m.[39mAny) [38;5;241m-[39m[38;5;241m>[39m [38;5;28;01mNone[39;00m:
    [0;32m-> 1513[0m     [38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43mnotify_change[49m[43m([49m
    [1;32m   1514[0m [43m        [49m[43mBunch[49m[43m([49m
    [1;32m   1515[0m [43m            [49m[43mname[49m[38;5;241;43m=[39;49m[43mname[49m[43m,[49m
    [1;32m   1516[0m [43m            [49m[43mold[49m[38;5;241;43m=[39;49m[43mold_value[49m[43m,[49m
    [1;32m   1517[0m [43m            [49m[43mnew[49m[38;5;241;43m=[39;49m[43mnew_value[49m[43m,[49m
    [1;32m   1518[0m [43m            [49m[43mowner[49m[38;5;241;43m=[39;49m[38;5;28;43mself[39;49m[43m,[49m
    [1;32m   1519[0m [43m            [49m[38;5;28;43mtype[39;49m[38;5;241;43m=[39;49m[38;5;124;43m"[39;49m[38;5;124;43mchange[39;49m[38;5;124;43m"[39;49m[43m,[49m
    [1;32m   1520[0m [43m        [49m[43m)[49m
    [1;32m   1521[0m [43m    [49m[43m)[49m

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/ipywidgets/widgets/widget.py:687[0m, in [0;36mWidget.notify_change[0;34m(self, change)[0m
    [1;32m    684[0m     [38;5;28;01mif[39;00m name [38;5;129;01min[39;00m [38;5;28mself[39m[38;5;241m.[39mkeys [38;5;129;01mand[39;00m [38;5;28mself[39m[38;5;241m.[39m_should_send_property(name, [38;5;28mgetattr[39m([38;5;28mself[39m, name)):
    [1;32m    685[0m         [38;5;66;03m# Send new state to front-end[39;00m
    [1;32m    686[0m         [38;5;28mself[39m[38;5;241m.[39msend_state(key[38;5;241m=[39mname)
    [0;32m--> 687[0m [38;5;28;43msuper[39;49m[43m([49m[43mWidget[49m[43m,[49m[43m [49m[38;5;28;43mself[39;49m[43m)[49m[38;5;241;43m.[39;49m[43mnotify_change[49m[43m([49m[43mchange[49m[43m)[49m

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/traitlets/traitlets.py:1525[0m, in [0;36mHasTraits.notify_change[0;34m(self, change)[0m
    [1;32m   1523[0m [38;5;28;01mdef[39;00m [38;5;21mnotify_change[39m([38;5;28mself[39m, change: Bunch) [38;5;241m-[39m[38;5;241m>[39m [38;5;28;01mNone[39;00m:
    [1;32m   1524[0m [38;5;250m    [39m[38;5;124;03m"""Notify observers of a change event"""[39;00m
    [0;32m-> 1525[0m     [38;5;28;01mreturn[39;00m [38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43m_notify_observers[49m[43m([49m[43mchange[49m[43m)[49m

    File [0;32m~/miniforge3/envs/ds/lib/python3.11/site-packages/traitlets/traitlets.py:1568[0m, in [0;36mHasTraits._notify_observers[0;34m(self, event)[0m
    [1;32m   1565[0m [38;5;28;01melif[39;00m [38;5;28misinstance[39m(c, EventHandler) [38;5;129;01mand[39;00m c[38;5;241m.[39mname [38;5;129;01mis[39;00m [38;5;129;01mnot[39;00m [38;5;28;01mNone[39;00m:
    [1;32m   1566[0m     c [38;5;241m=[39m [38;5;28mgetattr[39m([38;5;28mself[39m, c[38;5;241m.[39mname)
    [0;32m-> 1568[0m [43mc[49m[43m([49m[43mevent[49m[43m)[49m

    Cell [0;32mIn[17], line 179[0m, in [0;36mYoutubeList._onSelectTopic[0;34m(self, _)[0m
    [1;32m    177[0m [38;5;28mself[39m[38;5;241m.[39mlistening [38;5;241m=[39m [38;5;28;01mFalse[39;00m
    [1;32m    178[0m [38;5;28;01mif[39;00m _[[38;5;124m'[39m[38;5;124mnew[39m[38;5;124m'[39m] [38;5;241m==[39m [38;5;124m'[39m[38;5;124mROOT[39m[38;5;124m'[39m: yamler[38;5;241m.[39mactivate()
    [0;32m--> 179[0m [38;5;28;01melse[39;00m:                  [43myamler[49m[38;5;241;43m.[39;49m[43mactivate[49m(_[[38;5;124m'[39m[38;5;124mnew[39m[38;5;124m'[39m])
    [1;32m    180[0m [38;5;28mself[39m[38;5;241m.[39mbuildByYamler()
    [1;32m    181[0m [38;5;28mself[39m[38;5;241m.[39mlistening [38;5;241m=[39m [38;5;28;01mTrue[39;00m

    [0;31mAttributeError[0m: 'Yamler' object has no attribute 'activate'

``` python
!rm -rf yemler/; mkdir yemler; mkdir yemler/mathpl; mkdir yemler/other
!echo "test: 'hallo'" > yemler/01234567890.yml
!echo "test2: 'hallo2'" > yemler/01234567890_loop.yml
!echo "test3: 'hallo3'" > yemler/__conf.yml
!echo "test4: 'hallo4'" > yemler/01234567890_de.yml
!echo "test: 'hallo'" > yemler/11234567890.yml
!echo "test2: 'hallo2'" > yemler/11234567890_loop.yml

!echo "test: 'hallo'" > yemler/mathpl/x1234567890.yml
!echo "test2: 'hallo2'" > yemler/mathpl/x1234567890_loop.yml
!echo "test3: 'hallo3'" > yemler/mathpl/__cunf.yml
!echo "test4: 'hallo4'" > yemler/mathpl/x1234567890_de.yml
!echo "test: 'hallo'" > yemler/mathpl/x2234567890.yml
!echo "test2: 'hallo2'" > yemler/mathpl/x2234567890_loop.yml

!echo "position:0" > yemler/other/y1234567890.yml
!echo "position:1" > yemler/other/y2234567890.yml

with open('yemler/other/__collection.yml', 'w') as file: yaml.dump(_collections_yml['mathpl'], file)
```

# YoutubeTranscript

``` python
#@markdown
#@markdown <table><tr><td><font size=+2>
#@markdown
#@markdown ```python
#@markdown # show english (default) transcript and (otpional) the translation
#@markdown vt = VideoTranscript ('8SF_h3xF3cE',translationLanguage='de')
#@markdown display (vt.widget)
#@markdown # Access transcription and translation with:
#@markdown # vt.transcript, vt.dataTranscript, vt.translation, vt.dataTranslation
#@markdown ```
#@markdown </td></tr></table>
import os
from ipywidgets import Tab, Button, HBox, VBox, Text, Textarea, HTML
try:     from youtube_transcript_api import YouTubeTranscriptApi
except:  os.system ('pip install youtube-transcript-api')
finally: from youtube_transcript_api import YouTubeTranscriptApi

class VideoTranscriptTools:
  default_chartokfac = 3.1

  def originalView (trans):
    ret = ''
    for all in trans:
      ret += f"{all['start']}|{all['duration']}|{all['text']}\n"
    return ret

  def timestampView (trans):
    """ make the transcription text format for the textareas """
    txt, max_block_line_len = '', 58
    for all in trans:
      tmp, block, sec = all['text'].replace('\xa0','').replace('\n',''), [], int(all['start'])
      h, i = sec//3600, len (tmp)
      m    = (sec - (h*3600)) // 60
      s    = sec - h*3600 - m*60
      # make a text block
      while len (tmp) > max_block_line_len:
        for i in reversed(range(max_block_line_len)):
          if tmp[i] == ' ': break
        block.append(tmp[:i])
        tmp = tmp[i+1:]
      block.append(tmp[:i])
      # and show it with tabs
      for i,l in enumerate (block):
        if i == 0: txt += f"{h}:{m:02d}:{s:02d}\t{l}\n"
        else:      txt += f"\t{l}\n"
    return txt

  def cleanView (trans, struct):
    # parse blocksize - check > 40 and < 200
    if not ',' in struct: bs = None
    else: bs = int(struct.split(',')[1]) if int(struct.split(',')[1]) < 200 and int(struct.split(',')[1]) > 40 else None
    return VideoTranscriptTools.taCleaner (trans, int(struct.split(',')[0]), bs)

  def taCleaner (lines,tsCount,bs=None):
    if tsCount > len (lines): tsCount = 1

    org, tmp, trigger = tsCount, '', False
    for i,l in enumerate(lines): # all lines
      if tsCount and not i%(len(lines)//org): # trigger if ts should create
        tsCount -= 1
        trigger = True
      if trigger and l != '' and l[1] == ':': # create ts
        if i > 0: tmp += '\n'
        tmp += l.split('\t')[0]+'\n'          # create blockline
        trigger = False
      if '\t' in l:
        tmp += l.split('\t')[1]+'\n'
    # return tmp - if no block wanted
    if bs == None: bs = 60
    lines, tmp2, nl = tmp.split('\n'), '', ''
    for i,l in enumerate(lines): # build block
      if len (l) > 1 and l[1] != ':':
        words = l.split(' ')
        for w in words:
          if len (nl+' '+w) < bs:
            nl += ' '+w
          else:
            tmp2 += nl + '\n'
            nl = w
      else:
        tmp2 += l+'\n'
    return tmp2.replace('\n ','\n')
  def cyanbox (s):
    return "<table><tr><td align='center' width='60'><p style='background-color:powderblue'>"+\
           s+"</p></td><td><b>Token</b></td></tr></table>"

  def loadTranscripts (videoID, defaultLanguage, translationLanguage):
    try:    transcript_list = YouTubeTranscriptApi.list_transcripts(videoID)
    except: raise Exception ('wrong videoID '+videoID)
    try:    transcript = transcript_list.find_manually_created_transcript([defaultLanguage])
    except: transcript = None
    if not transcript:
      try:    transcript = transcript_list.find_generated_transcript([defaultLanguage])
      except: raise Exception ('no transcritpt for video '+videoID)
    dataTranscript  = transcript.fetch()

    translation, dataTranslation = None, None
    if translationLanguage:
      translation = VideoTranscriptTools.getTranscriptTranslation (videoID, defaultLanguage, translationLanguage)
      dataTranslation = translation.fetch() if translation else None

    return transcript, dataTranscript, translation, dataTranslation

  def getTranscriptTranslation (videoID, defaultLanguage, translationLanguage):
    try:
      ret = YouTubeTranscriptApi.list_transcripts (videoID).\
            find_generated_transcript([translationLanguage, defaultLanguage]).translate(translationLanguage)
    except:
      ret = None
      for transcript in YouTubeTranscriptApi.list_transcripts (videoID):
        if transcript.is_translatable:
          ret = transcript.translate(translationLanguage)
          break
    return ret


class YoutubeTranscript:
  def onTranslationButtonClick (self, b): self.doButtonClick (b, self.vb_translation, self.ta_translation, self.dataTranslation)
  def onDefaultButtonClick (self, b):     self.doButtonClick (b, self.vb_default, self.ta_default, self.dataTranscript)
  def doButtonClick (self, b, vb_, ta_, data):
    bu_cleanb   = vb_.children[0].children[3].children[1]
    bu_origb    = vb_.children[0].children[1]
    bu_tabviewb = vb_.children[0].children[2]
    if b == bu_origb:
      bu_tabviewb.style.button_color = bu_cleanb.style.button_color = None
      bu_origb.style.button_color= '#99bfc3'
      ta_.value = VideoTranscriptTools.originalView (data)
    elif b == bu_tabviewb:
      bu_origb.style.button_color = bu_cleanb.style.button_color = None
      bu_tabviewb.style.button_color= '#99bfc3'
      ta_.value = VideoTranscriptTools.timestampView (data)
    elif b == bu_cleanb:
      tmp = VideoTranscriptTools.timestampView (data)
      bu_tabviewb.style.button_color = bu_origb.style.button_color = None
      bu_cleanb.style.button_color = '#99bfc3'
      struct = vb_.children[0].children[3].children[0].value
      ta_.value = VideoTranscriptTools.cleanView ([l for l in tmp.split('\n') if l != ''], struct)

  def text_change (self, _):
    if _['owner'] == self.ta_default:
      self.vb_default.children[0].children[0].value = VideoTranscriptTools.cyanbox(str(int(len(self.ta_default.value) // VideoTranscriptTools.default_chartokfac+1)))
    else:
      self.vb_translation.children[0].children[0].value = VideoTranscriptTools.cyanbox(str(int(len(self.ta_translation.value) // VideoTranscriptTools.default_chartokfac+1)))


  def buildTranscriptTab (self, clicker):
    ta_ = Textarea (layout={'width':'auto', 'height':'380px'})
    bu_cleanb = Button (description='clean', layout={'width':'60px'},
                        tooltip='Comma seperated the number of generated timestamps and the max line lenght.')
    hb_clean  = HBox (children=[Text (value='3, 70',layout={'width':'65px'}),bu_cleanb], layout={'width':'130px'})
    bu_origb = Button (description='original', layout={'width':'70px'}, tooltip='Restore original transcript.')
    bu_tabviewb = Button (description='tab view', layout={'width':'70px'}, tooltip='Restore original transcript.')

    bu_cleanb.on_click (clicker)
    bu_origb.on_click (clicker)
    bu_tabviewb.on_click (clicker)

    hb_control = HBox (children=[HTML(layout={'width':'280px'}), bu_origb, bu_tabviewb, hb_clean])
    hb_control.children[0].value = VideoTranscriptTools.cyanbox ('---')

    bu_tabviewb.style.button_color= '#99bfc3'
    ta_.observe (self.text_change, names=['value'])
    vb_ = VBox (children=[hb_control,ta_])

    return ta_, vb_, hb_clean, hb_control.children[0].value


  def __init__(self, videoID, width=600, height=500, translationLanguage=None, defaultLanguage='en'):
    self.videoID, self.width, self.height, self.translationLanguage, self.defaultLanguage = videoID, width, height, translationLanguage, defaultLanguage
    self.transcript, self.dataTranscript, self.translation, self.dataTranslation = \
      VideoTranscriptTools.loadTranscripts (videoID, defaultLanguage, translationLanguage)

    self.ta_default, self.vb_default, self.hb_cleanDefault, self.hm_tokenDefaul = self.buildTranscriptTab (self.onDefaultButtonClick)
    self.ta_default.value = VideoTranscriptTools.timestampView (self.dataTranscript)
    self.hb_cleanDefault.children[0].value = f'{int(len(self.ta_default.value) // (VideoTranscriptTools.default_chartokfac * 250) +1)}, 68'

    self.ta_description = Textarea (layout={'width':'auto', 'height':f'{height-50}px'})

    self.widget = Tab (children=[self.vb_default],layout={'width':f'{width}px', 'height':f'{height}px'})
    self.widget.set_title(0, self.transcript.language)

    self.ta_translation, self.vb_translation = None, None
    if self.translation:
      self.ta_translation, self.vb_translation, self.hb_cleanTranslation, self.hm_tokenTranslation = self.buildTranscriptTab (self.onTranslationButtonClick)
      self.widget.children = [*self.widget.children, self.vb_translation]
      self.widget.set_title(1, self.translation.language)
      self.ta_translation.value = VideoTranscriptTools.timestampView (self.dataTranslation)
      self.hb_cleanTranslation.children[0].value = f'{int(len(self.ta_translation.value) // (VideoTranscriptTools.default_chartokfac * 250) +1)}, 68'

    self.widget.selected_index = 0




# show english (default) transcript and (otpional) the translation
vt = YoutubeTranscript ('8SF_h3xF3cE',translationLanguage='de')
display (vt.widget)
# Access transcription and translation with:
# vt.transcript, vt.dataTranscript, vt.translation, vt.dataTranslation
```

# YoutubePlayer

``` python
#@markdown
#@markdown <table><tr><td><font size=+2>
#@markdown
#@markdown ```python
#@markdown class MiniMediator:
#@markdown   def notify (self, event):
#@markdown     if event == "onVideoTimestamp": print (y.timestamp)
#@markdown #
#@markdown y = YouTubePlayer ('8SF_h3xF3cE', mediator=MiniMediator())
#@markdown ```
#@markdown </td></tr></table>
import os
from ipywidgets import HTML
import IPython
##############################################################################################################################################
##############################################################################################################################################
# google.colab.output-Patch
# It raises: AttributeError: module 'IPython.utils.traitlets' has no attribute 'Unicode'
# I searched for a long time about this error. Finally I found a solution in this thread:
# https://stackoverflow.com/questions/64886414/i-have-a-warning-error-when-plotting-with-plotly
##############################################################################################################################################
import os, time
if os.path.expanduser('~') != '/root': # not in hosted kernel
  try:
    srcfile     = os.__file__.replace ('os.py','site-packages/google/colab/data_table.py')
    bad_source  = 'from IPython.utils import traitlets as _traitlets'
    good_source = 'import traitlets as _traitlets'
    if os.path.exists(srcfile):
      with open(srcfile, 'r') as file: content = file.read()
      if bad_source in content:
        with open(srcfile, 'w') as file: file.write(content.replace(bad_source,good_source))
        time.sleep(1)
        from google.colab import output
        with open(srcfile, 'w') as file: file.write(content)
  except:
    from google.colab import output

from google.colab import output
##############################################################################################################################################
##############################################################################################################################################
class YouTubePlayer:
  def __init__(self, video_id, width=640, height=360, mediator=None):
    self.video_id, self.title, self.timestamp, self.mediator = video_id, '', -1, mediator
    output.register_callback('_js_fire_timestamp', self._js_fire_timestamp)
    self.buildPlayer(video_id, width, height)
    #if self.mediator: self.mediator.notify ("onVideoReady")

  def buildPlayer (self, video_id, width, height):
    display(HTML("""<html><body><div id="player"></div>
      <script>
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        var player;
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
              height: '"""+f'{height}'+"""',
              width: '"""+f'{width}'+"""',
              videoId: '"""+video_id+"""',
              events: {
                'onStateChange': onPlayerStateChange
              }});
        }
        var done = false;
        function onPlayerStateChange(event) {
            if (event.data == YT.PlayerState.PLAYING) {
                setTimeout(callbackTimestamp, 2000);
                done = false;
            } else {
                done = true;
            }
        }
        function callbackTimestamp() {
            if (!done) {
                var currentTime = player.getCurrentTime();
                google.colab.kernel.invokeFunction('_js_fire_timestamp', [currentTime], {});
                setTimeout(callbackTimestamp, 2000);
            }
        }
      </script></body></html>"""))

  def _js_fire_timestamp (self, ts):
    self.timestamp = ts
    if self.mediator: self.mediator.notify ("onVideoTimestamp")


#8SF_h3xF3cE
#M7lc1UVf-VE
import datetime

class MiniMedi:
  def notify (self, event):
    if event == "onVideoTimestamp":
      print(f'\ronVideoTimestamp {str(datetime.timedelta (seconds=int(y.timestamp-1)))}',end='')
    else:
      print (event)

#
y = YouTubePlayer ('8SF_h3xF3cE', mediator=MiniMedi())
```

# Chapterizer

<svg xmlns="http://www.w3.org/2000/svg">

<circle cx="50" cy="50" r="50" fill="red" />
</svg>

``` python
#@markdown
#@markdown <table><tr><td><font size=+2>
#@markdown
#@markdown ```python
#@markdown # try: '_7rMfsA24Ls' or '8SF_h3xF3cE'
#@markdown Chapterizer('8SF_h3xF3cE').widget
#@markdown ```
#@markdown </td></tr></table>
from youtubesearchpython import  Video
from ipywidgets import Text, Button, HBox, VBox, HTML
from ipywidgets import Button, Box, Layout, Textarea, Tab


class Chapterizer:
  dash = {}
  def instance (video):
    if not Chapterizer.dash: Chapterizer.dash = {}
    videoInfo = video if type (video) != str else Video.getInfo(f'https://www.youtube.com/watch?v={video}')
    if videoInfo['id'] in Chapterizer.dash: c = Chapterizer.dash[videoInfo['id']]
    else: c = Chapterizer.dash[videoInfo['id']] = {'chapterizer':Chapterizer(videoInfo)}
    return c['chapterizer']

  def __init__(self, videoInfo, mediator=None):
    # remember mediato
    self.mediator, self.videoInfo = mediator, videoInfo

    self.chaptersBuilder = ChaptersBuilder (self.videoInfo)
    self.descriptionChapters = DescriptionChapters (self.videoInfo['description'])

    if self.descriptionChapters.chapters:
      tabChilds = [self.chaptersBuilder.widget, self.descriptionChapters.widget]
    else:
      tabChilds = [self.chaptersBuilder.widget]
    self.tb_tab = Tab (children=tabChilds, layout={'width':'auto'})
    self.tb_tab.set_title(0, 'BUILDER')

    if self.descriptionChapters.chapters:
      self.tb_tab.set_title(1, 'from description')
      self.tb_tab.selected_index = 1
    self.hm_head = HTML(value=f"<font size='+2'><b>{self.videoInfo['title']}", layout={'width':'auto'})
    self.widget = VBox (children=[self.hm_head, self.tb_tab], layout={'width':'90%'})

  def hasDescriptionChapters (self):
    return len (self.descriptionChapters.chapters) > 0


class DescriptionChapters:
  def __init__(self, description):
    self.chapters     = DescriptionChapters.parseChaptersFromDescription (description)
    if self.chapters:
      self.buttonBox  = ButtonBox (descriptions=self.chapters) if len (self.chapters) else None
      self.widget     = self.buttonBox.widget if self.buttonBox else None
    else:
      self.buttonBox, self.widget = None, None


  def parseChaptersFromDescription (description):
    if not description: return []
    lines = description.split('\n')
    chaps = []
    for l in lines:
      if ':' in l:
        for i,c in enumerate(l):
          if c == ':':
            if i > 0 and l[i-1].isdigit() and i < len(l)-1 and l[i+1].isdigit():
              start = i - (2 if i > 1 and l[i-2].isdigit() else 1)
              for end,c in enumerate (l[i+1:]):
                if not c.isdigit() and c != ':': break
              chaps.append(l[start:end+i+1]+' '+l[end+i+2:])
              break
    return chaps

class ChaptersBuilder:
  def __init__(self, videoInfo):
    self.videoInfo = videoInfo
    self.widget = Button (description='build chapters')

class AutogenChapters:
  def __init__(self, VideoListItem):
    self.VideoListItem, self.chapters = VideoListItem, []


# try: '_7rMfsA24Ls' or '8SF_h3xF3cE' or 'CGpR2ILao5M' (no chapters in description)
c = Chapterizer.instance('_7rMfsA24Ls')
c.widget
```

# Collections

``` python
#@markdown Collections
_collections_yml=yaml.safe_load("""
statquest:
  title: "StatQuest - collections by the singing guy Josh Starmer"
  courses:
  - id: PLblh5JKOoLUJUNlfvCNhJMNjNNpt5ljcR
    title: "Histograms Clearly Explained - #66DaysOfData"
    description: ''
    loaded: False
  - id: PLblh5JKOoLUK0FLuzwntyYI10UQFUhsY9
    title: "Histograms Clearly Explained - Statistics Fundamentals"
    description: ''
    loaded: False
  - id: PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI
    title: "A Gentle Introduction to Machine Learning"
    description: ''
    loaded: False
  - id: PLblh5JKOoLUIxGDQs4LFFD--41Vzf-ME1
    title: "Neural Networks / Deep Learning"
    description: ''
    loaded: False
mit:
  title: "MIT courses around deep learning"
  courses:
  - id: PLUl4u3cNGP63WbdFxL8giv4yhgdMGaZNA
    title: "6.0001 Introduction to Computer Science and Programming in Python"
    description: ''
    loaded: False
  - id: PLUl4u3cNGP62EaLLH92E_VCN4izBKK6OE
    title: "MIT 18.S096 Matrix Calculus For Machine Learning And Beyond"
    description: ''
    loaded: False
  - id: PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI
    title: "MIT 6.S191: Introduction to Deep Learning"
    description: ''
    loaded: False
  - id: PL80kAHvQbh-pT4lCkDT53zT8DKmhE0idB
    title: "EfficientML.ai Lecture, Fall 2023, MIT 6.5940"
    description: ''
    loaded: False
stanford:
  title: "Stanford: collection of free courses: CS221, CS224, CS229, CS330"
  courses:
  - id: PLoROMvodv4rOca_Ovz1DvdtWuz8BfSWL2
    title: "CS221:  2021 - Artificial Intelligence: Principles and Techniques (Percy Liang)"
    description: ''
    loaded: False
  - id: PLoROMvodv4rO1NB9TD4iUZ3qghGEGtqNX
    title: "CS221:  2019 - Artificial Intelligence: Principles and Techniques (Percy Liang)"
    description: ''
    loaded: False
  - id: PLoROMvodv4rOSH4v6133s9LFPRHjEmbmJ
    title: "CS224N: 2021 - NLP with Deep Learning (Christopher Manning)"
    description: ''
    loaded: False
  - id: PLoROMvodv4rPLKxIpqhjhPgdQy7imNkDn
    title: "CS224W: 2021 - Machine Learning with Graphs (Jure Leskovec)"
    description: ''
    loaded: False
  - id: PLoROMvodv4rPt5D0zs3YhbWSZA8Q_DyiJ
    title: "CS224U: 2021 - Natural Language Understanding (Christopher Potts)"
    description: ''
    loaded: False
  - id: PLoROMvodv4rMiGQp3WXShtMGgzqpfVfbU
    title: "CS229:  2018 - Machine Learning Full Course (Andrew Ng)"
    description: ''
    loaded: False
  - id: PLoROMvodv4rNH7qL6-efu_q2_bPuy0adh
    title: "CS229:  2019 - Machine Learning Course (Anand Avati)"
    description: ''
    loaded: False
  - id: PLoROMvodv4rNjRoawgt72BBNwL2V7doGI
    title: "CS330:  2022 - Deep Multi-Task & Meta Learning - What is multi-task learning? (Chelsea Finn)"
dlfc:
  title: "Practical Deep Learning for Coders / fast.ai live coding & tutorials"
  courses:
  - id: PLfYUBJiXbdtSvpQjSnJJ_PmDQB_VyT5iU
    title: "Practical Deep Learning for Coders 2022"
    description: ''
    loaded: False
  - id: PLfYUBJiXbdtRUvTUYpLdfHHp9a58nWVXP
    title: "Practical Deep Learning 2022 Part 2"
    description: ''
    loaded: False
  - id: PLfYUBJiXbdtSLBPJ1GMx-sQWf6iNhb8mM
    title: "fast.ai live coding & tutorials"
    description: ''
    loaded: False
  - id: PLfYUBJiXbdtSgU6S_3l6pX-4hQYKNJZFU
    title: "APL & array programming"
    description: ''
    loaded: False
  - id: PLfYUBJiXbdtRL3FMB3GoWHRI8ieU6FhfM
    title: "Practical Deep Learning for Coders (2020)"
    description: ''
    loaded: False
  - id: PLfYUBJiXbdtSIJb-Qd3pw0cqCbkGeS0xn
    title: "Practical Deep Learning for Coders 2019"
mathpl:
  title: "Calculus & Co - a math playlist collection"
  courses:
  - id: PLZHQObOWTQDMsr9K-rj53DwVRMYO3t5Yr
    title: "Essence of calculus, by Grant Sanderson (3Blue1Brown)"
    description: ''
    loaded: False
  - id: PLtmWHNX-gukIc92m1K0P6bIOnZb-mg0hY
    title: "Computational Linear Algebra, by Rachel Thomas (fastai)"
    description: ''
    loaded: False
"""[1:])
use_short = True # @param {type:"boolean"}
if use_short: _collections_yml=yaml.safe_load("""
mathpl:
  title: "Calculus & Co - a math playlist collection"
  courses:
  - id: PLZHQObOWTQDMsr9K-rj53DwVRMYO3t5Yr
    title: "Essence of calculus, by Grant Sanderson (3Blue1Brown)"
    description: ''
    loaded: False
  - id: PLtmWHNX-gukIc92m1K0P6bIOnZb-mg0hY
    title: "Computational Linear Algebra, by Rachel Thomas (fastai)"
    description: ''
    loaded: False
"""[1:])
```

``` python
```

    {mathpl: {title: Calculus & Co - a math playlist collection, courses: [{id: PLZHQObOWTQDMsr9K-rj53DwVRMYO3t5Yr, title: Essence of calculus, by Grant Sanderson (3Blue1Brown), description: , loaded: False}, {id: PLtmWHNX-gukIc92m1K0P6bIOnZb-mg0hY, title: Computational Linear Algebra, by Rachel Thomas (fastai), description: , loaded: False}]}}[mathpl]

``` python
import os, yaml
try:     from pytube import Playlist
except:  os.system ('pip install pytube')
finally: from pytube import Playlist

class Collections:
  def __init__(self, folder):
    self.content, self.folder = {}, folder

    # write collection yamls and create folders if not exists
    for collection_folder in _collections_yml:
      if not os.path.exists(f'{folder}/{collection_folder}'):
        os.makedirs(f'{folder}/{collection_folder}')

        # and write the __collections.yml with the playlist infos
        with open(f'{folder}/{collection_folder}/__collection.yml', 'w') as file:
          yaml.dump(_collections_yml[collection_folder], file)

  def playlist (self, collection, nr):
    course = _collections_yml[collection]['courses'][nr]
    playlistID = course['id']

    # load playlist via pytube
    if not course['loaded']:
      try:    self.urls         = Playlist(f"https://www.youtube.com/playlist?list={playlistID}")
      except: raise Exception  ('BIG_OOPS from pytube')
      try:    self.description  = self.urls.description
      except: self.description  = 'no description in pytube'
      try:    ids               = [link.split('?v=')[-1] for link in self.urls]
      except: raise Exception  ('No Links in playlist')

      # write empty id yaml with link to course (nr in list)
      for id in ids:
        dump_obj = {'position':nr}
        with open(f'{self.folder}/{collection}/{id}.yml', 'w') as file:
          yaml.dump(dump_obj, file)


    #playlist = Playlist(f"https://www.youtube.com/playlist?list={playlistID}")
    #return playlist.videos

  def log (self):
    for collection in _collections_yml:
      print (collection)
      for i,course in enumerate(_collections_yml[collection]['courses']):
        print (f"  {i}: {course['title']}")

  def activate (self, collection):
    # loop all playlists in collection
    #for coursenr, course in enumerate (_collections_yml[collection]['courses']):
      #

    #   # load playlist via pytube
    #   if not course['loaded'] or True:
    #     try:    self.playlist     = Playlist(f"https://www.youtube.com/playlist?list={course['id']}")
    #     except: raise Exception  ('BIG_OOPS from pytube')
    #     try:    self.description  = self.playlist.description
    #     except: self.description  = 'no description in pytube'
    #     try:    ids               = [link.split('?v=')[-1] for link in self.playlist]
    #     except: raise Exception  ('No Links in playlist')

    #     # write empty id yaml with link to course (nr in list)
    #     for id in ids:
    #       dump_obj = {'collection_course':coursenr}
    #       with open(f'{self.folder}/{collection}/{id}.yml', 'w') as file:
    #         yaml.dump(dump_obj, file)

    # # first switch forces yamler to scan folder and bind yamls
    # self.yamler.switch (collection)
    # self.yamler.dump ()


    pass


    # if collection in self.collections:
    #   self.selected = collection
    #   for coursenr, playlist in enumerate(self.collections[collection]['courses']):
    #     if playlist['loaded']: continue
    #     try:    self.playlist = Playlist(f"https://www.youtube.com/playlist?list={playlist['id']}")
    #     except: raise Exception ('BIG_OOPS from pytube')
    #     try:    self.description  = self.playlist.description
    #     except: self.description  = 'no description in pytube'
    #     try:    self.links        = [link for link in self.playlist]
    #     except: links  = []
    #     self.videos    = [link.split('?v=')[-1] for link in self.links]
    #     playlist['description'] = self.description
    #     playlist['loaded'] = True
    #     for id in self.videos:
    #       dump_obj = {'collection_course':coursenr}
    #       with open(f'{path}/{collection}/{id}.yml', 'w') as file:
    #         yaml.dump(dump_obj, file)

!rm -rf yumler/; mkdir yumler
c = Collections(folder='yumler')
```

# LazyStudent

``` python
class LazyStudent:
  def __init__ (self, topic=None):
    self.collections  = Collections (folder='yumler')
    self.yamler       = Yamler (folder='yumler', mediator=self)
    self.widget       = HBox ()
    self.youtubeList  = YoutubeList (mediator=self, yamler=self.yamler)
    self.widget.children  = [self.youtubeList.widget]

    #self.newList ()

  def notify (self, event, id, obj=None):
    print (event)#, id, obj)


    # if event == "onYoutubeList_selectPlaylist":
    #   self.collections.playlist (self.yamler.topic,id)
    #   self.yamler.activate (course)
    #   self.yamler.config['collection']['courses'][nr]['loaded'] = True
    #   self.yamler.dump ()




    # if event == "onYamlerActivate":
    #   # chapterizer for video
    #   chapterizer = Chapterizer.instance (id)


    # # load yamls and select
    # if event == "onYoutubeList_add":
    #   d = self.yamler.bind (id) # create empty id object in yamler.data
    #   d['_']['descriptionChapters'] = chapterizer.descriptionChapters.chapters

    # # set decoration: üìã: has description chapter / üìù: has generated chapters / üìú: has loops
    # if event == "onYoutubeListItem_widgetInitState":
    #   if chapterizer.hasDescriptionChapters(): obj.value += 'üìã'

    # # show chapterizer widget by selection
    # if event == "onYoutubeList_select":
    #   self.widget.children = [self.youtubeList.widget, chapterizer.widget]

    # # remove chapterizer widget
    # if event == "xxxxonYoutubeList_del":
    #   self.widget.children = [self.youtubeList.widget]

    # if event == "onYamlerBeforeActivate":
    #   print ('before',obj)

    # dump changed data
    #nr_of_changes = self.yamler.dump ()
    #if nr_of_changes: print (f'dumped {nr_of_changes} yamls')

  def activate (self, course):
    self.youtubeList  = YoutubeList (mediator=self, yamler=self.yamler)
    self.widget.children  = [self.youtubeList.widget]

deepLearningForCodersVideos = \
['8SF_h3xF3cE', 'F4tvM4Vb3A0', 'hBBOjCiFcuo', 'toUgBQv1BT8', '_rXzeWq4C6w', 'AdhG64NF76E', 'p4ZZq0736Po', 'htiNBPxcXgo', '_7rMfsA24Ls',
 '6StU6UtZEbU', 'Tf-8F5q8Xww', '_xIzPbCgutY', 'vGdB4eI4KBs', 'veqj0DsZSXU', '0Hi2r4CaHvk', '9YZaYjRKuEc', 'vGsc_NbU7xc', 'nlVOG2Nzc3k']
# 'CGpR2ILao5M' - no description chapters


cl = LazyStudent ()
cl.widget
```

    onYamlerReady

    KeyError: 'title'
    [0;31m---------------------------------------------------------------------------[0m
    [0;31mKeyError[0m                                  Traceback (most recent call last)
    Cell [0;32mIn[146], line 63[0m
    [1;32m     57[0m deepLearningForCodersVideos [38;5;241m=[39m \
    [1;32m     58[0m [[38;5;124m'[39m[38;5;124m8SF_h3xF3cE[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mF4tvM4Vb3A0[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mhBBOjCiFcuo[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mtoUgBQv1BT8[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124m_rXzeWq4C6w[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mAdhG64NF76E[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mp4ZZq0736Po[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mhtiNBPxcXgo[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124m_7rMfsA24Ls[39m[38;5;124m'[39m,
    [1;32m     59[0m  [38;5;124m'[39m[38;5;124m6StU6UtZEbU[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mTf-8F5q8Xww[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124m_xIzPbCgutY[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mvGdB4eI4KBs[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mveqj0DsZSXU[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124m0Hi2r4CaHvk[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124m9YZaYjRKuEc[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mvGsc_NbU7xc[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mnlVOG2Nzc3k[39m[38;5;124m'[39m]
    [1;32m     60[0m [38;5;66;03m# 'CGpR2ILao5M' - no description chapters[39;00m
    [0;32m---> 63[0m cl [38;5;241m=[39m [43mLazyStudent[49m[43m [49m[43m([49m[43m)[49m
    [1;32m     64[0m cl[38;5;241m.[39mwidget

    Cell [0;32mIn[146], line 6[0m, in [0;36mLazyStudent.__init__[0;34m(self, topic)[0m
    [1;32m      4[0m [38;5;28mself[39m[38;5;241m.[39myamler       [38;5;241m=[39m Yamler (folder[38;5;241m=[39m[38;5;124m'[39m[38;5;124myumler[39m[38;5;124m'[39m, mediator[38;5;241m=[39m[38;5;28mself[39m)
    [1;32m      5[0m [38;5;28mself[39m[38;5;241m.[39mwidget       [38;5;241m=[39m HBox ()
    [0;32m----> 6[0m [38;5;28mself[39m[38;5;241m.[39myoutubeList  [38;5;241m=[39m [43mYoutubeList[49m[43m [49m[43m([49m[43mmediator[49m[38;5;241;43m=[39;49m[38;5;28;43mself[39;49m[43m,[49m[43m [49m[43myamler[49m[38;5;241;43m=[39;49m[38;5;28;43mself[39;49m[38;5;241;43m.[39;49m[43myamler[49m[43m)[49m
    [1;32m      7[0m [38;5;28mself[39m[38;5;241m.[39mwidget[38;5;241m.[39mchildren  [38;5;241m=[39m [[38;5;28mself[39m[38;5;241m.[39myoutubeList[38;5;241m.[39mwidget]

    Cell [0;32mIn[144], line 90[0m, in [0;36mYoutubeList.__init__[0;34m(self, idList, mediator, yamler, height)[0m
    [1;32m     87[0m [38;5;28mself[39m[38;5;241m.[39mmediator, [38;5;28mself[39m[38;5;241m.[39midList, [38;5;28mself[39m[38;5;241m.[39myamler [38;5;241m=[39m mediator, idList, yamler
    [1;32m     89[0m [38;5;28;01mif[39;00m yamler [38;5;129;01mand[39;00m yamler[38;5;241m.[39mtopics:
    [0;32m---> 90[0m   items [38;5;241m=[39m [43m[[49m[43m([49m[43myamler[49m[38;5;241;43m.[39;49m[43mtopics[49m[43m[[49m[43mk[49m[43m][49m[43m[[49m[38;5;124;43m'[39;49m[38;5;124;43mtitle[39;49m[38;5;124;43m'[39;49m[43m][49m[43m,[49m[43m [49m[43mk[49m[43m)[49m[43m [49m[38;5;28;43;01mfor[39;49;00m[43m [49m[43mk[49m[43m [49m[38;5;129;43;01min[39;49;00m[43m [49m[43myamler[49m[38;5;241;43m.[39;49m[43mtopics[49m[43m][49m
    [1;32m     91[0m   [38;5;28mself[39m[38;5;241m.[39mdd_topic [38;5;241m=[39m Dropdown(options[38;5;241m=[39mitems, layout[38;5;241m=[39m{[38;5;124m'[39m[38;5;124mwidth[39m[38;5;124m'[39m:[38;5;124m'[39m[38;5;124mauto[39m[38;5;124m'[39m})
    [1;32m     92[0m [38;5;28;01melse[39;00m:  [38;5;28mself[39m[38;5;241m.[39mdd_topic [38;5;241m=[39m [38;5;28;01mNone[39;00m

    Cell [0;32mIn[144], line 90[0m, in [0;36m<listcomp>[0;34m(.0)[0m
    [1;32m     87[0m [38;5;28mself[39m[38;5;241m.[39mmediator, [38;5;28mself[39m[38;5;241m.[39midList, [38;5;28mself[39m[38;5;241m.[39myamler [38;5;241m=[39m mediator, idList, yamler
    [1;32m     89[0m [38;5;28;01mif[39;00m yamler [38;5;129;01mand[39;00m yamler[38;5;241m.[39mtopics:
    [0;32m---> 90[0m   items [38;5;241m=[39m [([43myamler[49m[38;5;241;43m.[39;49m[43mtopics[49m[43m[[49m[43mk[49m[43m][49m[43m[[49m[38;5;124;43m'[39;49m[38;5;124;43mtitle[39;49m[38;5;124;43m'[39;49m[43m][49m, k) [38;5;28;01mfor[39;00m k [38;5;129;01min[39;00m yamler[38;5;241m.[39mtopics]
    [1;32m     91[0m   [38;5;28mself[39m[38;5;241m.[39mdd_topic [38;5;241m=[39m Dropdown(options[38;5;241m=[39mitems, layout[38;5;241m=[39m{[38;5;124m'[39m[38;5;124mwidth[39m[38;5;124m'[39m:[38;5;124m'[39m[38;5;124mauto[39m[38;5;124m'[39m})
    [1;32m     92[0m [38;5;28;01melse[39;00m:  [38;5;28mself[39m[38;5;241m.[39mdd_topic [38;5;241m=[39m [38;5;28;01mNone[39;00m

    [0;31mKeyError[0m: 'title'

``` python
cl.activate ('mathpl')
```

``` python
cl.yamler.config
```

    {}

# \_

nbdev process

1.  new git repo
2.  clone it, change folder, execute nbdev_new and nbdev_install_hooks
3.  git add . / git commit -m / git push
4.  enable GitHub Pages: ‚ÄúSettings‚Äù tab, ‚ÄúPages‚Äù on the left, ‚ÄúBranch‚Äù
    to ‚Äúgh-pages‚Äù, ‚ÄúSave‚Äù.

``` python
Button (description='üìã', layout={'width': 'auto', 'height': 'auto'})
```

    Button(description='üìã', layout=Layout(height='auto', width='auto'), style=ButtonStyle())

``` python
import yaml

with open ("yumler/_collection.yml", 'r') as stream:
  d = yaml.safe_load(stream)
d
```

    {'title': 'Deep Learning for Coders',
     'courses': [['PLfYUBJiXbdtSvpQjSnJJ_PmDQB_VyT5iU',
       'Practical Deep Learning for Coders 2022'],
      ['PLfYUBJiXbdtRUvTUYpLdfHHp9a58nWVXP',
       'Practical Deep Learning 2022 Part 2'],
      ['PLfYUBJiXbdtSLBPJ1GMx-sQWf6iNhb8mM', 'fast.ai live coding & tutorials'],
      ['PLfYUBJiXbdtSgU6S_3l6pX-4hQYKNJZFU', 'APL & array programming'],
      ['PLfYUBJiXbdtRL3FMB3GoWHRI8ieU6FhfM',
       'Practical Deep Learning for Coders (2020)'],
      ['PLfYUBJiXbdtSIJb-Qd3pw0cqCbkGeS0xn',
       'Practical Deep Learning for Coders 2019']]}

``` python
import yaml
obj = {'statquet':[ {'title':'tit'},
                    {'courses': [ ['PLblh5JKOoLUJUNlfvCNhJMNjNNpt5ljcR', """Histograms Clearly Explained - #66DaysOfData"""],
                                  ['PLoROMvodv4rO1NB9TD4iUZ3qghGEGtqNX', """CS221:  2021 - Artificial Intelligence: Principles and Techniques (Percy Liang)"""]]}]}
obj
```

    {'statquet': [{'title': 'tit'},
      {'courses': [['PLblh5JKOoLUJUNlfvCNhJMNjNNpt5ljcR',
         'Histograms Clearly Explained - #66DaysOfData'],
        ['PLoROMvodv4rO1NB9TD4iUZ3qghGEGtqNX',
         'CS221:  2021 - Artificial Intelligence: Principles and Techniques (Percy Liang)']]}]}

``` python
with open("yumler/test.yml", 'w') as file:
  yaml.dump(obj, file)
```
